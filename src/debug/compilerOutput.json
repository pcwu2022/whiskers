[
  {
    "level": "info",
    "message": "Parsed sprite: Sprite2",
    "timestamp": "2026-01-23T09:55:52.989Z",
    "context": {
      "scripts": [
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "flagClicked"
              ],
              "next": {
                "type": "looks",
                "name": "say",
                "args": [
                  "Hello! I'm going to dance!"
                ],
                "next": {
                  "type": "control",
                  "name": "wait",
                  "args": [
                    1
                  ],
                  "next": {
                    "type": "control",
                    "name": "repeat",
                    "args": [
                      4
                    ],
                    "next": {
                      "type": "motion",
                      "name": "move",
                      "args": [
                        50
                      ],
                      "next": {
                        "type": "motion",
                        "name": "turnRight",
                        "args": [
                          90
                        ],
                        "next": {
                          "type": "control",
                          "name": "wait",
                          "args": [
                            0.3
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "keyPressed",
                "space"
              ],
              "next": {
                "type": "looks",
                "name": "say",
                "args": [
                  "You pressed space!",
                  "for",
                  1,
                  "seconds"
                ]
              }
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "keyPressed",
                "up"
              ],
              "next": {
                "type": "motion",
                "name": "move",
                "args": [
                  20
                ]
              }
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "keyPressed",
                "down"
              ],
              "next": {
                "type": "motion",
                "name": "move",
                "args": [
                  -20
                ]
              }
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "keyPressed",
                "left"
              ],
              "next": {
                "type": "motion",
                "name": "turnLeft",
                "args": [
                  15
                ]
              }
            }
          ]
        },
        {
          "blocks": [
            {
              "type": "event",
              "name": "when",
              "args": [
                "keyPressed",
                "right"
              ],
              "next": {
                "type": "motion",
                "name": "turnRight",
                "args": [
                  15
                ]
              }
            }
          ]
        }
      ],
      "variables": {},
      "lists": {}
    }
  },
  {
    "level": "info",
    "message": "Multi-sprite generator output",
    "timestamp": "2026-01-23T09:55:52.991Z",
    "context": {
      "js": "// Generated Scratch-like JavaScript code\n// Runtime support functions\nconst scratchRuntime = {\n    sprites: {},\n    stage: { \n        width: 480, \n        height: 360, \n        backgroundColor: 'white',\n        currentBackdrop: 0,\n        backdrops: ['backdrop1'], // Placeholder for costume names\n        volume: 100\n    },\n    currentSprite: 'Sprite1',\n    variables: {},\n    lists: {},\n    procedures: {},\n    events: {},\n    greenFlagHandlers: [],\n    answer: '',\n    broadcasts: {},\n    running: false,\n    clones: [],\n    timer: Date.now(),\n    mouse: { x: 0, y: 0, down: false },\n    pressedKeys: {},\n    dragMode: 'not draggable',\n\n    // Initialize a sprite with full Scratch capabilities\n    initSprite: function(name, options) {\n        options = options || {};\n        const self = this;\n        this.sprites[name] = {\n            name: name,\n            x: options.x || 0,\n            y: options.y || 0,\n            direction: options.direction || 90,\n            visible: options.visible !== false,\n            size: options.size || 100,\n            rotationStyle: options.rotationStyle || 'all around',\n            draggable: options.draggable || false,\n            costumes: options.costumes || ['costume1'],\n            currentCostume: options.currentCostume || 0,\n            effects: {\n                color: 0,\n                fisheye: 0,\n                whirl: 0,\n                pixelate: 0,\n                mosaic: 0,\n                brightness: 0,\n                ghost: 0\n            },\n            isClone: options.isClone || false,\n            cloneOf: options.cloneOf || null,\n            layer: Object.keys(self.sprites).length,\n            \n            // Motion methods\n            move: function(steps) {\n                const radians = (this.direction - 90) * Math.PI / 180;\n                this.x += steps * Math.cos(radians);\n                this.y -= steps * Math.sin(radians);\n                self.updateSpritePosition(name);\n            },\n            turnRight: function(degrees) {\n                this.direction = (this.direction + degrees) % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            turnLeft: function(degrees) {\n                this.direction = (this.direction - degrees + 360) % 360;\n                self.updateSpriteTransform(name);\n            },\n            pointInDirection: function(dir) {\n                this.direction = dir % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            pointTowards: function(target) {\n                let targetX, targetY;\n                if (target === 'mouse-pointer') {\n                    targetX = self.mouse.x;\n                    targetY = self.mouse.y;\n                } else if (self.sprites[target]) {\n                    targetX = self.sprites[target].x;\n                    targetY = self.sprites[target].y;\n                } else {\n                    return;\n                }\n                const dx = targetX - this.x;\n                const dy = targetY - this.y;\n                this.direction = (Math.atan2(dx, dy) * 180 / Math.PI + 90) % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            goTo: function(x, y) {\n                this.x = x;\n                this.y = y;\n                self.updateSpritePosition(name);\n            },\n            goToTarget: function(target) {\n                if (target === 'mouse-pointer') {\n                    this.x = self.mouse.x;\n                    this.y = self.mouse.y;\n                } else if (target === 'random') {\n                    this.x = Math.floor(Math.random() * self.stage.width) - (self.stage.width / 2);\n                    this.y = Math.floor(Math.random() * self.stage.height) - (self.stage.height / 2);\n                } else if (self.sprites[target]) {\n                    this.x = self.sprites[target].x;\n                    this.y = self.sprites[target].y;\n                }\n                self.updateSpritePosition(name);\n            },\n            setX: function(x) {\n                this.x = x;\n                self.updateSpritePosition(name);\n            },\n            setY: function(y) {\n                this.y = y;\n                self.updateSpritePosition(name);\n            },\n            changeX: function(dx) {\n                this.x += dx;\n                self.updateSpritePosition(name);\n            },\n            changeY: function(dy) {\n                this.y += dy;\n                self.updateSpritePosition(name);\n            },\n            ifOnEdgeBounce: function() {\n                const halfWidth = 15 * (this.size / 100);\n                const halfHeight = 15 * (this.size / 100);\n                const stageHalfWidth = self.stage.width / 2;\n                const stageHalfHeight = self.stage.height / 2;\n                \n                if (this.x + halfWidth > stageHalfWidth) {\n                    this.x = stageHalfWidth - halfWidth;\n                    this.direction = 180 - this.direction;\n                }\n                if (this.x - halfWidth < -stageHalfWidth) {\n                    this.x = -stageHalfWidth + halfWidth;\n                    this.direction = 180 - this.direction;\n                }\n                if (this.y + halfHeight > stageHalfHeight) {\n                    this.y = stageHalfHeight - halfHeight;\n                    this.direction = -this.direction;\n                }\n                if (this.y - halfHeight < -stageHalfHeight) {\n                    this.y = -stageHalfHeight + halfHeight;\n                    this.direction = -this.direction;\n                }\n                this.direction = ((this.direction % 360) + 360) % 360;\n                self.updateSpritePosition(name);\n                self.updateSpriteTransform(name);\n            },\n            setRotationStyle: function(style) {\n                this.rotationStyle = style;\n                self.updateSpriteTransform(name);\n            },\n            \n            // Looks methods\n            say: function(message, seconds) {\n                self.showSpeechBubble(name, message, seconds, false);\n            },\n            think: function(message, seconds) {\n                self.showSpeechBubble(name, message, seconds, true);\n            },\n            hide: function() {\n                this.visible = false;\n                const spriteDiv = document.getElementById('sprite-' + name);\n                if (spriteDiv) spriteDiv.style.display = 'none';\n            },\n            show: function() {\n                this.visible = true;\n                const spriteDiv = document.getElementById('sprite-' + name);\n                if (spriteDiv) spriteDiv.style.display = 'block';\n            },\n            setSize: function(size) {\n                this.size = Math.max(1, size);\n                self.updateSpriteTransform(name);\n            },\n            changeSize: function(change) {\n                this.size = Math.max(1, this.size + change);\n                self.updateSpriteTransform(name);\n            },\n            setEffect: function(effect, value) {\n                if (this.effects.hasOwnProperty(effect)) {\n                    this.effects[effect] = value;\n                    self.updateSpriteEffects(name);\n                }\n            },\n            changeEffect: function(effect, change) {\n                if (this.effects.hasOwnProperty(effect)) {\n                    this.effects[effect] += change;\n                    self.updateSpriteEffects(name);\n                }\n            },\n            clearEffects: function() {\n                for (let key in this.effects) {\n                    this.effects[key] = 0;\n                }\n                self.updateSpriteEffects(name);\n            },\n            switchCostume: function(costume) {\n                if (typeof costume === 'number') {\n                    this.currentCostume = ((costume - 1) % this.costumes.length + this.costumes.length) % this.costumes.length;\n                } else {\n                    const idx = this.costumes.indexOf(costume);\n                    if (idx >= 0) this.currentCostume = idx;\n                }\n                console.log(name + ' switched to costume: ' + this.costumes[this.currentCostume]);\n            },\n            nextCostume: function() {\n                this.currentCostume = (this.currentCostume + 1) % this.costumes.length;\n                console.log(name + ' switched to costume: ' + this.costumes[this.currentCostume]);\n            },\n            goToFrontLayer: function() {\n                const maxLayer = Object.keys(self.sprites).length;\n                this.layer = maxLayer;\n                self.updateSpriteLayers();\n            },\n            goToBackLayer: function() {\n                this.layer = 0;\n                self.updateSpriteLayers();\n            },\n            goForwardLayers: function(n) {\n                this.layer += n;\n                self.updateSpriteLayers();\n            },\n            goBackwardLayers: function(n) {\n                this.layer = Math.max(0, this.layer - n);\n                self.updateSpriteLayers();\n            },\n            \n            // Sensing helpers\n            isTouching: function(target) {\n                if (target === 'edge') {\n                    const halfWidth = 15 * (this.size / 100);\n                    const halfHeight = 15 * (this.size / 100);\n                    return Math.abs(this.x) + halfWidth >= self.stage.width / 2 ||\n                           Math.abs(this.y) + halfHeight >= self.stage.height / 2;\n                }\n                if (target === 'mouse-pointer') {\n                    const dx = self.mouse.x - this.x;\n                    const dy = self.mouse.y - this.y;\n                    return Math.sqrt(dx*dx + dy*dy) < 30 * (this.size / 100);\n                }\n                if (self.sprites[target]) {\n                    const other = self.sprites[target];\n                    const dx = other.x - this.x;\n                    const dy = other.y - this.y;\n                    const dist = 30 * (this.size / 100) + 30 * (other.size / 100);\n                    return Math.sqrt(dx*dx + dy*dy) < dist;\n                }\n                return false;\n            },\n            distanceTo: function(target) {\n                let targetX, targetY;\n                if (target === 'mouse-pointer') {\n                    targetX = self.mouse.x;\n                    targetY = self.mouse.y;\n                } else if (self.sprites[target]) {\n                    targetX = self.sprites[target].x;\n                    targetY = self.sprites[target].y;\n                } else {\n                    return 0;\n                }\n                const dx = targetX - this.x;\n                const dy = targetY - this.y;\n                return Math.sqrt(dx*dx + dy*dy);\n            }\n        };\n        \n        // Create visual element if stage is ready\n        this.createSpriteElement(name);\n    },\n\n    // Update sprite position in DOM\n    updateSpritePosition: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            spriteDiv.style.left = (sprite.x + this.stage.width/2 - 15) + 'px';\n            spriteDiv.style.bottom = (sprite.y + this.stage.height/2 - 15) + 'px';\n        }\n    },\n\n    // Update sprite transform (rotation and size)\n    updateSpriteTransform: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            const scale = sprite.size / 100;\n            let rotation = sprite.direction - 90;\n            \n            if (sprite.rotationStyle === \"don't rotate\") {\n                rotation = 0;\n            } else if (sprite.rotationStyle === 'left-right') {\n                rotation = 0;\n                if (sprite.direction > 180) {\n                    spriteDiv.style.transform = 'scaleX(-1) scale(' + scale + ')';\n                    return;\n                }\n            }\n            \n            spriteDiv.style.transform = 'rotate(' + rotation + 'deg) scale(' + scale + ')';\n        }\n    },\n\n    // Update sprite effects (color, ghost, etc.)\n    updateSpriteEffects: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            const effects = sprite.effects;\n            let filter = '';\n            \n            if (effects.brightness !== 0) {\n                filter += 'brightness(' + (100 + effects.brightness) + '%) ';\n            }\n            if (effects.ghost !== 0) {\n                spriteDiv.style.opacity = (100 - Math.min(100, Math.max(0, effects.ghost))) / 100;\n            }\n            if (effects.color !== 0) {\n                filter += 'hue-rotate(' + (effects.color * 3.6) + 'deg) ';\n            }\n            if (effects.fisheye !== 0) {\n                // Fisheye approximation\n                const scale = 1 + effects.fisheye / 100;\n                filter += 'scale(' + scale + ') ';\n            }\n            if (effects.whirl !== 0) {\n                filter += 'rotate(' + effects.whirl + 'deg) ';\n            }\n            if (effects.pixelate !== 0) {\n                // Pixelate is hard in CSS, we approximate with blur\n                filter += 'blur(' + Math.max(0, effects.pixelate / 10) + 'px) ';\n            }\n            \n            spriteDiv.style.filter = filter.trim() || 'none';\n        }\n    },\n\n    // Update sprite layer ordering\n    updateSpriteLayers: function() {\n        const sortedSprites = Object.values(this.sprites).sort(function(a, b) {\n            return a.layer - b.layer;\n        });\n        sortedSprites.forEach(function(sprite, index) {\n            const spriteDiv = document.getElementById('sprite-' + sprite.name);\n            if (spriteDiv) {\n                spriteDiv.style.zIndex = index + 1;\n            }\n        });\n    },\n\n    // Show speech bubble\n    showSpeechBubble: function(spriteName, message, seconds, isThought) {\n        const sprite = this.sprites[spriteName];\n        const stageDiv = document.getElementById('stage');\n        if (!stageDiv || !sprite) return;\n\n        // Remove existing bubble\n        const existingBubble = document.getElementById('speech-' + spriteName);\n        if (existingBubble) existingBubble.remove();\n\n        if (message === '' || message === null || message === undefined) return;\n\n        // Create bubble\n        const bubble = document.createElement('div');\n        bubble.id = 'speech-' + spriteName;\n        bubble.style.position = 'absolute';\n        bubble.style.backgroundColor = 'white';\n        bubble.style.border = '2px solid black';\n        bubble.style.borderRadius = isThought ? '20px' : '10px';\n        bubble.style.padding = '8px 12px';\n        bubble.style.left = (sprite.x + this.stage.width/2 + 20) + 'px';\n        bubble.style.bottom = (sprite.y + this.stage.height/2 + 30) + 'px';\n        bubble.style.whiteSpace = 'nowrap';\n        bubble.style.zIndex = '100';\n        bubble.style.fontSize = '14px';\n        bubble.textContent = isThought ? 'ðŸ’­ ' + message : message;\n        stageDiv.appendChild(bubble);\n\n        console.log(spriteName + (isThought ? ' thinks: ' : ' says: ') + message);\n\n        if (seconds) {\n            setTimeout(function() { bubble.remove(); }, seconds * 1000);\n        }\n    },\n\n    // Create DOM element for a sprite\n    createSpriteElement: function(name) {\n        const stageDiv = document.getElementById('stage');\n        if (!stageDiv) return;\n        \n        // Don't create duplicate elements\n        if (document.getElementById('sprite-' + name)) return;\n        \n        const sprite = this.sprites[name];\n        if (!sprite) return;\n        \n        // Use different colors for different sprites\n        const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8d8ea'];\n        const colorIndex = Object.keys(this.sprites).indexOf(name) % colors.length;\n        \n        const spriteDiv = document.createElement('div');\n        spriteDiv.id = 'sprite-' + name;\n        spriteDiv.style.position = 'absolute';\n        spriteDiv.style.width = '30px';\n        spriteDiv.style.height = '30px';\n        spriteDiv.style.backgroundColor = colors[colorIndex];\n        spriteDiv.style.borderRadius = '50%';\n        spriteDiv.style.left = (sprite.x + this.stage.width/2 - 15) + 'px';\n        spriteDiv.style.bottom = (sprite.y + this.stage.height/2 - 15) + 'px';\n        spriteDiv.style.transform = 'rotate(0deg)';\n        spriteDiv.style.transition = 'left 0.05s, bottom 0.05s';\n        spriteDiv.style.display = sprite.visible ? 'flex' : 'none';\n        spriteDiv.style.alignItems = 'center';\n        spriteDiv.style.justifyContent = 'center';\n        spriteDiv.style.fontSize = '10px';\n        spriteDiv.style.fontWeight = 'bold';\n        spriteDiv.style.color = 'white';\n        spriteDiv.style.textShadow = '0 0 2px black';\n        spriteDiv.style.cursor = sprite.draggable ? 'grab' : 'default';\n        spriteDiv.style.zIndex = sprite.layer || 1;\n        spriteDiv.textContent = name.charAt(0);\n        \n        // Make draggable if enabled\n        if (sprite.draggable) {\n            const self = this;\n            let isDragging = false;\n            let dragOffsetX = 0;\n            let dragOffsetY = 0;\n            \n            spriteDiv.addEventListener('mousedown', function(e) {\n                if (self.dragMode === 'draggable' || sprite.draggable) {\n                    isDragging = true;\n                    dragOffsetX = e.clientX - spriteDiv.getBoundingClientRect().left - 15;\n                    dragOffsetY = e.clientY - spriteDiv.getBoundingClientRect().top - 15;\n                    spriteDiv.style.cursor = 'grabbing';\n                }\n            });\n            \n            document.addEventListener('mousemove', function(e) {\n                if (isDragging) {\n                    const rect = stageDiv.getBoundingClientRect();\n                    sprite.x = (e.clientX - rect.left - self.stage.width/2) - dragOffsetX;\n                    sprite.y = (self.stage.height/2 - (e.clientY - rect.top)) + dragOffsetY;\n                    self.updateSpritePosition(name);\n                }\n            });\n            \n            document.addEventListener('mouseup', function() {\n                isDragging = false;\n                spriteDiv.style.cursor = 'grab';\n            });\n        }\n        \n        stageDiv.appendChild(spriteDiv);\n    },\n\n    // Clone management\n    createClone: function(spriteName) {\n        const original = this.sprites[spriteName];\n        if (!original) return null;\n        \n        const cloneId = spriteName + '_clone_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);\n        \n        this.initSprite(cloneId, {\n            x: original.x,\n            y: original.y,\n            direction: original.direction,\n            visible: original.visible,\n            size: original.size,\n            rotationStyle: original.rotationStyle,\n            costumes: original.costumes.slice(),\n            currentCostume: original.currentCostume,\n            isClone: true,\n            cloneOf: spriteName\n        });\n        \n        this.clones.push(cloneId);\n        \n        // Trigger clone start event\n        if (this.events['cloneStart_' + spriteName]) {\n            const self = this;\n            this.events['cloneStart_' + spriteName].forEach(function(callback) {\n                self.currentSprite = cloneId;\n                callback();\n            });\n        }\n        \n        return cloneId;\n    },\n    \n    deleteClone: function(cloneName) {\n        const sprite = this.sprites[cloneName];\n        if (!sprite || !sprite.isClone) return;\n        \n        // Remove visual element\n        const spriteDiv = document.getElementById('sprite-' + cloneName);\n        if (spriteDiv) spriteDiv.remove();\n        \n        // Remove speech bubble\n        const bubble = document.getElementById('speech-' + cloneName);\n        if (bubble) bubble.remove();\n        \n        // Remove from tracking\n        delete this.sprites[cloneName];\n        const idx = this.clones.indexOf(cloneName);\n        if (idx >= 0) this.clones.splice(idx, 1);\n    },\n\n    // Stage/Backdrop methods\n    switchBackdrop: function(backdrop) {\n        if (typeof backdrop === 'number') {\n            this.stage.currentBackdrop = ((backdrop - 1) % this.stage.backdrops.length + this.stage.backdrops.length) % this.stage.backdrops.length;\n        } else {\n            const idx = this.stage.backdrops.indexOf(backdrop);\n            if (idx >= 0) this.stage.currentBackdrop = idx;\n        }\n        const backdropName = this.stage.backdrops[this.stage.currentBackdrop];\n        console.log('Switched to backdrop: ' + backdropName);\n        \n        // Trigger backdrop change event\n        if (this.events['backdropSwitch_' + backdropName]) {\n            this.events['backdropSwitch_' + backdropName].forEach(function(callback) { callback(); });\n        }\n    },\n    \n    nextBackdrop: function() {\n        this.stage.currentBackdrop = (this.stage.currentBackdrop + 1) % this.stage.backdrops.length;\n        console.log('Switched to backdrop: ' + this.stage.backdrops[this.stage.currentBackdrop]);\n    },\n\n    // Initialize the runtime\n    init: function() {\n        const self = this;\n        \n        // Setup UI when DOM is ready\n        const setupUI = function() {\n            const stageDiv = document.getElementById('stage');\n            if (stageDiv) {\n                // Use the actual rendered size of the stage\n                const rect = stageDiv.getBoundingClientRect();\n                self.stage.width = rect.width || 480;\n                self.stage.height = rect.height || 360;\n                \n                stageDiv.style.backgroundColor = self.stage.backgroundColor;\n                stageDiv.style.position = 'relative';\n                stageDiv.style.overflow = 'hidden';\n\n                // Create sprite elements for all initialized sprites\n                Object.keys(self.sprites).forEach(function(name) {\n                    self.createSpriteElement(name);\n                });\n            }\n        };\n\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', setupUI);\n        } else {\n            setupUI();\n        }\n\n        // Track mouse position\n        document.addEventListener('mousemove', function(e) {\n            const stageDiv = document.getElementById('stage');\n            if (stageDiv) {\n                const rect = stageDiv.getBoundingClientRect();\n                self.mouse.x = e.clientX - rect.left - self.stage.width/2;\n                self.mouse.y = self.stage.height/2 - (e.clientY - rect.top);\n            }\n        });\n        \n        document.addEventListener('mousedown', function() { self.mouse.down = true; });\n        document.addEventListener('mouseup', function() { self.mouse.down = false; });\n\n        // Register keyboard event handlers\n        document.addEventListener('keydown', function(e) {\n            self.pressedKeys[e.key.toLowerCase()] = true;\n            const keyEvent = 'keyPressed_' + e.key.toLowerCase();\n            if (self.events[keyEvent] && Array.isArray(self.events[keyEvent])) {\n                self.events[keyEvent].forEach(function(callback) { callback(); });\n            }\n        });\n        \n        document.addEventListener('keyup', function(e) {\n            delete self.pressedKeys[e.key.toLowerCase()];\n        });\n        \n        // Click on sprite events\n        document.addEventListener('click', function(e) {\n            const target = e.target;\n            if (target && target.id && target.id.startsWith('sprite-')) {\n                const spriteName = target.id.replace('sprite-', '');\n                if (self.events['spriteClicked_' + spriteName]) {\n                    self.events['spriteClicked_' + spriteName].forEach(function(callback) { callback(); });\n                }\n            }\n        });\n    },\n\n    // Register green flag handler\n    onGreenFlag: function(callback) {\n        this.greenFlagHandlers.push(callback);\n    },\n\n    // Trigger green flag\n    greenFlag: function() {\n        const self = this;\n        this.running = true;\n        this.timer = Date.now();\n        console.log('ðŸš© Green flag clicked!');\n        this.greenFlagHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e) {\n                console.error('Error in green flag handler:', e);\n            }\n        });\n    },\n\n    // Stop all scripts\n    stopAll: function() {\n        this.running = false;\n        // Delete all clones\n        const self = this;\n        this.clones.slice().forEach(function(clone) {\n            self.deleteClone(clone);\n        });\n        console.log('ðŸ›‘ All scripts stopped');\n    },\n\n    // Timer functions\n    getTimer: function() {\n        return (Date.now() - this.timer) / 1000;\n    },\n    \n    resetTimer: function() {\n        this.timer = Date.now();\n    },\n\n    // Keyboard sensing\n    isKeyPressed: function(key) {\n        if (key === 'any') {\n            return Object.keys(this.pressedKeys).length > 0;\n        }\n        return !!this.pressedKeys[key.toLowerCase()];\n    },\n\n    // Broadcasting system\n    broadcast: function(message) {\n        console.log('ðŸ“¢ Broadcasting: ' + message);\n        if (this.broadcasts[message] && Array.isArray(this.broadcasts[message])) {\n            this.broadcasts[message].forEach(function(callback) { callback(); });\n        }\n    },\n    \n    broadcastAndWait: async function(message) {\n        console.log('ðŸ“¢ Broadcasting and waiting: ' + message);\n        if (this.broadcasts[message] && Array.isArray(this.broadcasts[message])) {\n            const promises = this.broadcasts[message].map(function(callback) {\n                return Promise.resolve(callback());\n            });\n            await Promise.all(promises);\n        }\n    },\n\n    // Register a broadcast receiver\n    onBroadcast: function(message, callback) {\n        if (!this.broadcasts[message]) {\n            this.broadcasts[message] = [];\n        }\n        this.broadcasts[message].push(callback);\n    },\n\n    // Register an event handler\n    onEvent: function(event, callback) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(callback);\n    },\n\n    // Wait for seconds\n    wait: function(seconds) {\n        return new Promise(function(resolve) {\n            setTimeout(resolve, seconds * 1000);\n        });\n    },\n\n    // Ask a question and get an answer\n    ask: async function(question) {\n        const self = this;\n        return new Promise(function(resolve) {\n            const stageDiv = document.getElementById('stage');\n            if (!stageDiv) { resolve(''); return; }\n\n            const askDiv = document.createElement('div');\n            askDiv.id = 'ask-prompt';\n            askDiv.style.position = 'absolute';\n            askDiv.style.bottom = '10px';\n            askDiv.style.left = '10px';\n            askDiv.style.right = '10px';\n            askDiv.style.backgroundColor = 'white';\n            askDiv.style.border = '2px solid black';\n            askDiv.style.borderRadius = '8px';\n            askDiv.style.padding = '10px';\n            askDiv.style.zIndex = '200';\n\n            const questionText = document.createElement('div');\n            questionText.textContent = question;\n            questionText.style.marginBottom = '8px';\n            askDiv.appendChild(questionText);\n\n            const inputField = document.createElement('input');\n            inputField.type = 'text';\n            inputField.style.width = 'calc(100% - 70px)';\n            inputField.style.padding = '5px';\n            inputField.style.border = '1px solid #ccc';\n            inputField.style.borderRadius = '4px';\n            askDiv.appendChild(inputField);\n\n            const submitButton = document.createElement('button');\n            submitButton.textContent = 'âœ“';\n            submitButton.style.marginLeft = '5px';\n            submitButton.style.padding = '5px 15px';\n            submitButton.style.backgroundColor = '#4CAF50';\n            submitButton.style.color = 'white';\n            submitButton.style.border = 'none';\n            submitButton.style.borderRadius = '4px';\n            submitButton.style.cursor = 'pointer';\n            askDiv.appendChild(submitButton);\n\n            const submit = function() {\n                self.answer = inputField.value;\n                askDiv.remove();\n                resolve(self.answer);\n            };\n\n            submitButton.onclick = submit;\n            inputField.addEventListener('keypress', function(e) {\n                if (e.key === 'Enter') submit();\n            });\n\n            stageDiv.appendChild(askDiv);\n            inputField.focus();\n        });\n    },\n    \n    // Utility functions for math operations\n    pickRandom: function(from, to) {\n        if (Number.isInteger(from) && Number.isInteger(to)) {\n            return Math.floor(Math.random() * (to - from + 1)) + from;\n        }\n        return Math.random() * (to - from) + from;\n    },\n    \n    // List operations\n    addToList: function(listName, item) {\n        if (!this.lists[listName]) this.lists[listName] = [];\n        this.lists[listName].push(item);\n    },\n    \n    deleteOfList: function(listName, index) {\n        if (!this.lists[listName]) return;\n        if (index === 'all') {\n            this.lists[listName] = [];\n        } else if (index === 'last') {\n            this.lists[listName].pop();\n        } else {\n            const idx = parseInt(index) - 1;\n            if (idx >= 0 && idx < this.lists[listName].length) {\n                this.lists[listName].splice(idx, 1);\n            }\n        }\n    },\n    \n    insertAtList: function(listName, index, item) {\n        if (!this.lists[listName]) this.lists[listName] = [];\n        const idx = index === 'last' ? this.lists[listName].length : parseInt(index) - 1;\n        this.lists[listName].splice(idx, 0, item);\n    },\n    \n    replaceItemOfList: function(listName, index, item) {\n        if (!this.lists[listName]) return;\n        const idx = index === 'last' ? this.lists[listName].length - 1 : parseInt(index) - 1;\n        if (idx >= 0 && idx < this.lists[listName].length) {\n            this.lists[listName][idx] = item;\n        }\n    },\n    \n    itemOfList: function(listName, index) {\n        if (!this.lists[listName]) return '';\n        const idx = index === 'last' ? this.lists[listName].length - 1 : parseInt(index) - 1;\n        return (idx >= 0 && idx < this.lists[listName].length) ? this.lists[listName][idx] : '';\n    },\n    \n    itemNumberInList: function(listName, item) {\n        if (!this.lists[listName]) return 0;\n        const idx = this.lists[listName].indexOf(item);\n        return idx >= 0 ? idx + 1 : 0;\n    },\n    \n    lengthOfList: function(listName) {\n        return this.lists[listName] ? this.lists[listName].length : 0;\n    },\n    \n    listContains: function(listName, item) {\n        return this.lists[listName] ? this.lists[listName].includes(item) : false;\n    },\n    \n    // Sound (placeholder implementations)\n    playSound: function(soundName) {\n        console.log('ðŸ”Š Playing sound: ' + soundName);\n    },\n    \n    playSoundUntilDone: async function(soundName) {\n        console.log('ðŸ”Š Playing sound until done: ' + soundName);\n        // Placeholder - in real implementation, would wait for audio to finish\n        await this.wait(1);\n    },\n    \n    stopAllSounds: function() {\n        console.log('ðŸ”‡ Stopping all sounds');\n    },\n    \n    setVolume: function(volume) {\n        this.stage.volume = Math.max(0, Math.min(100, volume));\n        console.log('ðŸ”Š Volume set to: ' + this.stage.volume + '%');\n    },\n    \n    changeVolume: function(change) {\n        this.stage.volume = Math.max(0, Math.min(100, this.stage.volume + change));\n        console.log('ðŸ”Š Volume changed to: ' + this.stage.volume + '%');\n    },\n    \n    // Username (placeholder)\n    getUsername: function() {\n        return 'ScratchUser';\n    }\n};\n\n// Initialize the runtime\nscratchRuntime.init();\n// Variables\n// No variables defined\n\n// Lists\n// No lists defined\n\n// Initialize Sprites\ndelete scratchRuntime.sprites[\"Sprite1\"];\nscratchRuntime.initSprite(\"Sprite2\", {\n    x: 0,\n    y: 0,\n    direction: 90,\n    visible: true,\n    size: 100,\n    rotationStyle: 'all around',\n    costumes: ['costume1'],\n    currentCostume: 0\n});\n\n// Custom Procedures\n// No procedures defined\n\n// Scripts\n// === Sprite2 Scripts ===\n(function() {\n    const CURRENT_SPRITE = \"Sprite2\";\n    const IS_STAGE = false;\n    const sprite = scratchRuntime.sprites[CURRENT_SPRITE];\n\n    // Script 1\n    // When green flag clicked\n    scratchRuntime.onGreenFlag(async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].say(\"Hello! I'm going to dance!\");\n        await scratchRuntime.wait(1);\n        for (let _i = 0; _i < 4; _i++) {\n            scratchRuntime.sprites[\"Sprite2\"].move(50);\n            scratchRuntime.sprites[\"Sprite2\"].turnRight(90);\n            await scratchRuntime.wait(0.3);\n        }\n    });\n\n    // Script 2\n    // When   key pressed\n    scratchRuntime.onEvent(\"keyPressed_ \", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].say(\"You pressed space!\");\n    });\n\n    // Script 3\n    // When arrowup key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowup\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].move(20);\n    });\n\n    // Script 4\n    // When arrowdown key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowdown\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].move(-20);\n    });\n\n    // Script 5\n    // When arrowleft key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowleft\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].turnLeft(15);\n    });\n\n    // Script 6\n    // When arrowright key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowright\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].turnRight(15);\n    });\n\n})();\n\n",
      "html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Scratch Preview</title>\n    <style>\n        * {\n            box-sizing: border-box;\n            margin: 0;\n            padding: 0;\n        }\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            background-color: #f0f0f0;\n            height: 100vh;\n            display: flex;\n            flex-direction: column;\n        }\n        \n        .stage-container {\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n            padding: 8px;\n            gap: 8px;\n        }\n        \n        .controls {\n            display: flex;\n            gap: 6px;\n            align-items: center;\n        }\n        \n        .flag-btn {\n            width: 36px;\n            height: 36px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 20px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            background-color: #4CAF50;\n            transition: all 0.15s;\n        }\n        .flag-btn:hover {\n            background-color: #45a049;\n            transform: scale(1.05);\n        }\n        .flag-btn:active {\n            transform: scale(0.95);\n        }\n        \n        .stop-btn {\n            width: 36px;\n            height: 36px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 20px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            background-color: #e53935;\n            transition: all 0.15s;\n        }\n        .stop-btn:hover {\n            background-color: #c62828;\n            transform: scale(1.05);\n        }\n        .stop-btn:active {\n            transform: scale(0.95);\n        }\n        \n        #stage {\n            flex: 1;\n            background-color: white;\n            border: 2px solid #d0d0d0;\n            border-radius: 8px;\n            position: relative;\n            overflow: hidden;\n            min-height: 200px;\n        }\n        \n        #console {\n            height: 100px;\n            border: 1px solid #d0d0d0;\n            border-radius: 6px;\n            padding: 6px 8px;\n            overflow-y: auto;\n            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;\n            font-size: 11px;\n            background-color: #1a1a2e;\n            color: #eee;\n        }\n        \n        #console:empty::before {\n            content: 'Console...';\n            color: #555;\n        }\n        \n        .log-line {\n            padding: 1px 0;\n            border-bottom: 1px solid #2a2a3e;\n        }\n        .log-line:last-child {\n            border-bottom: none;\n        }\n        .log-line.say {\n            color: #4fc3f7;\n        }\n        .log-line.flag {\n            color: #81c784;\n        }\n        .log-line.stop {\n            color: #e57373;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"stage-container\">\n        <div class=\"controls\">\n            <button id=\"flag-btn\" class=\"flag-btn\" title=\"Green Flag - Start\">ðŸš©</button>\n            <button id=\"stop-btn\" class=\"stop-btn\" title=\"Stop and Reset\">ðŸ›‘</button>\n        </div>\n        <div id=\"stage\"></div>\n        <div id=\"console\"></div>\n    </div>\n\n    <script>\n        // Console logging override\n        const originalLog = console.log;\n        const originalError = console.error;\n        \n        function log(msg, cls) {\n            const c = document.getElementById('console');\n            if (c) {\n                const line = document.createElement('div');\n                line.className = 'log-line' + (cls ? ' ' + cls : '');\n                line.textContent = msg;\n                c.appendChild(line);\n                c.scrollTop = c.scrollHeight;\n            }\n        }\n        \n        console.log = function() {\n            originalLog.apply(console, arguments);\n            const msg = Array.from(arguments).join(' ');\n            let cls = '';\n            if (msg.includes('says:')) cls = 'say';\n            else if (msg.includes('ðŸš©')) cls = 'flag';\n            else if (msg.includes('ðŸ›‘')) cls = 'stop';\n            log(msg, cls);\n        };\n        \n        console.error = function() {\n            originalError.apply(console, arguments);\n            log('Error: ' + Array.from(arguments).join(' '), 'stop');\n        };\n        \n        // Green Flag button\n        document.getElementById('flag-btn').addEventListener('click', function() {\n            document.getElementById('console').innerHTML = '';\n            if (typeof scratchRuntime !== 'undefined') {\n                scratchRuntime.greenFlag();\n            }\n        });\n        \n        // Stop button (also resets)\n        document.getElementById('stop-btn').addEventListener('click', function() {\n            if (typeof scratchRuntime !== 'undefined') {\n                scratchRuntime.stopAll();\n            }\n            // Reset by reloading\n            setTimeout(function() { location.reload(); }, 100);\n        });\n        \n        // Generated program code\n        // Generated Scratch-like JavaScript code\n// Runtime support functions\nconst scratchRuntime = {\n    sprites: {},\n    stage: { \n        width: 480, \n        height: 360, \n        backgroundColor: 'white',\n        currentBackdrop: 0,\n        backdrops: ['backdrop1'], // Placeholder for costume names\n        volume: 100\n    },\n    currentSprite: 'Sprite1',\n    variables: {},\n    lists: {},\n    procedures: {},\n    events: {},\n    greenFlagHandlers: [],\n    answer: '',\n    broadcasts: {},\n    running: false,\n    clones: [],\n    timer: Date.now(),\n    mouse: { x: 0, y: 0, down: false },\n    pressedKeys: {},\n    dragMode: 'not draggable',\n\n    // Initialize a sprite with full Scratch capabilities\n    initSprite: function(name, options) {\n        options = options || {};\n        const self = this;\n        this.sprites[name] = {\n            name: name,\n            x: options.x || 0,\n            y: options.y || 0,\n            direction: options.direction || 90,\n            visible: options.visible !== false,\n            size: options.size || 100,\n            rotationStyle: options.rotationStyle || 'all around',\n            draggable: options.draggable || false,\n            costumes: options.costumes || ['costume1'],\n            currentCostume: options.currentCostume || 0,\n            effects: {\n                color: 0,\n                fisheye: 0,\n                whirl: 0,\n                pixelate: 0,\n                mosaic: 0,\n                brightness: 0,\n                ghost: 0\n            },\n            isClone: options.isClone || false,\n            cloneOf: options.cloneOf || null,\n            layer: Object.keys(self.sprites).length,\n            \n            // Motion methods\n            move: function(steps) {\n                const radians = (this.direction - 90) * Math.PI / 180;\n                this.x += steps * Math.cos(radians);\n                this.y -= steps * Math.sin(radians);\n                self.updateSpritePosition(name);\n            },\n            turnRight: function(degrees) {\n                this.direction = (this.direction + degrees) % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            turnLeft: function(degrees) {\n                this.direction = (this.direction - degrees + 360) % 360;\n                self.updateSpriteTransform(name);\n            },\n            pointInDirection: function(dir) {\n                this.direction = dir % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            pointTowards: function(target) {\n                let targetX, targetY;\n                if (target === 'mouse-pointer') {\n                    targetX = self.mouse.x;\n                    targetY = self.mouse.y;\n                } else if (self.sprites[target]) {\n                    targetX = self.sprites[target].x;\n                    targetY = self.sprites[target].y;\n                } else {\n                    return;\n                }\n                const dx = targetX - this.x;\n                const dy = targetY - this.y;\n                this.direction = (Math.atan2(dx, dy) * 180 / Math.PI + 90) % 360;\n                if (this.direction < 0) this.direction += 360;\n                self.updateSpriteTransform(name);\n            },\n            goTo: function(x, y) {\n                this.x = x;\n                this.y = y;\n                self.updateSpritePosition(name);\n            },\n            goToTarget: function(target) {\n                if (target === 'mouse-pointer') {\n                    this.x = self.mouse.x;\n                    this.y = self.mouse.y;\n                } else if (target === 'random') {\n                    this.x = Math.floor(Math.random() * self.stage.width) - (self.stage.width / 2);\n                    this.y = Math.floor(Math.random() * self.stage.height) - (self.stage.height / 2);\n                } else if (self.sprites[target]) {\n                    this.x = self.sprites[target].x;\n                    this.y = self.sprites[target].y;\n                }\n                self.updateSpritePosition(name);\n            },\n            setX: function(x) {\n                this.x = x;\n                self.updateSpritePosition(name);\n            },\n            setY: function(y) {\n                this.y = y;\n                self.updateSpritePosition(name);\n            },\n            changeX: function(dx) {\n                this.x += dx;\n                self.updateSpritePosition(name);\n            },\n            changeY: function(dy) {\n                this.y += dy;\n                self.updateSpritePosition(name);\n            },\n            ifOnEdgeBounce: function() {\n                const halfWidth = 15 * (this.size / 100);\n                const halfHeight = 15 * (this.size / 100);\n                const stageHalfWidth = self.stage.width / 2;\n                const stageHalfHeight = self.stage.height / 2;\n                \n                if (this.x + halfWidth > stageHalfWidth) {\n                    this.x = stageHalfWidth - halfWidth;\n                    this.direction = 180 - this.direction;\n                }\n                if (this.x - halfWidth < -stageHalfWidth) {\n                    this.x = -stageHalfWidth + halfWidth;\n                    this.direction = 180 - this.direction;\n                }\n                if (this.y + halfHeight > stageHalfHeight) {\n                    this.y = stageHalfHeight - halfHeight;\n                    this.direction = -this.direction;\n                }\n                if (this.y - halfHeight < -stageHalfHeight) {\n                    this.y = -stageHalfHeight + halfHeight;\n                    this.direction = -this.direction;\n                }\n                this.direction = ((this.direction % 360) + 360) % 360;\n                self.updateSpritePosition(name);\n                self.updateSpriteTransform(name);\n            },\n            setRotationStyle: function(style) {\n                this.rotationStyle = style;\n                self.updateSpriteTransform(name);\n            },\n            \n            // Looks methods\n            say: function(message, seconds) {\n                self.showSpeechBubble(name, message, seconds, false);\n            },\n            think: function(message, seconds) {\n                self.showSpeechBubble(name, message, seconds, true);\n            },\n            hide: function() {\n                this.visible = false;\n                const spriteDiv = document.getElementById('sprite-' + name);\n                if (spriteDiv) spriteDiv.style.display = 'none';\n            },\n            show: function() {\n                this.visible = true;\n                const spriteDiv = document.getElementById('sprite-' + name);\n                if (spriteDiv) spriteDiv.style.display = 'block';\n            },\n            setSize: function(size) {\n                this.size = Math.max(1, size);\n                self.updateSpriteTransform(name);\n            },\n            changeSize: function(change) {\n                this.size = Math.max(1, this.size + change);\n                self.updateSpriteTransform(name);\n            },\n            setEffect: function(effect, value) {\n                if (this.effects.hasOwnProperty(effect)) {\n                    this.effects[effect] = value;\n                    self.updateSpriteEffects(name);\n                }\n            },\n            changeEffect: function(effect, change) {\n                if (this.effects.hasOwnProperty(effect)) {\n                    this.effects[effect] += change;\n                    self.updateSpriteEffects(name);\n                }\n            },\n            clearEffects: function() {\n                for (let key in this.effects) {\n                    this.effects[key] = 0;\n                }\n                self.updateSpriteEffects(name);\n            },\n            switchCostume: function(costume) {\n                if (typeof costume === 'number') {\n                    this.currentCostume = ((costume - 1) % this.costumes.length + this.costumes.length) % this.costumes.length;\n                } else {\n                    const idx = this.costumes.indexOf(costume);\n                    if (idx >= 0) this.currentCostume = idx;\n                }\n                console.log(name + ' switched to costume: ' + this.costumes[this.currentCostume]);\n            },\n            nextCostume: function() {\n                this.currentCostume = (this.currentCostume + 1) % this.costumes.length;\n                console.log(name + ' switched to costume: ' + this.costumes[this.currentCostume]);\n            },\n            goToFrontLayer: function() {\n                const maxLayer = Object.keys(self.sprites).length;\n                this.layer = maxLayer;\n                self.updateSpriteLayers();\n            },\n            goToBackLayer: function() {\n                this.layer = 0;\n                self.updateSpriteLayers();\n            },\n            goForwardLayers: function(n) {\n                this.layer += n;\n                self.updateSpriteLayers();\n            },\n            goBackwardLayers: function(n) {\n                this.layer = Math.max(0, this.layer - n);\n                self.updateSpriteLayers();\n            },\n            \n            // Sensing helpers\n            isTouching: function(target) {\n                if (target === 'edge') {\n                    const halfWidth = 15 * (this.size / 100);\n                    const halfHeight = 15 * (this.size / 100);\n                    return Math.abs(this.x) + halfWidth >= self.stage.width / 2 ||\n                           Math.abs(this.y) + halfHeight >= self.stage.height / 2;\n                }\n                if (target === 'mouse-pointer') {\n                    const dx = self.mouse.x - this.x;\n                    const dy = self.mouse.y - this.y;\n                    return Math.sqrt(dx*dx + dy*dy) < 30 * (this.size / 100);\n                }\n                if (self.sprites[target]) {\n                    const other = self.sprites[target];\n                    const dx = other.x - this.x;\n                    const dy = other.y - this.y;\n                    const dist = 30 * (this.size / 100) + 30 * (other.size / 100);\n                    return Math.sqrt(dx*dx + dy*dy) < dist;\n                }\n                return false;\n            },\n            distanceTo: function(target) {\n                let targetX, targetY;\n                if (target === 'mouse-pointer') {\n                    targetX = self.mouse.x;\n                    targetY = self.mouse.y;\n                } else if (self.sprites[target]) {\n                    targetX = self.sprites[target].x;\n                    targetY = self.sprites[target].y;\n                } else {\n                    return 0;\n                }\n                const dx = targetX - this.x;\n                const dy = targetY - this.y;\n                return Math.sqrt(dx*dx + dy*dy);\n            }\n        };\n        \n        // Create visual element if stage is ready\n        this.createSpriteElement(name);\n    },\n\n    // Update sprite position in DOM\n    updateSpritePosition: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            spriteDiv.style.left = (sprite.x + this.stage.width/2 - 15) + 'px';\n            spriteDiv.style.bottom = (sprite.y + this.stage.height/2 - 15) + 'px';\n        }\n    },\n\n    // Update sprite transform (rotation and size)\n    updateSpriteTransform: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            const scale = sprite.size / 100;\n            let rotation = sprite.direction - 90;\n            \n            if (sprite.rotationStyle === \"don't rotate\") {\n                rotation = 0;\n            } else if (sprite.rotationStyle === 'left-right') {\n                rotation = 0;\n                if (sprite.direction > 180) {\n                    spriteDiv.style.transform = 'scaleX(-1) scale(' + scale + ')';\n                    return;\n                }\n            }\n            \n            spriteDiv.style.transform = 'rotate(' + rotation + 'deg) scale(' + scale + ')';\n        }\n    },\n\n    // Update sprite effects (color, ghost, etc.)\n    updateSpriteEffects: function(name) {\n        const sprite = this.sprites[name];\n        const spriteDiv = document.getElementById('sprite-' + name);\n        if (spriteDiv && sprite) {\n            const effects = sprite.effects;\n            let filter = '';\n            \n            if (effects.brightness !== 0) {\n                filter += 'brightness(' + (100 + effects.brightness) + '%) ';\n            }\n            if (effects.ghost !== 0) {\n                spriteDiv.style.opacity = (100 - Math.min(100, Math.max(0, effects.ghost))) / 100;\n            }\n            if (effects.color !== 0) {\n                filter += 'hue-rotate(' + (effects.color * 3.6) + 'deg) ';\n            }\n            if (effects.fisheye !== 0) {\n                // Fisheye approximation\n                const scale = 1 + effects.fisheye / 100;\n                filter += 'scale(' + scale + ') ';\n            }\n            if (effects.whirl !== 0) {\n                filter += 'rotate(' + effects.whirl + 'deg) ';\n            }\n            if (effects.pixelate !== 0) {\n                // Pixelate is hard in CSS, we approximate with blur\n                filter += 'blur(' + Math.max(0, effects.pixelate / 10) + 'px) ';\n            }\n            \n            spriteDiv.style.filter = filter.trim() || 'none';\n        }\n    },\n\n    // Update sprite layer ordering\n    updateSpriteLayers: function() {\n        const sortedSprites = Object.values(this.sprites).sort(function(a, b) {\n            return a.layer - b.layer;\n        });\n        sortedSprites.forEach(function(sprite, index) {\n            const spriteDiv = document.getElementById('sprite-' + sprite.name);\n            if (spriteDiv) {\n                spriteDiv.style.zIndex = index + 1;\n            }\n        });\n    },\n\n    // Show speech bubble\n    showSpeechBubble: function(spriteName, message, seconds, isThought) {\n        const sprite = this.sprites[spriteName];\n        const stageDiv = document.getElementById('stage');\n        if (!stageDiv || !sprite) return;\n\n        // Remove existing bubble\n        const existingBubble = document.getElementById('speech-' + spriteName);\n        if (existingBubble) existingBubble.remove();\n\n        if (message === '' || message === null || message === undefined) return;\n\n        // Create bubble\n        const bubble = document.createElement('div');\n        bubble.id = 'speech-' + spriteName;\n        bubble.style.position = 'absolute';\n        bubble.style.backgroundColor = 'white';\n        bubble.style.border = '2px solid black';\n        bubble.style.borderRadius = isThought ? '20px' : '10px';\n        bubble.style.padding = '8px 12px';\n        bubble.style.left = (sprite.x + this.stage.width/2 + 20) + 'px';\n        bubble.style.bottom = (sprite.y + this.stage.height/2 + 30) + 'px';\n        bubble.style.whiteSpace = 'nowrap';\n        bubble.style.zIndex = '100';\n        bubble.style.fontSize = '14px';\n        bubble.textContent = isThought ? 'ðŸ’­ ' + message : message;\n        stageDiv.appendChild(bubble);\n\n        console.log(spriteName + (isThought ? ' thinks: ' : ' says: ') + message);\n\n        if (seconds) {\n            setTimeout(function() { bubble.remove(); }, seconds * 1000);\n        }\n    },\n\n    // Create DOM element for a sprite\n    createSpriteElement: function(name) {\n        const stageDiv = document.getElementById('stage');\n        if (!stageDiv) return;\n        \n        // Don't create duplicate elements\n        if (document.getElementById('sprite-' + name)) return;\n        \n        const sprite = this.sprites[name];\n        if (!sprite) return;\n        \n        // Use different colors for different sprites\n        const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8d8ea'];\n        const colorIndex = Object.keys(this.sprites).indexOf(name) % colors.length;\n        \n        const spriteDiv = document.createElement('div');\n        spriteDiv.id = 'sprite-' + name;\n        spriteDiv.style.position = 'absolute';\n        spriteDiv.style.width = '30px';\n        spriteDiv.style.height = '30px';\n        spriteDiv.style.backgroundColor = colors[colorIndex];\n        spriteDiv.style.borderRadius = '50%';\n        spriteDiv.style.left = (sprite.x + this.stage.width/2 - 15) + 'px';\n        spriteDiv.style.bottom = (sprite.y + this.stage.height/2 - 15) + 'px';\n        spriteDiv.style.transform = 'rotate(0deg)';\n        spriteDiv.style.transition = 'left 0.05s, bottom 0.05s';\n        spriteDiv.style.display = sprite.visible ? 'flex' : 'none';\n        spriteDiv.style.alignItems = 'center';\n        spriteDiv.style.justifyContent = 'center';\n        spriteDiv.style.fontSize = '10px';\n        spriteDiv.style.fontWeight = 'bold';\n        spriteDiv.style.color = 'white';\n        spriteDiv.style.textShadow = '0 0 2px black';\n        spriteDiv.style.cursor = sprite.draggable ? 'grab' : 'default';\n        spriteDiv.style.zIndex = sprite.layer || 1;\n        spriteDiv.textContent = name.charAt(0);\n        \n        // Make draggable if enabled\n        if (sprite.draggable) {\n            const self = this;\n            let isDragging = false;\n            let dragOffsetX = 0;\n            let dragOffsetY = 0;\n            \n            spriteDiv.addEventListener('mousedown', function(e) {\n                if (self.dragMode === 'draggable' || sprite.draggable) {\n                    isDragging = true;\n                    dragOffsetX = e.clientX - spriteDiv.getBoundingClientRect().left - 15;\n                    dragOffsetY = e.clientY - spriteDiv.getBoundingClientRect().top - 15;\n                    spriteDiv.style.cursor = 'grabbing';\n                }\n            });\n            \n            document.addEventListener('mousemove', function(e) {\n                if (isDragging) {\n                    const rect = stageDiv.getBoundingClientRect();\n                    sprite.x = (e.clientX - rect.left - self.stage.width/2) - dragOffsetX;\n                    sprite.y = (self.stage.height/2 - (e.clientY - rect.top)) + dragOffsetY;\n                    self.updateSpritePosition(name);\n                }\n            });\n            \n            document.addEventListener('mouseup', function() {\n                isDragging = false;\n                spriteDiv.style.cursor = 'grab';\n            });\n        }\n        \n        stageDiv.appendChild(spriteDiv);\n    },\n\n    // Clone management\n    createClone: function(spriteName) {\n        const original = this.sprites[spriteName];\n        if (!original) return null;\n        \n        const cloneId = spriteName + '_clone_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);\n        \n        this.initSprite(cloneId, {\n            x: original.x,\n            y: original.y,\n            direction: original.direction,\n            visible: original.visible,\n            size: original.size,\n            rotationStyle: original.rotationStyle,\n            costumes: original.costumes.slice(),\n            currentCostume: original.currentCostume,\n            isClone: true,\n            cloneOf: spriteName\n        });\n        \n        this.clones.push(cloneId);\n        \n        // Trigger clone start event\n        if (this.events['cloneStart_' + spriteName]) {\n            const self = this;\n            this.events['cloneStart_' + spriteName].forEach(function(callback) {\n                self.currentSprite = cloneId;\n                callback();\n            });\n        }\n        \n        return cloneId;\n    },\n    \n    deleteClone: function(cloneName) {\n        const sprite = this.sprites[cloneName];\n        if (!sprite || !sprite.isClone) return;\n        \n        // Remove visual element\n        const spriteDiv = document.getElementById('sprite-' + cloneName);\n        if (spriteDiv) spriteDiv.remove();\n        \n        // Remove speech bubble\n        const bubble = document.getElementById('speech-' + cloneName);\n        if (bubble) bubble.remove();\n        \n        // Remove from tracking\n        delete this.sprites[cloneName];\n        const idx = this.clones.indexOf(cloneName);\n        if (idx >= 0) this.clones.splice(idx, 1);\n    },\n\n    // Stage/Backdrop methods\n    switchBackdrop: function(backdrop) {\n        if (typeof backdrop === 'number') {\n            this.stage.currentBackdrop = ((backdrop - 1) % this.stage.backdrops.length + this.stage.backdrops.length) % this.stage.backdrops.length;\n        } else {\n            const idx = this.stage.backdrops.indexOf(backdrop);\n            if (idx >= 0) this.stage.currentBackdrop = idx;\n        }\n        const backdropName = this.stage.backdrops[this.stage.currentBackdrop];\n        console.log('Switched to backdrop: ' + backdropName);\n        \n        // Trigger backdrop change event\n        if (this.events['backdropSwitch_' + backdropName]) {\n            this.events['backdropSwitch_' + backdropName].forEach(function(callback) { callback(); });\n        }\n    },\n    \n    nextBackdrop: function() {\n        this.stage.currentBackdrop = (this.stage.currentBackdrop + 1) % this.stage.backdrops.length;\n        console.log('Switched to backdrop: ' + this.stage.backdrops[this.stage.currentBackdrop]);\n    },\n\n    // Initialize the runtime\n    init: function() {\n        const self = this;\n        \n        // Setup UI when DOM is ready\n        const setupUI = function() {\n            const stageDiv = document.getElementById('stage');\n            if (stageDiv) {\n                // Use the actual rendered size of the stage\n                const rect = stageDiv.getBoundingClientRect();\n                self.stage.width = rect.width || 480;\n                self.stage.height = rect.height || 360;\n                \n                stageDiv.style.backgroundColor = self.stage.backgroundColor;\n                stageDiv.style.position = 'relative';\n                stageDiv.style.overflow = 'hidden';\n\n                // Create sprite elements for all initialized sprites\n                Object.keys(self.sprites).forEach(function(name) {\n                    self.createSpriteElement(name);\n                });\n            }\n        };\n\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', setupUI);\n        } else {\n            setupUI();\n        }\n\n        // Track mouse position\n        document.addEventListener('mousemove', function(e) {\n            const stageDiv = document.getElementById('stage');\n            if (stageDiv) {\n                const rect = stageDiv.getBoundingClientRect();\n                self.mouse.x = e.clientX - rect.left - self.stage.width/2;\n                self.mouse.y = self.stage.height/2 - (e.clientY - rect.top);\n            }\n        });\n        \n        document.addEventListener('mousedown', function() { self.mouse.down = true; });\n        document.addEventListener('mouseup', function() { self.mouse.down = false; });\n\n        // Register keyboard event handlers\n        document.addEventListener('keydown', function(e) {\n            self.pressedKeys[e.key.toLowerCase()] = true;\n            const keyEvent = 'keyPressed_' + e.key.toLowerCase();\n            if (self.events[keyEvent] && Array.isArray(self.events[keyEvent])) {\n                self.events[keyEvent].forEach(function(callback) { callback(); });\n            }\n        });\n        \n        document.addEventListener('keyup', function(e) {\n            delete self.pressedKeys[e.key.toLowerCase()];\n        });\n        \n        // Click on sprite events\n        document.addEventListener('click', function(e) {\n            const target = e.target;\n            if (target && target.id && target.id.startsWith('sprite-')) {\n                const spriteName = target.id.replace('sprite-', '');\n                if (self.events['spriteClicked_' + spriteName]) {\n                    self.events['spriteClicked_' + spriteName].forEach(function(callback) { callback(); });\n                }\n            }\n        });\n    },\n\n    // Register green flag handler\n    onGreenFlag: function(callback) {\n        this.greenFlagHandlers.push(callback);\n    },\n\n    // Trigger green flag\n    greenFlag: function() {\n        const self = this;\n        this.running = true;\n        this.timer = Date.now();\n        console.log('ðŸš© Green flag clicked!');\n        this.greenFlagHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e) {\n                console.error('Error in green flag handler:', e);\n            }\n        });\n    },\n\n    // Stop all scripts\n    stopAll: function() {\n        this.running = false;\n        // Delete all clones\n        const self = this;\n        this.clones.slice().forEach(function(clone) {\n            self.deleteClone(clone);\n        });\n        console.log('ðŸ›‘ All scripts stopped');\n    },\n\n    // Timer functions\n    getTimer: function() {\n        return (Date.now() - this.timer) / 1000;\n    },\n    \n    resetTimer: function() {\n        this.timer = Date.now();\n    },\n\n    // Keyboard sensing\n    isKeyPressed: function(key) {\n        if (key === 'any') {\n            return Object.keys(this.pressedKeys).length > 0;\n        }\n        return !!this.pressedKeys[key.toLowerCase()];\n    },\n\n    // Broadcasting system\n    broadcast: function(message) {\n        console.log('ðŸ“¢ Broadcasting: ' + message);\n        if (this.broadcasts[message] && Array.isArray(this.broadcasts[message])) {\n            this.broadcasts[message].forEach(function(callback) { callback(); });\n        }\n    },\n    \n    broadcastAndWait: async function(message) {\n        console.log('ðŸ“¢ Broadcasting and waiting: ' + message);\n        if (this.broadcasts[message] && Array.isArray(this.broadcasts[message])) {\n            const promises = this.broadcasts[message].map(function(callback) {\n                return Promise.resolve(callback());\n            });\n            await Promise.all(promises);\n        }\n    },\n\n    // Register a broadcast receiver\n    onBroadcast: function(message, callback) {\n        if (!this.broadcasts[message]) {\n            this.broadcasts[message] = [];\n        }\n        this.broadcasts[message].push(callback);\n    },\n\n    // Register an event handler\n    onEvent: function(event, callback) {\n        if (!this.events[event]) {\n            this.events[event] = [];\n        }\n        this.events[event].push(callback);\n    },\n\n    // Wait for seconds\n    wait: function(seconds) {\n        return new Promise(function(resolve) {\n            setTimeout(resolve, seconds * 1000);\n        });\n    },\n\n    // Ask a question and get an answer\n    ask: async function(question) {\n        const self = this;\n        return new Promise(function(resolve) {\n            const stageDiv = document.getElementById('stage');\n            if (!stageDiv) { resolve(''); return; }\n\n            const askDiv = document.createElement('div');\n            askDiv.id = 'ask-prompt';\n            askDiv.style.position = 'absolute';\n            askDiv.style.bottom = '10px';\n            askDiv.style.left = '10px';\n            askDiv.style.right = '10px';\n            askDiv.style.backgroundColor = 'white';\n            askDiv.style.border = '2px solid black';\n            askDiv.style.borderRadius = '8px';\n            askDiv.style.padding = '10px';\n            askDiv.style.zIndex = '200';\n\n            const questionText = document.createElement('div');\n            questionText.textContent = question;\n            questionText.style.marginBottom = '8px';\n            askDiv.appendChild(questionText);\n\n            const inputField = document.createElement('input');\n            inputField.type = 'text';\n            inputField.style.width = 'calc(100% - 70px)';\n            inputField.style.padding = '5px';\n            inputField.style.border = '1px solid #ccc';\n            inputField.style.borderRadius = '4px';\n            askDiv.appendChild(inputField);\n\n            const submitButton = document.createElement('button');\n            submitButton.textContent = 'âœ“';\n            submitButton.style.marginLeft = '5px';\n            submitButton.style.padding = '5px 15px';\n            submitButton.style.backgroundColor = '#4CAF50';\n            submitButton.style.color = 'white';\n            submitButton.style.border = 'none';\n            submitButton.style.borderRadius = '4px';\n            submitButton.style.cursor = 'pointer';\n            askDiv.appendChild(submitButton);\n\n            const submit = function() {\n                self.answer = inputField.value;\n                askDiv.remove();\n                resolve(self.answer);\n            };\n\n            submitButton.onclick = submit;\n            inputField.addEventListener('keypress', function(e) {\n                if (e.key === 'Enter') submit();\n            });\n\n            stageDiv.appendChild(askDiv);\n            inputField.focus();\n        });\n    },\n    \n    // Utility functions for math operations\n    pickRandom: function(from, to) {\n        if (Number.isInteger(from) && Number.isInteger(to)) {\n            return Math.floor(Math.random() * (to - from + 1)) + from;\n        }\n        return Math.random() * (to - from) + from;\n    },\n    \n    // List operations\n    addToList: function(listName, item) {\n        if (!this.lists[listName]) this.lists[listName] = [];\n        this.lists[listName].push(item);\n    },\n    \n    deleteOfList: function(listName, index) {\n        if (!this.lists[listName]) return;\n        if (index === 'all') {\n            this.lists[listName] = [];\n        } else if (index === 'last') {\n            this.lists[listName].pop();\n        } else {\n            const idx = parseInt(index) - 1;\n            if (idx >= 0 && idx < this.lists[listName].length) {\n                this.lists[listName].splice(idx, 1);\n            }\n        }\n    },\n    \n    insertAtList: function(listName, index, item) {\n        if (!this.lists[listName]) this.lists[listName] = [];\n        const idx = index === 'last' ? this.lists[listName].length : parseInt(index) - 1;\n        this.lists[listName].splice(idx, 0, item);\n    },\n    \n    replaceItemOfList: function(listName, index, item) {\n        if (!this.lists[listName]) return;\n        const idx = index === 'last' ? this.lists[listName].length - 1 : parseInt(index) - 1;\n        if (idx >= 0 && idx < this.lists[listName].length) {\n            this.lists[listName][idx] = item;\n        }\n    },\n    \n    itemOfList: function(listName, index) {\n        if (!this.lists[listName]) return '';\n        const idx = index === 'last' ? this.lists[listName].length - 1 : parseInt(index) - 1;\n        return (idx >= 0 && idx < this.lists[listName].length) ? this.lists[listName][idx] : '';\n    },\n    \n    itemNumberInList: function(listName, item) {\n        if (!this.lists[listName]) return 0;\n        const idx = this.lists[listName].indexOf(item);\n        return idx >= 0 ? idx + 1 : 0;\n    },\n    \n    lengthOfList: function(listName) {\n        return this.lists[listName] ? this.lists[listName].length : 0;\n    },\n    \n    listContains: function(listName, item) {\n        return this.lists[listName] ? this.lists[listName].includes(item) : false;\n    },\n    \n    // Sound (placeholder implementations)\n    playSound: function(soundName) {\n        console.log('ðŸ”Š Playing sound: ' + soundName);\n    },\n    \n    playSoundUntilDone: async function(soundName) {\n        console.log('ðŸ”Š Playing sound until done: ' + soundName);\n        // Placeholder - in real implementation, would wait for audio to finish\n        await this.wait(1);\n    },\n    \n    stopAllSounds: function() {\n        console.log('ðŸ”‡ Stopping all sounds');\n    },\n    \n    setVolume: function(volume) {\n        this.stage.volume = Math.max(0, Math.min(100, volume));\n        console.log('ðŸ”Š Volume set to: ' + this.stage.volume + '%');\n    },\n    \n    changeVolume: function(change) {\n        this.stage.volume = Math.max(0, Math.min(100, this.stage.volume + change));\n        console.log('ðŸ”Š Volume changed to: ' + this.stage.volume + '%');\n    },\n    \n    // Username (placeholder)\n    getUsername: function() {\n        return 'ScratchUser';\n    }\n};\n\n// Initialize the runtime\nscratchRuntime.init();\n// Variables\n// No variables defined\n\n// Lists\n// No lists defined\n\n// Initialize Sprites\ndelete scratchRuntime.sprites[\"Sprite1\"];\nscratchRuntime.initSprite(\"Sprite2\", {\n    x: 0,\n    y: 0,\n    direction: 90,\n    visible: true,\n    size: 100,\n    rotationStyle: 'all around',\n    costumes: ['costume1'],\n    currentCostume: 0\n});\n\n// Custom Procedures\n// No procedures defined\n\n// Scripts\n// === Sprite2 Scripts ===\n(function() {\n    const CURRENT_SPRITE = \"Sprite2\";\n    const IS_STAGE = false;\n    const sprite = scratchRuntime.sprites[CURRENT_SPRITE];\n\n    // Script 1\n    // When green flag clicked\n    scratchRuntime.onGreenFlag(async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].say(\"Hello! I'm going to dance!\");\n        await scratchRuntime.wait(1);\n        for (let _i = 0; _i < 4; _i++) {\n            scratchRuntime.sprites[\"Sprite2\"].move(50);\n            scratchRuntime.sprites[\"Sprite2\"].turnRight(90);\n            await scratchRuntime.wait(0.3);\n        }\n    });\n\n    // Script 2\n    // When   key pressed\n    scratchRuntime.onEvent(\"keyPressed_ \", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].say(\"You pressed space!\");\n    });\n\n    // Script 3\n    // When arrowup key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowup\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].move(20);\n    });\n\n    // Script 4\n    // When arrowdown key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowdown\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].move(-20);\n    });\n\n    // Script 5\n    // When arrowleft key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowleft\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].turnLeft(15);\n    });\n\n    // Script 6\n    // When arrowright key pressed\n    scratchRuntime.onEvent(\"keyPressed_arrowright\", async function() {\n        scratchRuntime.currentSprite = \"Sprite2\";\n        scratchRuntime.sprites[\"Sprite2\"].turnRight(15);\n    });\n\n})();\n\n\n    </script>\n</body>\n</html>"
    }
  }
]