// Enhanced CodeGenerator: Convert AST to JavaScript code
// This class converts an Abstract Syntax Tree (AST) generated by the Parser
// into executable JavaScript code with a Scratch-like runtime environment.

import { Program, BlockNode } from "@/types/compilerTypes";
import { SCRATCH_RUNTIME, generateHTMLTemplate } from "@/templates";

export class CodeGenerator {
    // The program (AST) to generate code from
    private program: Program;
    // The generated JavaScript code output
    private output: string = "";
    // HTML output for browser display
    private htmlOutput: string = "";
    // Current indentation level for code formatting
    private indent: number = 0;
    // Track if we're inside a function definition
    private inFunction: boolean = false;
    // Custom procedures with their parameter lists
    private procedures: Map<string, string[]> = new Map();

    constructor(program: Program) {
        this.program = program;
    }

    /**
     * Main method to generate the JavaScript and HTML code
     * @returns Object containing JavaScript code and HTML
     */
    generate(): { js: string; html: string } {
        // First pass to collect all custom procedures
        this.collectProcedures();

        // Generate the JavaScript code
        this.generateJavaScript();

        // Generate the HTML wrapper
        this.generateHTML();

        return {
            js: this.output,
            html: this.htmlOutput,
        };
    }

    /**
     * Collects all custom procedures defined in the program
     */
    private collectProcedures(): void {
        this.program.scripts.forEach((script) => {
            script.blocks.forEach((block) => {
                this.findProceduresInBlock(block);
            });
        });
    }

    /**
     * Recursively searches for procedure definitions in blocks
     */
    private findProceduresInBlock(block: BlockNode): void {
        if (block.type === "custom" && block.name === "defineFunction") {
            const procedureName = block.args[0] as string;
            const parameters = block.args.slice(1) as string[];
            this.procedures.set(procedureName, parameters);
        }

        // Check next block in sequence
        if (block.next) {
            this.findProceduresInBlock(block.next);
        }
    }

    /**
     * Generates the JavaScript code from the AST
     */
    private generateJavaScript(): void {
        // Add runtime support code
        this.generateRuntimeSupport();

        // Generate code for variables
        this.generateVariablesCode();

        // Generate code for lists
        this.generateListsCode();

        // Generate code for custom procedures
        this.generateProceduresCode();

        // Generate code for scripts
        this.generateScriptsCode();
    }

    /**
     * Generates the runtime support functions
     */
    private generateRuntimeSupport(): void {
        this.output = SCRATCH_RUNTIME;
    }

    /**
     * Generates code for variables
     */
    private generateVariablesCode(): void {
        this.output += `// Variables\n`;
        if (this.program.variables.size > 0) {
            this.program.variables.forEach((value, name) => {
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${name}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${name}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${name}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for lists
     */
    private generateListsCode(): void {
        this.output += `// Lists\n`;
        if (this.program.lists.size > 0) {
            this.program.lists.forEach((values, name) => {
                const formattedValues = values.map((v) => (typeof v === "number" ? v : `"${v}"`)).join(", ");
                this.output += `scratchRuntime.lists["${name}"] = [${formattedValues}];\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for custom procedures
     */
    private generateProceduresCode(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size > 0) {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = function(${paramList}) {\n`;
                this.indent++;
                this.write(`// Function body will be generated during script processing\n`);
                this.indent--;
                this.output += `};\n\n`;
            });
        } else {
            this.output += `// No procedures defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for all scripts
     */
    private generateScriptsCode(): void {
        this.output += `// Scripts\n`;
        this.program.scripts.forEach((script, index) => {
            this.output += `// Script ${index + 1}\n`;
            script.blocks.forEach((block) => {
                this.generateBlockCode(block);
            });
            this.output += `\n`;
        });
    }

    /**
     * Generates code for a single block and its nested structure
     */
    private generateBlockCode(block: BlockNode): void {
        switch (block.type) {
            case "event":
                this.generateEventBlock(block);
                break;
            case "motion":
                this.generateMotionBlock(block);
                break;
            case "looks":
                this.generateLooksBlock(block);
                break;
            case "sound":
                this.generateSoundBlock(block);
                break;
            case "control":
                this.generateControlBlock(block);
                break;
            case "sensing":
                this.generateSensingBlock(block);
                break;
            case "operators":
                this.write(this.generateOperatorsBlock(block));
                break;
            case "variables":
                this.generateVariablesBlock(block);
                break;
            case "pen":
                this.generatePenBlock(block);
                break;
            case "custom":
                this.generateCustomBlock(block);
                break;
            default:
                this.write(`// Unsupported block type: ${block.type}, name: ${block.name}\n`);
        }
    }

    /**
     * Generates code for event blocks (when flag clicked, when key pressed, etc.)
     */
    private generateEventBlock(block: BlockNode): void {
        if (block.name === "when" && block.args[0] === "flagClicked") {
            this.write(`// When green flag clicked\n`);
            this.write(`scratchRuntime.onGreenFlag(async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "when" && typeof block.args[0] === "string" && block.args[0].includes("keyPressed")) {
            const key = (block.args[0] as string).replace("keyPressed", "").toLowerCase();
            this.write(`// When ${key} key pressed\n`);
            this.write(`scratchRuntime.onEvent("keyPressed_${key}", async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "whenReceived") {
            const message = this.formatArg(block.args[0]);
            this.write(`// When I receive ${message}\n`);
            this.write(`scratchRuntime.onBroadcast(${message}, async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "broadcast") {
            const message = this.formatArg(block.args[0]);
            this.write(`scratchRuntime.broadcast(${message});\n`);
        } else if (block.name === "broadcastAndWait") {
            const message = this.formatArg(block.args[0]);
            this.write(`// Broadcast and wait (simplified implementation)\n`);
            this.write(`scratchRuntime.broadcast(${message});\n`);
            this.write(`await new Promise(resolve => setTimeout(resolve, 100));\n`);
        }

        // Note: Do not process block.next here - event handler bodies are generated above
    }

    /**
     * Generates code for motion blocks (move, turn, go to, etc.)
     */
    private generateMotionBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "move":
                const steps = this.formatArg(block.args[0]);
                this.write(`${sprite}.move(${steps});\n`);
                break;
            case "turnRight":
                const degreesRight = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnRight(${degreesRight});\n`);
                break;
            case "turnLeft":
                const degreesLeft = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnLeft(${degreesLeft});\n`);
                break;
            case "pointInDirection":
                const direction = this.formatArg(block.args[0]);
                this.write(`${sprite}.pointInDirection(${direction});\n`);
                break;
            case "goTo":
                if (block.args[0] === "random") {
                    this.write(`// Go to random position\n`);
                    this.write(
                        `const randomX = Math.floor(Math.random() * scratchRuntime.stage.width) - (scratchRuntime.stage.width / 2);\n`
                    );
                    this.write(
                        `const randomY = Math.floor(Math.random() * scratchRuntime.stage.height) - (scratchRuntime.stage.height / 2);\n`
                    );
                    this.write(`${sprite}.goTo(randomX, randomY);\n`);
                } else if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`${sprite}.goToSprite("${targetSprite}");\n`);
                } else {
                    const x = this.formatArg(block.args[0]);
                    const y = this.formatArg(block.args[1]);
                    this.write(`${sprite}.goTo(${x}, ${y});\n`);
                }
                break;
            case "setX":
                const x = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${x}, ${sprite}.y);\n`);
                break;
            case "setY":
                const y = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${y});\n`);
                break;
            case "changeX":
                const changeX = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x + ${changeX}, ${sprite}.y);\n`);
                break;
            case "changeY":
                const changeY = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${sprite}.y + ${changeY});\n`);
                break;
            case "glide":
                const seconds = this.formatArg(block.args[0]);
                const targetX = this.formatArg(block.args[1]);
                const targetY = this.formatArg(block.args[2]);
                this.write(`// Glide to position\n`);
                this.write(`const startX = ${sprite}.x;\n`);
                this.write(`const startY = ${sprite}.y;\n`);
                this.write(`const targetX = ${targetX};\n`);
                this.write(`const targetY = ${targetY};\n`);
                this.write(`const duration = ${seconds} * 1000;\n`);
                this.write(`const startTime = Date.now();\n\n`);

                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function animate() {\n`);
                this.indent++;
                this.write(`const elapsed = Date.now() - startTime;\n`);
                this.write(`const progress = Math.min(elapsed / duration, 1);\n`);
                this.write(`const newX = startX + (targetX - startX) * progress;\n`);
                this.write(`const newY = startY + (targetY - startY) * progress;\n`);
                this.write(`${sprite}.goTo(newX, newY);\n\n`);

                this.write(`if (progress < 1) {\n`);
                this.indent++;
                this.write(`requestAnimationFrame(animate);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n\n`);

                this.write(`animate();\n`);
                this.indent--;
                this.write(`});\n`);
                break;
            default:
                this.write(`// Unsupported motion block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for looks blocks (say, change size, etc.)
     */
    private generateLooksBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "say":
                const message = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`${sprite}.say(${message}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say(${message});\n`);
                }
                break;
            case "think":
                const thought = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`// Think is implemented the same as say but with different styling\n`);
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought});\n`);
                }
                break;
            case "show":
                this.write(`${sprite}.show();\n`);
                break;
            case "hide":
                this.write(`${sprite}.hide();\n`);
                break;
            case "changeSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changeSize(${sizeChange});\n`);
                break;
            case "setSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setSize(${size});\n`);
                break;
            case "switchCostume":
                const costume = this.formatArg(block.args[0]);
                this.write(`// Switch costume (simplified implementation)\n`);
                this.write(`console.log(\`Switching costume to \${${costume}}\`);\n`);
                break;
            default:
                this.write(`// Unsupported looks block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for sound blocks (play sound, change volume, etc.)
     */
    private generateSoundBlock(block: BlockNode): void {
        switch (block.name) {
            case "playSound":
                const sound = this.formatArg(block.args[0]);
                this.write(`// Play sound (simplified implementation)\n`);
                this.write(`console.log(\`Playing sound: \${${sound}}\`);\n`);
                break;
            case "stopAllSounds":
                this.write(`// Stop all sounds (simplified implementation)\n`);
                this.write(`console.log("Stopping all sounds");\n`);
                break;
            case "changeVolume":
                const volumeChange = this.formatArg(block.args[0]);
                this.write(`// Change volume (simplified implementation)\n`);
                this.write(
                    `scratchRuntime.stage.volume = Math.max(0, Math.min(100, scratchRuntime.stage.volume + ${volumeChange}));\n`
                );
                this.write(`console.log(\`Volume changed to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            case "setVolume":
                const volume = this.formatArg(block.args[0]);
                this.write(`// Set volume (simplified implementation)\n`);
                this.write(`scratchRuntime.stage.volume = Math.max(0, Math.min(100, ${volume}));\n`);
                this.write(`console.log(\`Volume set to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            default:
                this.write(`// Unsupported sound block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for control blocks (wait, repeat, if, etc.)
     */
    private generateControlBlock(block: BlockNode): void {
        switch (block.name) {
            case "wait":
                const seconds = this.formatArg(block.args[0]);
                this.write(`await new Promise(resolve => setTimeout(resolve, ${seconds} * 1000));\n`);

                // Process next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeat":
                const count = this.formatArg(block.args[0]);
                this.write(`// Repeat loop\n`);
                this.write(`for (let i = 0; i < ${count}; i++) {\n`);
                this.indent++;
                // Generate code for the blocks inside the loop body.
                // Prefer args[1] if present; fall back to block.next when the parser attached
                // the body incorrectly to `next` instead of as an arg.
                let nextAfterRepeat: BlockNode | undefined = undefined;
                let bodyBlock: BlockNode | undefined;

                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    bodyBlock = block.args[1] as BlockNode;
                } else if (block.next) {
                    // Treat block.next as the loop body if args don't contain it
                    bodyBlock = block.next as BlockNode;
                    nextAfterRepeat = block.next.next;
                }

                if (bodyBlock) {
                    this.generateBlockCode(bodyBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block after the repeat block if it exists
                if (!nextAfterRepeat && block.next) {
                    this.generateBlockCode(block.next);
                } else if (nextAfterRepeat) {
                    this.generateBlockCode(nextAfterRepeat);
                }
                break;
            case "forever":
                this.write(`// Forever loop (using setInterval for browser compatibility)\n`);
                this.write(`(async function forever() {\n`);
                this.indent++;
                // Prefer args[0] for body; fall back to block.next if parser attached body to next
                if (block.args.length > 0 && typeof block.args[0] === "object") {
                    this.generateBlockCode(block.args[0] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // Skip generating block.next again below
                    return;
                }

                this.write(`setTimeout(forever, 10); // Small delay to prevent UI freezing\n`);
                this.indent--;
                this.write(`})();\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "if":
                const condition = this.formatArg(block.args[0]);
                this.write(`// If statement\n`);
                this.write(`if (${condition}) {\n`);
                this.indent++;

                // Prefer args[1] for then-body; fall back to block.next when parser attached body to next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // If we used block.next as the body, advance the next chain appropriately below
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "ifElse":
                const ifCondition = this.formatArg(block.args[0]);
                const thenBlock = block.args[1] as BlockNode;
                const elseBlock = block.args[2] as BlockNode;

                this.write(`// If-Else statement\n`);
                this.write(`if (${ifCondition}) {\n`);
                this.indent++;

                // Generate code for the 'then' blocks
                if (thenBlock) {
                    this.generateBlockCode(thenBlock);
                }

                this.indent--;
                this.write(`} else {\n`);
                this.indent++;

                // Generate code for the 'else' blocks
                if (elseBlock) {
                    this.generateBlockCode(elseBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "waitUntil":
                const waitCondition = this.formatArg(block.args[0]);
                this.write(`// Wait until condition is true\n`);
                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function checkCondition() {\n`);
                this.indent++;
                this.write(`if (${waitCondition}) {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`setTimeout(checkCondition, 50);\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`checkCondition();\n`);
                this.indent--;
                this.write(`});\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeatUntil":
                const repeatCondition = this.formatArg(block.args[0]);
                this.write(`// Repeat until condition is true\n`);
                this.write(`while (!(${repeatCondition})) {\n`);
                this.indent++;

                // Prefer args[1] for body; fall back to block.next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                }

                // Add a small delay to prevent browser from freezing
                this.write(`await new Promise(resolve => setTimeout(resolve, 10));\n`);
                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "stop":
                const target = block.args[0];
                if (target === "all") {
                    this.write(`// Stop all (simplified implementation - just returns from current execution)\n`);
                    this.write(`return;\n`);
                } else if (target === "thisScript") {
                    this.write(`// Stop this script\n`);
                    this.write(`return;\n`);
                } else {
                    this.write(`// Stop other scripts (simplified implementation)\n`);
                    this.write(`console.log("Stop other scripts requested");\n`);
                }
                break;
            default:
                this.write(`// Unsupported control block: ${block.name}\n`);
        }
    }

    /**
     * Generates code for sensing blocks (ask, touching, etc.)
     */
    private generateSensingBlock(block: BlockNode): void {
        switch (block.name) {
            case "ask":
                const question = this.formatArg(block.args[0]);
                this.write(`// Ask a question and wait for answer\n`);
                this.write(`await scratchRuntime.ask(${question});\n`);
                break;
            case "answer":
                this.write(`scratchRuntime.answer`);
                break;
            case "touching":
                const target = this.formatArg(block.args[0]);
                this.write(`// Touching detection (simplified implementation)\n`);
                this.write(`/* Simulating touch detection */\n`);
                if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`((sprite) => {\n`);
                    this.indent++;
                    this.write(`const dx = sprite.x - scratchRuntime.sprites["${targetSprite}"].x;\n`);
                    this.write(`const dy = sprite.y - scratchRuntime.sprites["${targetSprite}"].y;\n`);
                    this.write(`return Math.sqrt(dx*dx + dy*dy) < 30; // Simple distance check\n`);
                    this.indent--;
                    this.write(`})(scratchRuntime.sprites[scratchRuntime.currentSprite])`);
                } else {
                    this.write(`false /* Touch detection for ${target} not implemented */`);
                }
                break;
            case "keyPressed":
                const key = this.formatArg(block.args[0]);
                this.write(`// Key pressed detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const pressedKeys = {};\n`);
                this.write(
                    `document.addEventListener('keydown', (e) => { pressedKeys[e.key.toLowerCase()] = true; });\n`
                );
                this.write(
                    `document.addEventListener('keyup', (e) => { delete pressedKeys[e.key.toLowerCase()]; });\n`
                );
                this.write(`return ${key}.toLowerCase() in pressedKeys;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseDown":
                this.write(`// Mouse down detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let isMouseDown = false;\n`);
                this.write(`document.addEventListener('mousedown', () => { isMouseDown = true; });\n`);
                this.write(`document.addEventListener('mouseup', () => { isMouseDown = false; });\n`);
                this.write(`return isMouseDown;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseX":
                this.write(`// Mouse X position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseX = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseX = e.clientX - rect.left - (rect.width / 2);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseX;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseY":
                this.write(`// Mouse Y position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseY = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseY = (rect.height / 2) - (e.clientY - rect.top);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseY;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "timer":
                this.write(`// Timer value (seconds since page load)\n`);
                this.write(`((start) => (Date.now() - start) / 1000)(Date.now())`);
                break;
            case "resetTimer":
                this.write(`// Reset timer (simplified implementation)\n`);
                this.write(`console.log("Timer reset requested");\n`);
                break;
            default:
                this.write(`// Unsupported sensing block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for operators blocks (mathematical and logical operations)
     */
    private generateOperatorsBlock(block: BlockNode): string {
        switch (block.name) {
            case "add":
                const addend1 = this.formatArg(block.args[0]);
                const addend2 = this.formatArg(block.args[1]);
                return `(Number(${addend1}) + Number(${addend2}))`;
            case "subtract":
                const minuend = this.formatArg(block.args[0]);
                const subtrahend = this.formatArg(block.args[1]);
                return `(Number(${minuend}) - Number(${subtrahend}))`;
            case "multiply":
                const factor1 = this.formatArg(block.args[0]);
                const factor2 = this.formatArg(block.args[1]);
                return `(Number(${factor1}) * Number(${factor2}))`;
            case "divide":
                const dividend = this.formatArg(block.args[0]);
                const divisor = this.formatArg(block.args[1]);
                return `(Number(${dividend}) / Number(${divisor}))`;
            case "mod":
                const modDividend = this.formatArg(block.args[0]);
                const modDivisor = this.formatArg(block.args[1]);
                return `(Number(${modDividend}) % Number(${modDivisor}))`;
            case "round":
                const roundValue = this.formatArg(block.args[0]);
                return `Math.round(Number(${roundValue}))`;
            case "abs":
                const absValue = this.formatArg(block.args[0]);
                return `Math.abs(Number(${absValue}))`;
            case "floor":
                const floorValue = this.formatArg(block.args[0]);
                return `Math.floor(Number(${floorValue}))`;
            case "ceiling":
                const ceilingValue = this.formatArg(block.args[0]);
                return `Math.ceil(Number(${ceilingValue}))`;
            case "sqrt":
                const sqrtValue = this.formatArg(block.args[0]);
                return `Math.sqrt(Number(${sqrtValue}))`;
            case "sin":
                const sinValue = this.formatArg(block.args[0]);
                return `Math.sin(Number(${sinValue}) * Math.PI / 180)`;
            case "cos":
                const cosValue = this.formatArg(block.args[0]);
                return `Math.cos(Number(${cosValue}) * Math.PI / 180)`;
            case "tan":
                const tanValue = this.formatArg(block.args[0]);
                return `Math.tan(Number(${tanValue}) * Math.PI / 180)`;
            case "greater":
                const greater1 = this.formatArg(block.args[0]);
                const greater2 = this.formatArg(block.args[1]);
                return `(Number(${greater1}) > Number(${greater2}))`;
            case "less":
                const less1 = this.formatArg(block.args[0]);
                const less2 = this.formatArg(block.args[1]);
                return `(Number(${less1}) < Number(${less2}))`;
            case "equals":
                const equals1 = this.formatArg(block.args[0]);
                const equals2 = this.formatArg(block.args[1]);
                return `(${equals1} == ${equals2})`;
            case "and":
                const and1 = this.formatArg(block.args[0]);
                const and2 = this.formatArg(block.args[1]);
                return `(${and1} && ${and2})`;
            case "or":
                const or1 = this.formatArg(block.args[0]);
                const or2 = this.formatArg(block.args[1]);
                return `(${or1} || ${or2})`;
            case "not":
                const notValue = this.formatArg(block.args[0]);
                return `!(${notValue})`;
            case "random":
                const min = this.formatArg(block.args[0]);
                const max = this.formatArg(block.args[1]);
                return `(Math.floor(Math.random() * (${max} - ${min} + 1)) + ${min})`;
            case "join":
                const string1 = this.formatArg(block.args[0]);
                const string2 = this.formatArg(block.args[1]);
                return `('' + ${string1} + ${string2})`;
            case "letterOf":
                const letter = this.formatArg(block.args[0]);
                const string = this.formatArg(block.args[1]);
                return `String(${string}).charAt(${letter} - 1)`;
            case "length":
                const lengthString = this.formatArg(block.args[0]);
                return `String(${lengthString}).length`;
            case "contains":
                const containsString = this.formatArg(block.args[0]);
                const substring = this.formatArg(block.args[1]);
                return `String(${containsString}).includes(String(${substring}))`;
            case "expression":
                const expression = this.formatArg(block.args[0]);
                return `(${expression})`;
            default:
                return `/* Unsupported operator: ${block.name} */`;
        }
    }

    /**
     * Generates code for variables blocks (set, change, etc.)
     */
    private generateVariablesBlock(block: BlockNode): void {
        switch (block.name) {
            case "set":
                const varName = block.args[0];
                const varValue = this.formatArg(block.args[1]);
                this.write(`scratchRuntime.variables["${varName}"] = ${varValue};\n`);
                break;
            case "change":
                const changeVarName = block.args[0];
                const changeValue = this.formatArg(block.args[1]);
                this.write(
                    `scratchRuntime.variables["${changeVarName}"] = Number(scratchRuntime.variables["${changeVarName}"]) + Number(${changeValue});\n`
                );
                break;
            case "showVariable":
                const showVarName = block.args[0];
                this.write(`// Show variable in the UI\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const varDisplay = document.getElementById('var-${showVarName}');\n`);
                this.write(`if (!varDisplay) {\n`);
                this.indent++;
                this.write(`const newVarDisplay = document.createElement('div');\n`);
                this.write(`newVarDisplay.id = 'var-${showVarName}';\n`);
                this.write(`newVarDisplay.className = 'scratch-variable';\n`);
                this.write(`newVarDisplay.style.position = 'absolute';\n`);
                this.write(`newVarDisplay.style.top = '10px';\n`);
                this.write(`newVarDisplay.style.left = '10px';\n`);
                this.write(`newVarDisplay.style.backgroundColor = 'rgba(255,255,255,0.7)';\n`);
                this.write(`newVarDisplay.style.padding = '5px';\n`);
                this.write(`newVarDisplay.style.borderRadius = '5px';\n`);
                this.write(
                    `newVarDisplay.textContent = '${showVarName}: ' + scratchRuntime.variables["${showVarName}"];\n`
                );
                this.write(`document.getElementById('stage').appendChild(newVarDisplay);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`varDisplay.style.display = 'block';\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`})();\n`);
                break;
            case "hideVariable":
                const hideVarName = block.args[0];
                this.write(`// Hide variable in the UI\n`);
                this.write(`const varDisplay = document.getElementById('var-${hideVarName}');\n`);
                this.write(`if (varDisplay) varDisplay.style.display = 'none';\n`);
                break;
            case "addToList":
                const listName = block.args[0];
                const itemValue = this.formatArg(block.args[1]);
                this.write(`// Add item to list\n`);
                this.write(`if (!scratchRuntime.lists["${listName}"]) scratchRuntime.lists["${listName}"] = [];\n`);
                this.write(`scratchRuntime.lists["${listName}"].push(${itemValue});\n`);
                break;
            case "deleteFromList":
                const deleteListName = block.args[0];
                const deleteIndex = this.formatArg(block.args[1]);
                this.write(`// Delete item from list\n`);
                this.write(
                    `if (scratchRuntime.lists["${deleteListName}"] && ${deleteIndex} > 0 && ${deleteIndex} <= scratchRuntime.lists["${deleteListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${deleteListName}"].splice(${deleteIndex} - 1, 1);\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "insertInList":
                const insertListName = block.args[0];
                const insertValue = this.formatArg(block.args[1]);
                const insertIndex = this.formatArg(block.args[2]);
                this.write(`// Insert item in list\n`);
                this.write(
                    `if (!scratchRuntime.lists["${insertListName}"]) scratchRuntime.lists["${insertListName}"] = [];\n`
                );
                this.write(
                    `if (${insertIndex} > 0 && ${insertIndex} <= scratchRuntime.lists["${insertListName}"].length + 1) {\n`
                );
                this.indent++;
                this.write(
                    `scratchRuntime.lists["${insertListName}"].splice(${insertIndex} - 1, 0, ${insertValue});\n`
                );
                this.indent--;
                this.write(`}\n`);
                break;
            case "replaceInList":
                const replaceListName = block.args[0];
                const replaceIndex = this.formatArg(block.args[1]);
                const replaceValue = this.formatArg(block.args[2]);
                this.write(`// Replace item in list\n`);
                this.write(
                    `if (scratchRuntime.lists["${replaceListName}"] && ${replaceIndex} > 0 && ${replaceIndex} <= scratchRuntime.lists["${replaceListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${replaceListName}"][${replaceIndex} - 1] = ${replaceValue};\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "itemOfList":
                const itemListName = block.args[0];
                const itemIndex = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${itemListName}"] && ${itemIndex} > 0 && ${itemIndex} <= scratchRuntime.lists["${itemListName}"].length ? scratchRuntime.lists["${itemListName}"][${itemIndex} - 1] : "")`
                );
            case "lengthOfList":
                const lengthListName = block.args[0];
                this.write(
                    `(scratchRuntime.lists["${lengthListName}"] ? scratchRuntime.lists["${lengthListName}"].length : 0)`
                );
            case "listContains":
                const containsListName = block.args[0];
                const containsItem = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${containsListName}"] ? scratchRuntime.lists["${containsListName}"].includes(${containsItem}) : false)`
                );
            default:
                this.write(`// Unsupported variables block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for pen blocks
     */
    private generatePenBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        // If pen methods don't exist yet, add them
        if (!this.penMethodsAdded) {
            this.addPenMethods();
        }

        switch (block.name) {
            case "penDown":
                this.write(`${sprite}.penDown();\n`);
                break;
            case "penUp":
                this.write(`${sprite}.penUp();\n`);
                break;
            case "setPenColor":
                const color = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenColor(${color});\n`);
                break;
            case "changePenSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changePenSize(${sizeChange});\n`);
                break;
            case "setPenSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenSize(${size});\n`);
                break;
            case "clear":
                this.write(`${sprite}.clearPen();\n`);
                break;
            case "stamp":
                this.write(`${sprite}.stamp();\n`);
                break;
            default:
                this.write(`// Unsupported pen block: ${block.name}\n`);
        }

        // Process the next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Flag to track if pen methods have been added to the runtime
     */
    private penMethodsAdded: boolean = false;

    /**
     * Adds pen methods to the runtime if they don't exist yet
     */
    private addPenMethods(): void {
        this.penMethodsAdded = true;

        // Add pen methods before the runtime init
        const penMethods = `
        // Add pen methods to the sprite prototype
        penDown: function() {
            this.penIsDown = true;
            console.log(\`\${scratchRuntime.currentSprite} pen down\`);
            
            // Create canvas for pen if it doesn't exist
            if (!document.getElementById('pen-canvas')) {
                const stageDiv = document.getElementById('stage');
                const canvas = document.createElement('canvas');
                canvas.id = 'pen-canvas';
                canvas.width = scratchRuntime.stage.width;
                canvas.height = scratchRuntime.stage.height;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                stageDiv.appendChild(canvas);
                
                // Store last position
                this.lastPenX = this.x + scratchRuntime.stage.width/2;
                this.lastPenY = scratchRuntime.stage.height/2 - this.y;
            }
        },
        
        penUp: function() {
            this.penIsDown = false;
            console.log(\`\${scratchRuntime.currentSprite} pen up\`);
        },
        
        setPenColor: function(color) {
            this.penColor = color;
            console.log(\`\${scratchRuntime.currentSprite} pen color set to \${color}\`);
        },
        
        changePenSize: function(change) {
            if (!this.penSize) this.penSize = 1;
            this.penSize += Number(change);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size changed to \${this.penSize}\`);
        },
        
        setPenSize: function(size) {
            this.penSize = Number(size);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size set to \${this.penSize}\`);
        },
        
        clearPen: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            console.log('Cleared pen marks');
        },
        
        stamp: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);
                if (spriteDiv) {
                    // This is a simplified stamp implementation
                    ctx.fillStyle = 'red'; // Use sprite color
                    ctx.beginPath();
                    ctx.arc(this.x + scratchRuntime.stage.width/2, 
                        scratchRuntime.stage.height/2 - this.y, 15, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            console.log(\`\${scratchRuntime.currentSprite} stamped\`);
        },
        
        // Update pen drawing when sprite moves
        updatePenDrawing: function() {
            if (this.penIsDown) {
                const canvas = document.getElementById('pen-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    
                    // Initialize pen properties if not set
                    if (!this.penColor) this.penColor = '#000000';
                    if (!this.penSize) this.penSize = 1;
                    
                    // Set drawing styles
                    ctx.strokeStyle = this.penColor;
                    ctx.lineWidth = this.penSize;
                    ctx.lineCap = 'round';
                    
                    // Calculate current position
                    const currentX = this.x + scratchRuntime.stage.width/2;
                    const currentY = scratchRuntime.stage.height/2 - this.y;
                    
                    // If last position exists, draw line
                    if (typeof this.lastPenX === 'number' && typeof this.lastPenY === 'number') {
                        ctx.beginPath();
                        ctx.moveTo(this.lastPenX, this.lastPenY);
                        ctx.lineTo(currentX, currentY);
                        ctx.stroke();
                    }
                    
                    // Update last position
                    this.lastPenX = currentX;
                    this.lastPenY = currentY;
                }
            }
        },`;

        // Insert pen methods into the sprite definition
        const insertPoint = this.output.lastIndexOf("};") - 1;
        this.output = this.output.substring(0, insertPoint) + penMethods + this.output.substring(insertPoint);

        // Update move and goto methods to handle pen drawing
        this.updateMovementMethods();
    }

    /**
     * Updates movement methods to handle pen drawing
     */
    private updateMovementMethods(): void {
        // Find and modify the move method to update pen drawing
        const moveMethodPos = this.output.indexOf("move: function(steps)");
        if (moveMethodPos > -1) {
            const endOfMoveMethod = this.output.indexOf("},", moveMethodPos) + 2;
            const moveMethod = this.output.substring(moveMethodPos, endOfMoveMethod);
            const updatedMoveMethod = moveMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, moveMethodPos) + updatedMoveMethod + this.output.substring(endOfMoveMethod);
        }

        // Find and modify the goTo method to update pen drawing
        const goToMethodPos = this.output.indexOf("goTo: function(x, y)");
        if (goToMethodPos > -1) {
            const endOfGoToMethod = this.output.indexOf("},", goToMethodPos) + 2;
            const goToMethod = this.output.substring(goToMethodPos, endOfGoToMethod);
            const updatedGoToMethod = goToMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, goToMethodPos) + updatedGoToMethod + this.output.substring(endOfGoToMethod);
        }
    }

    /**
     * Generates code for custom blocks (procedures)
     */
    private generateCustomBlock(block: BlockNode): void {
        if (block.name === "defineFunction") {
            // Define a custom procedure/function
            const functionName = block.args[0] as string;
            const paramList = block.args.slice(1) as string[];

            this.write(`// Define custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"] = function(${paramList.join(", ")}) {\n`);
            this.indent++;

            // Generate code for the function body
            if (block.next) {
                this.inFunction = true;
                this.generateBlockCode(block.next);
                this.inFunction = false;
            }

            this.indent--;
            this.write(`};\n\n`);
        } else if (block.name === "call") {
            // Call a custom procedure/function
            const functionName = block.args[0] as string;
            const args = block.args
                .slice(1)
                .map((arg) => this.formatArg(arg))
                .join(", ");

            this.write(`// Call custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"](${args});\n`);

            // Process the next block if it exists
            if (block.next) {
                this.generateBlockCode(block.next);
            }
        }
    }

    /**
     * Helper method to add proper indentation to the output
     */
    private write(text: string): void {
        const indentation = "    ".repeat(this.indent);
        this.output += indentation + text;
    }

    /**
     * Helper method to format arguments correctly
     */
    private formatArg(arg: string | number | object): string {
        if (typeof arg === "string") {
            // If it's a variable reference
            if (arg.startsWith("$")) {
                return `scratchRuntime.variables["${arg.substring(1)}"]`;
            }
            // If it's a list reference
            else if (arg.startsWith("#")) {
                return `scratchRuntime.lists["${arg.substring(1)}"]`;
            }
            // It's a regular string
            else {
                return `"${arg}"`;
            }
        } else if (typeof arg === "number") {
            return arg.toString();
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // It's a nested block
            const block = arg as BlockNode;
            if (block.type === "operators") {
                return this.generateOperatorsBlock(block);
            } else {
                this.write(`// Warning: Unexpected nested block type: ${block.type}\n`);
                return '""';
            }
        } else {
            return JSON.stringify(arg);
        }
    }

    /**
     * Generates HTML wrapper code using the template
     */
    private generateHTML(): void {
        this.htmlOutput = generateHTMLTemplate(this.output);
    }
}

/**
 * MultiSpriteCodeGenerator: Generates code for multiple sprites
 * Each sprite gets its own initialization and script code
 */
export class MultiSpriteCodeGenerator {
    private sprites: { name: string; program: Program }[];
    private output: string = "";
    private htmlOutput: string = "";
    private procedures: Map<string, string[]> = new Map();

    constructor(sprites: { name: string; program: Program }[]) {
        this.sprites = sprites;
    }

    generate(): { js: string; html: string } {
        // Add runtime support code
        this.output = SCRATCH_RUNTIME;

        // Collect all procedures from all sprites
        this.collectAllProcedures();

        // Generate variables (global scope)
        this.generateGlobalVariables();

        // Generate lists (global scope)
        this.generateGlobalLists();

        // Initialize all sprites
        this.generateSpriteInitializations();

        // Generate custom procedures
        this.generateProcedures();

        // Generate code for each sprite's scripts
        this.generateSpriteScripts();

        // Generate HTML
        this.htmlOutput = generateHTMLTemplate(this.output);

        return {
            js: this.output,
            html: this.htmlOutput,
        };
    }

    private collectAllProcedures(): void {
        for (const sprite of this.sprites) {
            for (const script of sprite.program.scripts) {
                for (const block of script.blocks) {
                    this.findProcedures(block);
                }
            }
        }
    }

    private findProcedures(block: BlockNode): void {
        if (block.type === "procedure" && block.name === "define") {
            const procName = String(block.args[0]);
            const params = block.args.slice(1).map((a) => String(a));
            this.procedures.set(procName, params);
        }
        if (block.body) {
            for (const child of block.body) {
                this.findProcedures(child);
            }
        }
        if (block.next) {
            this.findProcedures(block.next);
        }
    }

    private generateGlobalVariables(): void {
        this.output += `// Variables\n`;
        const allVars = new Map<string, unknown>();
        for (const sprite of this.sprites) {
            sprite.program.variables.forEach((value, name) => {
                allVars.set(name, value);
            });
        }
        if (allVars.size > 0) {
            allVars.forEach((value, name) => {
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${name}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${name}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${name}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    private generateGlobalLists(): void {
        this.output += `// Lists\n`;
        const allLists = new Map<string, unknown[]>();
        for (const sprite of this.sprites) {
            sprite.program.lists.forEach((value, name) => {
                allLists.set(name, value);
            });
        }
        if (allLists.size > 0) {
            allLists.forEach((value, name) => {
                this.output += `scratchRuntime.lists["${name}"] = ${JSON.stringify(value)};\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    private generateSpriteInitializations(): void {
        this.output += `// Initialize Sprites\n`;
        
        // Skip default Sprite1 if it's not in our list
        const spriteNames = this.sprites.map(s => s.name);
        if (!spriteNames.includes("Sprite1")) {
            this.output += `delete scratchRuntime.sprites["Sprite1"];\n`;
        }

        for (let i = 0; i < this.sprites.length; i++) {
            const sprite = this.sprites[i];
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            
            // Initialize the sprite if it doesn't exist
            if (sprite.name !== "Sprite1") {
                this.output += `scratchRuntime.initSprite("${safeName}");\n`;
            }
            
            // Position sprites slightly apart so they're visible
            const xOffset = (i - Math.floor(this.sprites.length / 2)) * 50;
            this.output += `scratchRuntime.sprites["${safeName}"].x = ${xOffset};\n`;
        }
        
        this.output += `\n`;
    }

    private generateProcedures(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size === 0) {
            this.output += `// No procedures defined\n`;
        } else {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = async function(${paramList}) {\n`;
                this.output += `    // Procedure body will be filled by scripts\n`;
                this.output += `};\n`;
            });
        }
        this.output += `\n`;
    }

    private generateSpriteScripts(): void {
        this.output += `// Scripts\n`;
        
        for (const sprite of this.sprites) {
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            this.output += `// === ${sprite.name} Scripts ===\n`;
            this.output += `(function() {\n`;
            this.output += `    const CURRENT_SPRITE = "${safeName}";\n`;
            this.output += `    const sprite = scratchRuntime.sprites[CURRENT_SPRITE];\n\n`;
            
            // Generate each script
            for (let i = 0; i < sprite.program.scripts.length; i++) {
                const script = sprite.program.scripts[i];
                this.output += `    // Script ${i + 1}\n`;
                
                for (const block of script.blocks) {
                    this.generateBlock(block, 1, safeName);
                }
            }
            
            this.output += `})();\n\n`;
        }
    }

    private generateBlock(block: BlockNode, indent: number, spriteName: string): void {
        const spaces = "    ".repeat(indent);
        const spriteRef = `scratchRuntime.sprites["${spriteName}"]`;

        switch (block.type) {
            case "event":
                this.generateEventBlock(block, indent, spriteName);
                break;
            case "motion":
                this.generateMotionBlock(block, indent, spriteRef);
                break;
            case "looks":
                this.generateLooksBlock(block, indent, spriteRef);
                break;
            case "control":
                this.generateControlBlock(block, indent, spriteName);
                break;
            case "sound":
                this.output += `${spaces}// Sound: ${block.name}\n`;
                break;
            case "sensing":
                this.generateSensingBlock(block, indent, spriteName);
                break;
            case "operator":
                // Operators are usually inline expressions
                break;
            case "variable":
                this.generateVariableBlock(block, indent);
                break;
            case "list":
                this.generateListBlock(block, indent);
                break;
            case "procedure":
                this.generateProcedureBlock(block, indent, spriteName);
                break;
            default:
                this.output += `${spaces}// Unknown block type: ${block.type}\n`;
        }

        if (block.next) {
            this.generateBlock(block.next, indent, spriteName);
        }
    }

    private generateEventBlock(block: BlockNode, indent: number, spriteName: string): void {
        const spaces = "    ".repeat(indent);

        if (block.name === "when" && block.args[0] === "flagClicked") {
            this.output += `${spaces}// When green flag clicked\n`;
            this.output += `${spaces}scratchRuntime.onGreenFlag(async function() {\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName);
            }
            this.output += `${spaces}});\n\n`;
        } else if (block.name === "when" && String(block.args[0]).includes("keyPressed")) {
            const key = String(block.args[0]).replace("keyPressed", "").toLowerCase();
            this.output += `${spaces}// When ${key} key pressed\n`;
            this.output += `${spaces}scratchRuntime.onEvent("keyPressed_${key}", async function() {\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName);
            }
            this.output += `${spaces}});\n\n`;
        } else if (block.name === "whenReceived") {
            const message = this.formatArg(block.args[0]);
            this.output += `${spaces}// When I receive ${message}\n`;
            this.output += `${spaces}scratchRuntime.onBroadcast(${message}, async function() {\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName);
            }
            this.output += `${spaces}});\n\n`;
        } else if (block.name === "broadcast") {
            this.output += `${spaces}scratchRuntime.broadcast(${this.formatArg(block.args[0])});\n`;
        }
    }

    private generateMotionBlock(block: BlockNode, indent: number, spriteRef: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "move":
                this.output += `${spaces}${spriteRef}.move(${this.formatArg(block.args[0])});\n`;
                break;
            case "turn":
            case "turnRight":
                this.output += `${spaces}${spriteRef}.turnRight(${this.formatArg(block.args[0])});\n`;
                break;
            case "turnLeft":
                this.output += `${spaces}${spriteRef}.turnLeft(${this.formatArg(block.args[0])});\n`;
                break;
            case "goTo":
                this.output += `${spaces}${spriteRef}.goTo(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                break;
            case "setX":
                this.output += `${spaces}${spriteRef}.setX(${this.formatArg(block.args[0])});\n`;
                break;
            case "setY":
                this.output += `${spaces}${spriteRef}.setY(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeX":
                this.output += `${spaces}${spriteRef}.changeX(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeY":
                this.output += `${spaces}${spriteRef}.changeY(${this.formatArg(block.args[0])});\n`;
                break;
            case "pointInDirection":
                this.output += `${spaces}${spriteRef}.pointInDirection(${this.formatArg(block.args[0])});\n`;
                break;
        }
    }

    private generateLooksBlock(block: BlockNode, indent: number, spriteRef: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "say":
                if (block.args.length > 1) {
                    this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                } else {
                    this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "think":
                this.output += `${spaces}${spriteRef}.think(${this.formatArg(block.args[0])});\n`;
                break;
            case "show":
                this.output += `${spaces}${spriteRef}.show();\n`;
                break;
            case "hide":
                this.output += `${spaces}${spriteRef}.hide();\n`;
                break;
            case "changeSize":
                this.output += `${spaces}${spriteRef}.changeSize(${this.formatArg(block.args[0])});\n`;
                break;
            case "setSize":
                this.output += `${spaces}${spriteRef}.setSize(${this.formatArg(block.args[0])});\n`;
                break;
        }
    }

    private generateControlBlock(block: BlockNode, indent: number, spriteName: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "wait":
                this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[0])});\n`;
                break;
            case "repeat":
                this.output += `${spaces}for (let i = 0; i < ${this.formatArg(block.args[0])}; i++) {\n`;
                if (block.body) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName);
                    }
                }
                this.output += `${spaces}}\n`;
                break;
            case "forever":
                this.output += `${spaces}while (scratchRuntime.running) {\n`;
                if (block.body) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName);
                    }
                }
                this.output += `${spaces}    await scratchRuntime.wait(0.01);\n`;
                this.output += `${spaces}}\n`;
                break;
            case "if":
                this.output += `${spaces}if (${this.formatCondition(block.args[0])}) {\n`;
                if (block.body) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName);
                    }
                }
                this.output += `${spaces}}\n`;
                break;
            case "ifElse":
                this.output += `${spaces}if (${this.formatCondition(block.args[0])}) {\n`;
                if (block.body) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName);
                    }
                }
                this.output += `${spaces}} else {\n`;
                if (block.elseBody) {
                    for (const child of block.elseBody) {
                        this.generateBlock(child, indent + 1, spriteName);
                    }
                }
                this.output += `${spaces}}\n`;
                break;
        }
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    private generateSensingBlock(block: BlockNode, indent: number, _spriteName: string): void {
        const spaces = "    ".repeat(indent);
        
        if (block.name === "ask") {
            this.output += `${spaces}await scratchRuntime.ask(${this.formatArg(block.args[0])});\n`;
        }
    }

    private generateVariableBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        const varName = String(block.args[0]);
        
        switch (block.name) {
            case "set":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] = ${this.formatArg(block.args[1])};\n`;
                break;
            case "change":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] += ${this.formatArg(block.args[1])};\n`;
                break;
        }
    }

    private generateListBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        const listName = String(block.args[0]);
        
        switch (block.name) {
            case "addToList":
                this.output += `${spaces}scratchRuntime.lists["${listName}"].push(${this.formatArg(block.args[1])});\n`;
                break;
            case "deleteFromList":
                this.output += `${spaces}scratchRuntime.lists["${listName}"].splice(${this.formatArg(block.args[1])} - 1, 1);\n`;
                break;
            case "clearList":
                this.output += `${spaces}scratchRuntime.lists["${listName}"] = [];\n`;
                break;
        }
    }

    private generateProcedureBlock(block: BlockNode, indent: number, spriteName: string): void {
        const spaces = "    ".repeat(indent);
        
        if (block.name === "define") {
            const procName = String(block.args[0]);
            const params = block.args.slice(1).map(a => String(a)).join(", ");
            this.output += `${spaces}scratchRuntime.procedures["${procName}"] = async function(${params}) {\n`;
            if (block.body) {
                for (const child of block.body) {
                    this.generateBlock(child, indent + 1, spriteName);
                }
            }
            this.output += `${spaces}};\n`;
        } else if (block.name === "call") {
            const procName = String(block.args[0]);
            const args = block.args.slice(1).map(a => this.formatArg(a)).join(", ");
            this.output += `${spaces}await scratchRuntime.procedures["${procName}"](${args});\n`;
        }
    }

    private formatArg(arg: unknown): string {
        if (typeof arg === "string") {
            // Check if it's a variable reference
            if (arg.startsWith("var:")) {
                return `scratchRuntime.variables["${arg.slice(4)}"]`;
            }
            // Check if it's a list reference
            if (arg.startsWith("list:")) {
                return `scratchRuntime.lists["${arg.slice(5)}"]`;
            }
            return `"${arg}"`;
        } else if (typeof arg === "number") {
            return String(arg);
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // Handle nested blocks/expressions
            const block = arg as BlockNode;
            return this.formatExpression(block);
        }
        return JSON.stringify(arg);
    }

    private formatExpression(block: BlockNode): string {
        switch (block.type) {
            case "operator":
                return this.formatOperator(block);
            case "sensing":
                if (block.name === "answer") {
                    return `scratchRuntime.answer`;
                }
                break;
            case "variable":
                return `scratchRuntime.variables["${block.args[0]}"]`;
        }
        return JSON.stringify(block);
    }

    private formatOperator(block: BlockNode): string {
        switch (block.name) {
            case "add":
                return `(${this.formatArg(block.args[0])} + ${this.formatArg(block.args[1])})`;
            case "subtract":
                return `(${this.formatArg(block.args[0])} - ${this.formatArg(block.args[1])})`;
            case "multiply":
                return `(${this.formatArg(block.args[0])} * ${this.formatArg(block.args[1])})`;
            case "divide":
                return `(${this.formatArg(block.args[0])} / ${this.formatArg(block.args[1])})`;
            case "random":
                return `Math.floor(Math.random() * (${this.formatArg(block.args[1])} - ${this.formatArg(block.args[0])} + 1) + ${this.formatArg(block.args[0])})`;
            case "greaterThan":
                return `(${this.formatArg(block.args[0])} > ${this.formatArg(block.args[1])})`;
            case "lessThan":
                return `(${this.formatArg(block.args[0])} < ${this.formatArg(block.args[1])})`;
            case "equals":
                return `(${this.formatArg(block.args[0])} == ${this.formatArg(block.args[1])})`;
            case "and":
                return `(${this.formatCondition(block.args[0])} && ${this.formatCondition(block.args[1])})`;
            case "or":
                return `(${this.formatCondition(block.args[0])} || ${this.formatCondition(block.args[1])})`;
            case "not":
                return `!(${this.formatCondition(block.args[0])})`;
            case "join":
                return `String(${this.formatArg(block.args[0])}) + String(${this.formatArg(block.args[1])})`;
            case "mod":
                return `(${this.formatArg(block.args[0])} % ${this.formatArg(block.args[1])})`;
            case "round":
                return `Math.round(${this.formatArg(block.args[0])})`;
            case "abs":
                return `Math.abs(${this.formatArg(block.args[0])})`;
        }
        return "null";
    }

    private formatCondition(condition: unknown): string {
        if (typeof condition === "object" && condition !== null && "type" in condition) {
            return this.formatExpression(condition as BlockNode);
        }
        return String(condition);
    }
}
