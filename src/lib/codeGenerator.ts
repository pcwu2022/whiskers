// Enhanced CodeGenerator: Convert AST to JavaScript code
// This class converts an Abstract Syntax Tree (AST) generated by the Parser
// into executable JavaScript code with a Scratch-like runtime environment.

import { Program, BlockNode } from "@/types/compilerTypes";

export class CodeGenerator {
    // The program (AST) to generate code from
    private program: Program;
    // The generated JavaScript code output
    private output: string = "";
    // HTML output for browser display
    private htmlOutput: string = "";
    // Current indentation level for code formatting
    private indent: number = 0;
    // Track if we're inside a function definition
    private inFunction: boolean = false;
    // Custom procedures with their parameter lists
    private procedures: Map<string, string[]> = new Map();

    constructor(program: Program) {
        this.program = program;
    }

    /**
     * Main method to generate the JavaScript and HTML code
     * @returns Object containing JavaScript code and HTML
     */
    generate(): { js: string; html: string } {
        // First pass to collect all custom procedures
        this.collectProcedures();

        // Generate the JavaScript code
        this.generateJavaScript();

        // Generate the HTML wrapper
        this.generateHTML();

        return {
            js: this.output,
            html: this.htmlOutput,
        };
    }

    /**
     * Collects all custom procedures defined in the program
     */
    private collectProcedures(): void {
        this.program.scripts.forEach((script) => {
            script.blocks.forEach((block) => {
                this.findProceduresInBlock(block);
            });
        });
    }

    /**
     * Recursively searches for procedure definitions in blocks
     */
    private findProceduresInBlock(block: BlockNode): void {
        if (block.type === "custom" && block.name === "defineFunction") {
            const procedureName = block.args[0] as string;
            const parameters = block.args.slice(1) as string[];
            this.procedures.set(procedureName, parameters);
        }

        // Check next block in sequence
        if (block.next) {
            this.findProceduresInBlock(block.next);
        }
    }

    /**
     * Generates the JavaScript code from the AST
     */
    private generateJavaScript(): void {
        // Add runtime support code
        this.generateRuntimeSupport();

        // Generate code for variables
        this.generateVariablesCode();

        // Generate code for lists
        this.generateListsCode();

        // Generate code for custom procedures
        this.generateProceduresCode();

        // Generate code for scripts
        this.generateScriptsCode();
    }

    /**
     * Generates the runtime support functions
     */
    private generateRuntimeSupport(): void {
        this.output = `// Generated Scratch-like JavaScript code\n`;
        this.output += `// Runtime support functions\n`;
        this.output += `const scratchRuntime = {\n`;
        this.output += `    sprites: {},\n`;
        this.output += `    stage: { width: 480, height: 360 },\n`;
        this.output += `    currentSprite: 'Sprite1',\n`;
        this.output += `    variables: {},\n`;
        this.output += `    lists: {},\n`;
        this.output += `    procedures: {},\n`;
        this.output += `    events: {},\n`;
        this.output += `    answer: '',\n`;
        this.output += `    broadcasts: {},\n`;
        this.output += `    init: function() {\n`;
        this.output += `        // Create visual stage (deferred until DOM is ready)\n`;
        this.output += `        const setupUI = () => {\n`;
        this.output += `            const stageDiv = document.getElementById('stage');\n`;
        this.output += `            if (stageDiv) {\n`;
        this.output += `                stageDiv.style.width = this.stage.width + 'px';\n`;
        this.output += `                stageDiv.style.height = this.stage.height + 'px';\n`;
        this.output += `                stageDiv.style.backgroundColor = this.stage.backgroundColor;\n`;
        this.output += `                stageDiv.style.position = 'relative';\n`;
        this.output += `                stageDiv.style.overflow = 'hidden';\n`;
        this.output += `                stageDiv.style.border = '2px solid black';\n`;
        this.output += `\n`;
        this.output += `                // Create sprite element\n`;
        this.output += `                const spriteDiv = document.createElement('div');\n`;
        this.output += `                spriteDiv.id = 'sprite-Sprite1';\n`;
        this.output += `                spriteDiv.style.position = 'absolute';\n`;
        this.output += `                spriteDiv.style.width = '30px';\n`;
        this.output += `                spriteDiv.style.height = '30px';\n`;
        this.output += `                spriteDiv.style.backgroundColor = 'red';\n`;
        this.output += `                spriteDiv.style.borderRadius = '50%';\n`;
        this.output += `                spriteDiv.style.left = (this.sprites.Sprite1.x + this.stage.width/2) + 'px';\n`;
        this.output += `                spriteDiv.style.bottom = (this.sprites.Sprite1.y + this.stage.height/2) + 'px';\n`;
        this.output += `                spriteDiv.style.transform = 'rotate(0deg)';\n`;
        this.output += `                stageDiv.appendChild(spriteDiv);\n`;
        this.output += `            }\n`;
        this.output += `        };\n`;
        this.output += `\n`;
        this.output += `        if (document.readyState === 'loading') {\n`;
        this.output += `            document.addEventListener('DOMContentLoaded', setupUI);\n`;
        this.output += `        } else {\n`;
        this.output += `            setupUI();\n`;
        this.output += `        }\n`;
        this.output += `            },\n`;
        this.output += `            move: function(steps) {\n`;
        this.output += `                const radians = this.direction * Math.PI / 180;\n`;
        this.output += `                this.x += steps * Math.cos(radians);\n`;
        this.output += `                this.y += steps * Math.sin(radians);\n`;
        this.output += `                \n`;
        this.output += `                // Update sprite position in the DOM\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.left = (this.x + scratchRuntime.stage.width/2) + 'px';\n`;
        this.output += `                    spriteDiv.style.bottom = (this.y + scratchRuntime.stage.height/2) + 'px';\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} moved to (\${Math.floor(this.x)}, \${Math.floor(this.y)})\`);\n`;
        this.output += `            },\n`;
        this.output += `            turnRight: function(degrees) {\n`;
        this.output += `                this.direction = (this.direction + degrees) % 360;\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} turned right \${degrees} degrees to \${this.direction} degrees\`);\n`;
        this.output += `                // Update sprite rotation in the DOM\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.transform = \`rotate(\${this.direction - 90}deg)\`;\n`;
        this.output += `                }\n`;
        this.output += `            },\n`;
        this.output += `            turnLeft: function(degrees) {\n`;
        this.output += `                this.direction = (this.direction - degrees) % 360;\n`;
        this.output += `                if (this.direction < 0) this.direction += 360;\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} turned left \${degrees} degrees to \${this.direction} degrees\`);\n`;
        this.output += `                // Update sprite rotation in the DOM\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.transform = \`rotate(\${this.direction - 90}deg)\`;\n`;
        this.output += `                }\n`;
        this.output += `            },\n`;
        this.output += `            pointInDirection: function(direction) {\n`;
        this.output += `                this.direction = direction % 360;\n`;
        this.output += `                if (this.direction < 0) this.direction += 360;\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} now pointing in direction \${this.direction} degrees\`);\n`;
        this.output += `                // Update sprite rotation in the DOM\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.transform = \`rotate(\${this.direction - 90}deg)\`;\n`;
        this.output += `                }\n`;
        this.output += `            },\n`;
        this.output += `            goTo: function(x, y) {\n`;
        this.output += `                this.x = x;\n`;
        this.output += `                this.y = y;\n`;
        this.output += `                // Update sprite position in the DOM\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.left = (this.x + scratchRuntime.stage.width/2) + 'px';\n`;
        this.output += `                    spriteDiv.style.bottom = (this.y + scratchRuntime.stage.height/2) + 'px';\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} went to (\${Math.floor(this.x)}, \${Math.floor(this.y)})\`);\n`;
        this.output += `            },\n`;
        this.output += `            goToSprite: function(spriteName) {\n`;
        this.output += `                if (scratchRuntime.sprites[spriteName]) {\n`;
        this.output += `                    this.x = scratchRuntime.sprites[spriteName].x;\n`;
        this.output += `                    this.y = scratchRuntime.sprites[spriteName].y;\n`;
        this.output += `                    // Update sprite position in the DOM\n`;
        this.output += `                    const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                    if (spriteDiv) {\n`;
        this.output += `                        spriteDiv.style.left = (this.x + scratchRuntime.stage.width/2) + 'px';\n`;
        this.output += `                        spriteDiv.style.bottom = (this.y + scratchRuntime.stage.height/2) + 'px';\n`;
        this.output += `                    }\n`;
        this.output += `                    console.log(\`\${scratchRuntime.currentSprite} went to \${spriteName} at (\${Math.floor(this.x)}, \${Math.floor(this.y)})\`);\n`;
        this.output += `                }\n`;
        this.output += `            },\n`;
        this.output += `            hide: function() {\n`;
        this.output += `                this.visible = false;\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.display = 'none';\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} is now hidden\`);\n`;
        this.output += `            },\n`;
        this.output += `            show: function() {\n`;
        this.output += `                this.visible = true;\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.display = 'block';\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} is now shown\`);\n`;
        this.output += `            },\n`;
        this.output += `            changeSize: function(change) {\n`;
        this.output += `                this.size += change;\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.transform = \`rotate(\${this.direction - 90}deg) scale(\${this.size/100})\`;\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} size changed to \${this.size}%\`);\n`;
        this.output += `            },\n`;
        this.output += `            setSize: function(size) {\n`;
        this.output += `                this.size = size;\n`;
        this.output += `                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);\n`;
        this.output += `                if (spriteDiv) {\n`;
        this.output += `                    spriteDiv.style.transform = \`rotate(\${this.direction - 90}deg) scale(\${this.size/100})\`;\n`;
        this.output += `                }\n`;
        this.output += `                console.log(\`\${scratchRuntime.currentSprite} size set to \${this.size}%\`);\n`;
        this.output += `            }\n`;
        this.output += `        };\n\n`;

        // Add utility functions
        this.output += `        // Register event handlers\n`;
        this.output += `        document.addEventListener('keydown', (e) => {\n`;
        this.output += `            const keyEvent = \`keyPressed\${e.key}\`;\n`;
        this.output += `            if (this.events[keyEvent] && Array.isArray(this.events[keyEvent])) {\n`;
        this.output += `                this.events[keyEvent].forEach(callback => callback());\n`;
        this.output += `            }\n`;
        this.output += `        });\n\n`;

        this.output += `        // Create visual stage\n`;
        this.output += `        const stageDiv = document.getElementById('stage');\n`;
        this.output += `        if (stageDiv) {\n`;
        this.output += `            stageDiv.style.width = this.stage.width + 'px';\n`;
        this.output += `            stageDiv.style.height = this.stage.height + 'px';\n`;
        this.output += `            stageDiv.style.backgroundColor = this.stage.backgroundColor;\n`;
        this.output += `            stageDiv.style.position = 'relative';\n`;
        this.output += `            stageDiv.style.overflow = 'hidden';\n`;
        this.output += `            stageDiv.style.border = '2px solid black';\n\n`;

        this.output += `            // Create sprite element\n`;
        this.output += `            const spriteDiv = document.createElement('div');\n`;
        this.output += `            spriteDiv.id = 'sprite-Sprite1';\n`;
        this.output += `            spriteDiv.style.position = 'absolute';\n`;
        this.output += `            spriteDiv.style.width = '30px';\n`;
        this.output += `            spriteDiv.style.height = '30px';\n`;
        this.output += `            spriteDiv.style.backgroundColor = 'red';\n`;
        this.output += `            spriteDiv.style.borderRadius = '50%';\n`;
        this.output += `            spriteDiv.style.left = (this.sprites.Sprite1.x + this.stage.width/2) + 'px';\n`;
        this.output += `            spriteDiv.style.bottom = (this.sprites.Sprite1.y + this.stage.height/2) + 'px';\n`;
        this.output += `            spriteDiv.style.transform = 'rotate(0deg)';\n`;
        this.output += `            stageDiv.appendChild(spriteDiv);\n`;
        this.output += `        }\n`;
        this.output += `    },\n\n`;

        this.output += `    // Broadcasting system\n`;
        this.output += `    broadcast: function(message) {\n`;
        this.output += `        console.log(\`Broadcasting: \${message}\`);\n`;
        this.output += `        if (this.broadcasts[message] && Array.isArray(this.broadcasts[message])) {\n`;
        this.output += `            this.broadcasts[message].forEach(callback => callback());\n`;
        this.output += `        }\n`;
        this.output += `    },\n\n`;

        this.output += `    // Register a broadcast receiver\n`;
        this.output += `    onBroadcast: function(message, callback) {\n`;
        this.output += `        if (!this.broadcasts[message]) {\n`;
        this.output += `            this.broadcasts[message] = [];\n`;
        this.output += `        }\n`;
        this.output += `        this.broadcasts[message].push(callback);\n`;
        this.output += `    },\n\n`;

        this.output += `    // Register an event handler\n`;
        this.output += `    onEvent: function(event, callback) {\n`;
        this.output += `        if (!this.events[event]) {\n`;
        this.output += `            this.events[event] = [];\n`;
        this.output += `        }\n`;
        this.output += `        this.events[event].push(callback);\n`;
        this.output += `    },\n\n`;

        this.output += `    // Ask a question and get an answer\n`;
        this.output += `    ask: async function(question) {\n`;
        this.output += `        return new Promise((resolve) => {\n`;
        this.output += `            const askDiv = document.createElement('div');\n`;
        this.output += `            askDiv.id = 'ask-prompt';\n`;
        this.output += `            askDiv.style.position = 'absolute';\n`;
        this.output += `            askDiv.style.bottom = '10px';\n`;
        this.output += `            askDiv.style.left = '10px';\n`;
        this.output += `            askDiv.style.backgroundColor = 'white';\n`;
        this.output += `            askDiv.style.border = '2px solid black';\n`;
        this.output += `            askDiv.style.padding = '10px';\n`;
        this.output += `            askDiv.style.width = 'calc(100% - 40px)';\n`;
        this.output += `            askDiv.style.zIndex = '10';\n\n`;

        this.output += `            const questionText = document.createElement('div');\n`;
        this.output += `            questionText.textContent = question;\n`;
        this.output += `            askDiv.appendChild(questionText);\n\n`;

        this.output += `            const inputField = document.createElement('input');\n`;
        this.output += `            inputField.type = 'text';\n`;
        this.output += `            inputField.style.width = '100%';\n`;
        this.output += `            inputField.style.marginTop = '5px';\n`;
        this.output += `            askDiv.appendChild(inputField);\n\n`;

        this.output += `            const submitButton = document.createElement('button');\n`;
        this.output += `            submitButton.textContent = 'Answer';\n`;
        this.output += `            submitButton.style.marginTop = '5px';\n`;
        this.output += `            askDiv.appendChild(submitButton);\n\n`;

        this.output += `            submitButton.onclick = function() {\n`;
        this.output += `                scratchRuntime.answer = inputField.value;\n`;
        this.output += `                document.getElementById('stage').removeChild(askDiv);\n`;
        this.output += `                resolve(scratchRuntime.answer);\n`;
        this.output += `            };\n\n`;

        this.output += `            // Allow pressing Enter to submit\n`;
        this.output += `            inputField.addEventListener('keypress', function(e) {\n`;
        this.output += `                if (e.key === 'Enter') {\n`;
        this.output += `                    submitButton.click();\n`;
        this.output += `                }\n`;
        this.output += `            });\n\n`;

        this.output += `            document.getElementById('stage').appendChild(askDiv);\n`;
        this.output += `            inputField.focus();\n`;
        this.output += `        });\n`;
        this.output += `    }\n`;
        this.output += `};\n\n`;

        // Initialize runtime
        this.output += `// Initialize the runtime\n`;
        this.output += `scratchRuntime.init();\n\n`;
    }

    /**
     * Generates code for variables
     */
    private generateVariablesCode(): void {
        this.output += `// Variables\n`;
        if (this.program.variables.size > 0) {
            this.program.variables.forEach((value, name) => {
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${name}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${name}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${name}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for lists
     */
    private generateListsCode(): void {
        this.output += `// Lists\n`;
        if (this.program.lists.size > 0) {
            this.program.lists.forEach((values, name) => {
                const formattedValues = values.map((v) => (typeof v === "number" ? v : `"${v}"`)).join(", ");
                this.output += `scratchRuntime.lists["${name}"] = [${formattedValues}];\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for custom procedures
     */
    private generateProceduresCode(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size > 0) {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = function(${paramList}) {\n`;
                this.indent++;
                this.write(`// Function body will be generated during script processing\n`);
                this.indent--;
                this.output += `};\n\n`;
            });
        } else {
            this.output += `// No procedures defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for all scripts
     */
    private generateScriptsCode(): void {
        this.output += `// Scripts\n`;
        this.program.scripts.forEach((script, index) => {
            this.output += `// Script ${index + 1}\n`;
            script.blocks.forEach((block) => {
                this.generateBlockCode(block);
            });
            this.output += `\n`;
        });
    }

    /**
     * Generates code for a single block and its nested structure
     */
    private generateBlockCode(block: BlockNode): void {
        switch (block.type) {
            case "event":
                this.generateEventBlock(block);
                break;
            case "motion":
                this.generateMotionBlock(block);
                break;
            case "looks":
                this.generateLooksBlock(block);
                break;
            case "sound":
                this.generateSoundBlock(block);
                break;
            case "control":
                this.generateControlBlock(block);
                break;
            case "sensing":
                this.generateSensingBlock(block);
                break;
            case "operators":
                this.write(this.generateOperatorsBlock(block));
                break;
            case "variables":
                this.generateVariablesBlock(block);
                break;
            case "pen":
                this.generatePenBlock(block);
                break;
            case "custom":
                this.generateCustomBlock(block);
                break;
            default:
                this.write(`// Unsupported block type: ${block.type}, name: ${block.name}\n`);
        }
    }

    /**
     * Generates code for event blocks (when flag clicked, when key pressed, etc.)
     */
    private generateEventBlock(block: BlockNode): void {
        if (block.name === "when" && block.args[0] === "flagClicked") {
            this.write(`// When green flag clicked\n`);
            this.write(`document.addEventListener('DOMContentLoaded', async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "when" && typeof block.args[0] === "string" && block.args[0].includes("keyPressed")) {
            const key = (block.args[0] as string).replace("keyPressed", "").toLowerCase();
            this.write(`// When ${key} key pressed\n`);
            this.write(`scratchRuntime.onEvent("keyPressed${key}", async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "whenReceived") {
            const message = this.formatArg(block.args[0]);
            this.write(`// When I receive ${message}\n`);
            this.write(`scratchRuntime.onBroadcast(${message}, async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "broadcast") {
            const message = this.formatArg(block.args[0]);
            this.write(`scratchRuntime.broadcast(${message});\n`);
        } else if (block.name === "broadcastAndWait") {
            const message = this.formatArg(block.args[0]);
            this.write(`// Broadcast and wait (simplified implementation)\n`);
            this.write(`scratchRuntime.broadcast(${message});\n`);
            this.write(`await new Promise(resolve => setTimeout(resolve, 100));\n`);
        }

        // Note: Do not process block.next here - event handler bodies are generated above
    }

    /**
     * Generates code for motion blocks (move, turn, go to, etc.)
     */
    private generateMotionBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "move":
                const steps = this.formatArg(block.args[0]);
                this.write(`${sprite}.move(${steps});\n`);
                break;
            case "turnRight":
                const degreesRight = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnRight(${degreesRight});\n`);
                break;
            case "turnLeft":
                const degreesLeft = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnLeft(${degreesLeft});\n`);
                break;
            case "pointInDirection":
                const direction = this.formatArg(block.args[0]);
                this.write(`${sprite}.pointInDirection(${direction});\n`);
                break;
            case "goTo":
                if (block.args[0] === "random") {
                    this.write(`// Go to random position\n`);
                    this.write(
                        `const randomX = Math.floor(Math.random() * scratchRuntime.stage.width) - (scratchRuntime.stage.width / 2);\n`
                    );
                    this.write(
                        `const randomY = Math.floor(Math.random() * scratchRuntime.stage.height) - (scratchRuntime.stage.height / 2);\n`
                    );
                    this.write(`${sprite}.goTo(randomX, randomY);\n`);
                } else if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`${sprite}.goToSprite("${targetSprite}");\n`);
                } else {
                    const x = this.formatArg(block.args[0]);
                    const y = this.formatArg(block.args[1]);
                    this.write(`${sprite}.goTo(${x}, ${y});\n`);
                }
                break;
            case "setX":
                const x = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${x}, ${sprite}.y);\n`);
                break;
            case "setY":
                const y = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${y});\n`);
                break;
            case "changeX":
                const changeX = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x + ${changeX}, ${sprite}.y);\n`);
                break;
            case "changeY":
                const changeY = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${sprite}.y + ${changeY});\n`);
                break;
            case "glide":
                const seconds = this.formatArg(block.args[0]);
                const targetX = this.formatArg(block.args[1]);
                const targetY = this.formatArg(block.args[2]);
                this.write(`// Glide to position\n`);
                this.write(`const startX = ${sprite}.x;\n`);
                this.write(`const startY = ${sprite}.y;\n`);
                this.write(`const targetX = ${targetX};\n`);
                this.write(`const targetY = ${targetY};\n`);
                this.write(`const duration = ${seconds} * 1000;\n`);
                this.write(`const startTime = Date.now();\n\n`);

                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function animate() {\n`);
                this.indent++;
                this.write(`const elapsed = Date.now() - startTime;\n`);
                this.write(`const progress = Math.min(elapsed / duration, 1);\n`);
                this.write(`const newX = startX + (targetX - startX) * progress;\n`);
                this.write(`const newY = startY + (targetY - startY) * progress;\n`);
                this.write(`${sprite}.goTo(newX, newY);\n\n`);

                this.write(`if (progress < 1) {\n`);
                this.indent++;
                this.write(`requestAnimationFrame(animate);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n\n`);

                this.write(`animate();\n`);
                this.indent--;
                this.write(`});\n`);
                break;
            default:
                this.write(`// Unsupported motion block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for looks blocks (say, change size, etc.)
     */
    private generateLooksBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "say":
                const message = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`${sprite}.say(${message}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say(${message});\n`);
                }
                break;
            case "think":
                const thought = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`// Think is implemented the same as say but with different styling\n`);
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought});\n`);
                }
                break;
            case "show":
                this.write(`${sprite}.show();\n`);
                break;
            case "hide":
                this.write(`${sprite}.hide();\n`);
                break;
            case "changeSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changeSize(${sizeChange});\n`);
                break;
            case "setSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setSize(${size});\n`);
                break;
            case "switchCostume":
                const costume = this.formatArg(block.args[0]);
                this.write(`// Switch costume (simplified implementation)\n`);
                this.write(`console.log(\`Switching costume to \${${costume}}\`);\n`);
                break;
            default:
                this.write(`// Unsupported looks block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for sound blocks (play sound, change volume, etc.)
     */
    private generateSoundBlock(block: BlockNode): void {
        switch (block.name) {
            case "playSound":
                const sound = this.formatArg(block.args[0]);
                this.write(`// Play sound (simplified implementation)\n`);
                this.write(`console.log(\`Playing sound: \${${sound}}\`);\n`);
                break;
            case "stopAllSounds":
                this.write(`// Stop all sounds (simplified implementation)\n`);
                this.write(`console.log("Stopping all sounds");\n`);
                break;
            case "changeVolume":
                const volumeChange = this.formatArg(block.args[0]);
                this.write(`// Change volume (simplified implementation)\n`);
                this.write(
                    `scratchRuntime.stage.volume = Math.max(0, Math.min(100, scratchRuntime.stage.volume + ${volumeChange}));\n`
                );
                this.write(`console.log(\`Volume changed to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            case "setVolume":
                const volume = this.formatArg(block.args[0]);
                this.write(`// Set volume (simplified implementation)\n`);
                this.write(`scratchRuntime.stage.volume = Math.max(0, Math.min(100, ${volume}));\n`);
                this.write(`console.log(\`Volume set to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            default:
                this.write(`// Unsupported sound block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for control blocks (wait, repeat, if, etc.)
     */
    private generateControlBlock(block: BlockNode): void {
        switch (block.name) {
            case "wait":
                const seconds = this.formatArg(block.args[0]);
                this.write(`await new Promise(resolve => setTimeout(resolve, ${seconds} * 1000));\n`);

                // Process next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeat":
                const count = this.formatArg(block.args[0]);
                this.write(`// Repeat loop\n`);
                this.write(`for (let i = 0; i < ${count}; i++) {\n`);
                this.indent++;
                // Generate code for the blocks inside the loop body.
                // Prefer args[1] if present; fall back to block.next when the parser attached
                // the body incorrectly to `next` instead of as an arg.
                let nextAfterRepeat: BlockNode | undefined = undefined;
                let bodyBlock: BlockNode | undefined;

                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    bodyBlock = block.args[1] as BlockNode;
                } else if (block.next) {
                    // Treat block.next as the loop body if args don't contain it
                    bodyBlock = block.next as BlockNode;
                    nextAfterRepeat = block.next.next;
                }

                if (bodyBlock) {
                    this.generateBlockCode(bodyBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block after the repeat block if it exists
                if (!nextAfterRepeat && block.next) {
                    this.generateBlockCode(block.next);
                } else if (nextAfterRepeat) {
                    this.generateBlockCode(nextAfterRepeat);
                }
                break;
            case "forever":
                this.write(`// Forever loop (using setInterval for browser compatibility)\n`);
                this.write(`(async function forever() {\n`);
                this.indent++;
                // Prefer args[0] for body; fall back to block.next if parser attached body to next
                if (block.args.length > 0 && typeof block.args[0] === "object") {
                    this.generateBlockCode(block.args[0] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // Skip generating block.next again below
                    return;
                }

                this.write(`setTimeout(forever, 10); // Small delay to prevent UI freezing\n`);
                this.indent--;
                this.write(`})();\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "if":
                const condition = this.formatArg(block.args[0]);
                this.write(`// If statement\n`);
                this.write(`if (${condition}) {\n`);
                this.indent++;

                // Prefer args[1] for then-body; fall back to block.next when parser attached body to next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // If we used block.next as the body, advance the next chain appropriately below
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "ifElse":
                const ifCondition = this.formatArg(block.args[0]);
                const thenBlock = block.args[1] as BlockNode;
                const elseBlock = block.args[2] as BlockNode;

                this.write(`// If-Else statement\n`);
                this.write(`if (${ifCondition}) {\n`);
                this.indent++;

                // Generate code for the 'then' blocks
                if (thenBlock) {
                    this.generateBlockCode(thenBlock);
                }

                this.indent--;
                this.write(`} else {\n`);
                this.indent++;

                // Generate code for the 'else' blocks
                if (elseBlock) {
                    this.generateBlockCode(elseBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "waitUntil":
                const waitCondition = this.formatArg(block.args[0]);
                this.write(`// Wait until condition is true\n`);
                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function checkCondition() {\n`);
                this.indent++;
                this.write(`if (${waitCondition}) {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`setTimeout(checkCondition, 50);\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`checkCondition();\n`);
                this.indent--;
                this.write(`});\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeatUntil":
                const repeatCondition = this.formatArg(block.args[0]);
                this.write(`// Repeat until condition is true\n`);
                this.write(`while (!(${repeatCondition})) {\n`);
                this.indent++;

                // Prefer args[1] for body; fall back to block.next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                }

                // Add a small delay to prevent browser from freezing
                this.write(`await new Promise(resolve => setTimeout(resolve, 10));\n`);
                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "stop":
                const target = block.args[0];
                if (target === "all") {
                    this.write(`// Stop all (simplified implementation - just returns from current execution)\n`);
                    this.write(`return;\n`);
                } else if (target === "thisScript") {
                    this.write(`// Stop this script\n`);
                    this.write(`return;\n`);
                } else {
                    this.write(`// Stop other scripts (simplified implementation)\n`);
                    this.write(`console.log("Stop other scripts requested");\n`);
                }
                break;
            default:
                this.write(`// Unsupported control block: ${block.name}\n`);
        }
    }

    /**
     * Generates code for sensing blocks (ask, touching, etc.)
     */
    private generateSensingBlock(block: BlockNode): void {
        switch (block.name) {
            case "ask":
                const question = this.formatArg(block.args[0]);
                this.write(`// Ask a question and wait for answer\n`);
                this.write(`await scratchRuntime.ask(${question});\n`);
                break;
            case "answer":
                this.write(`scratchRuntime.answer`);
                break;
            case "touching":
                const target = this.formatArg(block.args[0]);
                this.write(`// Touching detection (simplified implementation)\n`);
                this.write(`/* Simulating touch detection */\n`);
                if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`((sprite) => {\n`);
                    this.indent++;
                    this.write(`const dx = sprite.x - scratchRuntime.sprites["${targetSprite}"].x;\n`);
                    this.write(`const dy = sprite.y - scratchRuntime.sprites["${targetSprite}"].y;\n`);
                    this.write(`return Math.sqrt(dx*dx + dy*dy) < 30; // Simple distance check\n`);
                    this.indent--;
                    this.write(`})(scratchRuntime.sprites[scratchRuntime.currentSprite])`);
                } else {
                    this.write(`false /* Touch detection for ${target} not implemented */`);
                }
                break;
            case "keyPressed":
                const key = this.formatArg(block.args[0]);
                this.write(`// Key pressed detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const pressedKeys = {};\n`);
                this.write(
                    `document.addEventListener('keydown', (e) => { pressedKeys[e.key.toLowerCase()] = true; });\n`
                );
                this.write(
                    `document.addEventListener('keyup', (e) => { delete pressedKeys[e.key.toLowerCase()]; });\n`
                );
                this.write(`return ${key}.toLowerCase() in pressedKeys;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseDown":
                this.write(`// Mouse down detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let isMouseDown = false;\n`);
                this.write(`document.addEventListener('mousedown', () => { isMouseDown = true; });\n`);
                this.write(`document.addEventListener('mouseup', () => { isMouseDown = false; });\n`);
                this.write(`return isMouseDown;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseX":
                this.write(`// Mouse X position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseX = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseX = e.clientX - rect.left - (rect.width / 2);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseX;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseY":
                this.write(`// Mouse Y position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseY = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseY = (rect.height / 2) - (e.clientY - rect.top);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseY;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "timer":
                this.write(`// Timer value (seconds since page load)\n`);
                this.write(`((start) => (Date.now() - start) / 1000)(Date.now())`);
                break;
            case "resetTimer":
                this.write(`// Reset timer (simplified implementation)\n`);
                this.write(`console.log("Timer reset requested");\n`);
                break;
            default:
                this.write(`// Unsupported sensing block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for operators blocks (mathematical and logical operations)
     */
    private generateOperatorsBlock(block: BlockNode): string {
        switch (block.name) {
            case "add":
                const addend1 = this.formatArg(block.args[0]);
                const addend2 = this.formatArg(block.args[1]);
                return `(Number(${addend1}) + Number(${addend2}))`;
            case "subtract":
                const minuend = this.formatArg(block.args[0]);
                const subtrahend = this.formatArg(block.args[1]);
                return `(Number(${minuend}) - Number(${subtrahend}))`;
            case "multiply":
                const factor1 = this.formatArg(block.args[0]);
                const factor2 = this.formatArg(block.args[1]);
                return `(Number(${factor1}) * Number(${factor2}))`;
            case "divide":
                const dividend = this.formatArg(block.args[0]);
                const divisor = this.formatArg(block.args[1]);
                return `(Number(${dividend}) / Number(${divisor}))`;
            case "mod":
                const modDividend = this.formatArg(block.args[0]);
                const modDivisor = this.formatArg(block.args[1]);
                return `(Number(${modDividend}) % Number(${modDivisor}))`;
            case "round":
                const roundValue = this.formatArg(block.args[0]);
                return `Math.round(Number(${roundValue}))`;
            case "abs":
                const absValue = this.formatArg(block.args[0]);
                return `Math.abs(Number(${absValue}))`;
            case "floor":
                const floorValue = this.formatArg(block.args[0]);
                return `Math.floor(Number(${floorValue}))`;
            case "ceiling":
                const ceilingValue = this.formatArg(block.args[0]);
                return `Math.ceil(Number(${ceilingValue}))`;
            case "sqrt":
                const sqrtValue = this.formatArg(block.args[0]);
                return `Math.sqrt(Number(${sqrtValue}))`;
            case "sin":
                const sinValue = this.formatArg(block.args[0]);
                return `Math.sin(Number(${sinValue}) * Math.PI / 180)`;
            case "cos":
                const cosValue = this.formatArg(block.args[0]);
                return `Math.cos(Number(${cosValue}) * Math.PI / 180)`;
            case "tan":
                const tanValue = this.formatArg(block.args[0]);
                return `Math.tan(Number(${tanValue}) * Math.PI / 180)`;
            case "greater":
                const greater1 = this.formatArg(block.args[0]);
                const greater2 = this.formatArg(block.args[1]);
                return `(Number(${greater1}) > Number(${greater2}))`;
            case "less":
                const less1 = this.formatArg(block.args[0]);
                const less2 = this.formatArg(block.args[1]);
                return `(Number(${less1}) < Number(${less2}))`;
            case "equals":
                const equals1 = this.formatArg(block.args[0]);
                const equals2 = this.formatArg(block.args[1]);
                return `(${equals1} == ${equals2})`;
            case "and":
                const and1 = this.formatArg(block.args[0]);
                const and2 = this.formatArg(block.args[1]);
                return `(${and1} && ${and2})`;
            case "or":
                const or1 = this.formatArg(block.args[0]);
                const or2 = this.formatArg(block.args[1]);
                return `(${or1} || ${or2})`;
            case "not":
                const notValue = this.formatArg(block.args[0]);
                return `!(${notValue})`;
            case "random":
                const min = this.formatArg(block.args[0]);
                const max = this.formatArg(block.args[1]);
                return `(Math.floor(Math.random() * (${max} - ${min} + 1)) + ${min})`;
            case "join":
                const string1 = this.formatArg(block.args[0]);
                const string2 = this.formatArg(block.args[1]);
                return `('' + ${string1} + ${string2})`;
            case "letterOf":
                const letter = this.formatArg(block.args[0]);
                const string = this.formatArg(block.args[1]);
                return `String(${string}).charAt(${letter} - 1)`;
            case "length":
                const lengthString = this.formatArg(block.args[0]);
                return `String(${lengthString}).length`;
            case "contains":
                const containsString = this.formatArg(block.args[0]);
                const substring = this.formatArg(block.args[1]);
                return `String(${containsString}).includes(String(${substring}))`;
            case "expression":
                const expression = this.formatArg(block.args[0]);
                return `(${expression})`;
            default:
                return `/* Unsupported operator: ${block.name} */`;
        }
    }

    /**
     * Generates code for variables blocks (set, change, etc.)
     */
    private generateVariablesBlock(block: BlockNode): void {
        switch (block.name) {
            case "set":
                const varName = block.args[0];
                const varValue = this.formatArg(block.args[1]);
                this.write(`scratchRuntime.variables["${varName}"] = ${varValue};\n`);
                break;
            case "change":
                const changeVarName = block.args[0];
                const changeValue = this.formatArg(block.args[1]);
                this.write(
                    `scratchRuntime.variables["${changeVarName}"] = Number(scratchRuntime.variables["${changeVarName}"]) + Number(${changeValue});\n`
                );
                break;
            case "showVariable":
                const showVarName = block.args[0];
                this.write(`// Show variable in the UI\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const varDisplay = document.getElementById('var-${showVarName}');\n`);
                this.write(`if (!varDisplay) {\n`);
                this.indent++;
                this.write(`const newVarDisplay = document.createElement('div');\n`);
                this.write(`newVarDisplay.id = 'var-${showVarName}';\n`);
                this.write(`newVarDisplay.className = 'scratch-variable';\n`);
                this.write(`newVarDisplay.style.position = 'absolute';\n`);
                this.write(`newVarDisplay.style.top = '10px';\n`);
                this.write(`newVarDisplay.style.left = '10px';\n`);
                this.write(`newVarDisplay.style.backgroundColor = 'rgba(255,255,255,0.7)';\n`);
                this.write(`newVarDisplay.style.padding = '5px';\n`);
                this.write(`newVarDisplay.style.borderRadius = '5px';\n`);
                this.write(
                    `newVarDisplay.textContent = '${showVarName}: ' + scratchRuntime.variables["${showVarName}"];\n`
                );
                this.write(`document.getElementById('stage').appendChild(newVarDisplay);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`varDisplay.style.display = 'block';\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`})();\n`);
                break;
            case "hideVariable":
                const hideVarName = block.args[0];
                this.write(`// Hide variable in the UI\n`);
                this.write(`const varDisplay = document.getElementById('var-${hideVarName}');\n`);
                this.write(`if (varDisplay) varDisplay.style.display = 'none';\n`);
                break;
            case "addToList":
                const listName = block.args[0];
                const itemValue = this.formatArg(block.args[1]);
                this.write(`// Add item to list\n`);
                this.write(`if (!scratchRuntime.lists["${listName}"]) scratchRuntime.lists["${listName}"] = [];\n`);
                this.write(`scratchRuntime.lists["${listName}"].push(${itemValue});\n`);
                break;
            case "deleteFromList":
                const deleteListName = block.args[0];
                const deleteIndex = this.formatArg(block.args[1]);
                this.write(`// Delete item from list\n`);
                this.write(
                    `if (scratchRuntime.lists["${deleteListName}"] && ${deleteIndex} > 0 && ${deleteIndex} <= scratchRuntime.lists["${deleteListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${deleteListName}"].splice(${deleteIndex} - 1, 1);\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "insertInList":
                const insertListName = block.args[0];
                const insertValue = this.formatArg(block.args[1]);
                const insertIndex = this.formatArg(block.args[2]);
                this.write(`// Insert item in list\n`);
                this.write(
                    `if (!scratchRuntime.lists["${insertListName}"]) scratchRuntime.lists["${insertListName}"] = [];\n`
                );
                this.write(
                    `if (${insertIndex} > 0 && ${insertIndex} <= scratchRuntime.lists["${insertListName}"].length + 1) {\n`
                );
                this.indent++;
                this.write(
                    `scratchRuntime.lists["${insertListName}"].splice(${insertIndex} - 1, 0, ${insertValue});\n`
                );
                this.indent--;
                this.write(`}\n`);
                break;
            case "replaceInList":
                const replaceListName = block.args[0];
                const replaceIndex = this.formatArg(block.args[1]);
                const replaceValue = this.formatArg(block.args[2]);
                this.write(`// Replace item in list\n`);
                this.write(
                    `if (scratchRuntime.lists["${replaceListName}"] && ${replaceIndex} > 0 && ${replaceIndex} <= scratchRuntime.lists["${replaceListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${replaceListName}"][${replaceIndex} - 1] = ${replaceValue};\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "itemOfList":
                const itemListName = block.args[0];
                const itemIndex = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${itemListName}"] && ${itemIndex} > 0 && ${itemIndex} <= scratchRuntime.lists["${itemListName}"].length ? scratchRuntime.lists["${itemListName}"][${itemIndex} - 1] : "")`
                );
            case "lengthOfList":
                const lengthListName = block.args[0];
                this.write(
                    `(scratchRuntime.lists["${lengthListName}"] ? scratchRuntime.lists["${lengthListName}"].length : 0)`
                );
            case "listContains":
                const containsListName = block.args[0];
                const containsItem = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${containsListName}"] ? scratchRuntime.lists["${containsListName}"].includes(${containsItem}) : false)`
                );
            default:
                this.write(`// Unsupported variables block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for pen blocks
     */
    private generatePenBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        // If pen methods don't exist yet, add them
        if (!this.penMethodsAdded) {
            this.addPenMethods();
        }

        switch (block.name) {
            case "penDown":
                this.write(`${sprite}.penDown();\n`);
                break;
            case "penUp":
                this.write(`${sprite}.penUp();\n`);
                break;
            case "setPenColor":
                const color = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenColor(${color});\n`);
                break;
            case "changePenSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changePenSize(${sizeChange});\n`);
                break;
            case "setPenSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenSize(${size});\n`);
                break;
            case "clear":
                this.write(`${sprite}.clearPen();\n`);
                break;
            case "stamp":
                this.write(`${sprite}.stamp();\n`);
                break;
            default:
                this.write(`// Unsupported pen block: ${block.name}\n`);
        }

        // Process the next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Flag to track if pen methods have been added to the runtime
     */
    private penMethodsAdded: boolean = false;

    /**
     * Adds pen methods to the runtime if they don't exist yet
     */
    private addPenMethods(): void {
        this.penMethodsAdded = true;

        // Add pen methods before the runtime init
        const penMethods = `
        // Add pen methods to the sprite prototype
        penDown: function() {
            this.penIsDown = true;
            console.log(\`\${scratchRuntime.currentSprite} pen down\`);
            
            // Create canvas for pen if it doesn't exist
            if (!document.getElementById('pen-canvas')) {
                const stageDiv = document.getElementById('stage');
                const canvas = document.createElement('canvas');
                canvas.id = 'pen-canvas';
                canvas.width = scratchRuntime.stage.width;
                canvas.height = scratchRuntime.stage.height;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                stageDiv.appendChild(canvas);
                
                // Store last position
                this.lastPenX = this.x + scratchRuntime.stage.width/2;
                this.lastPenY = scratchRuntime.stage.height/2 - this.y;
            }
        },
        
        penUp: function() {
            this.penIsDown = false;
            console.log(\`\${scratchRuntime.currentSprite} pen up\`);
        },
        
        setPenColor: function(color) {
            this.penColor = color;
            console.log(\`\${scratchRuntime.currentSprite} pen color set to \${color}\`);
        },
        
        changePenSize: function(change) {
            if (!this.penSize) this.penSize = 1;
            this.penSize += Number(change);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size changed to \${this.penSize}\`);
        },
        
        setPenSize: function(size) {
            this.penSize = Number(size);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size set to \${this.penSize}\`);
        },
        
        clearPen: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            console.log('Cleared pen marks');
        },
        
        stamp: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);
                if (spriteDiv) {
                    // This is a simplified stamp implementation
                    ctx.fillStyle = 'red'; // Use sprite color
                    ctx.beginPath();
                    ctx.arc(this.x + scratchRuntime.stage.width/2, 
                        scratchRuntime.stage.height/2 - this.y, 15, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            console.log(\`\${scratchRuntime.currentSprite} stamped\`);
        },
        
        // Update pen drawing when sprite moves
        updatePenDrawing: function() {
            if (this.penIsDown) {
                const canvas = document.getElementById('pen-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    
                    // Initialize pen properties if not set
                    if (!this.penColor) this.penColor = '#000000';
                    if (!this.penSize) this.penSize = 1;
                    
                    // Set drawing styles
                    ctx.strokeStyle = this.penColor;
                    ctx.lineWidth = this.penSize;
                    ctx.lineCap = 'round';
                    
                    // Calculate current position
                    const currentX = this.x + scratchRuntime.stage.width/2;
                    const currentY = scratchRuntime.stage.height/2 - this.y;
                    
                    // If last position exists, draw line
                    if (typeof this.lastPenX === 'number' && typeof this.lastPenY === 'number') {
                        ctx.beginPath();
                        ctx.moveTo(this.lastPenX, this.lastPenY);
                        ctx.lineTo(currentX, currentY);
                        ctx.stroke();
                    }
                    
                    // Update last position
                    this.lastPenX = currentX;
                    this.lastPenY = currentY;
                }
            }
        },`;

        // Insert pen methods into the sprite definition
        const insertPoint = this.output.lastIndexOf("};") - 1;
        this.output = this.output.substring(0, insertPoint) + penMethods + this.output.substring(insertPoint);

        // Update move and goto methods to handle pen drawing
        this.updateMovementMethods();
    }

    /**
     * Updates movement methods to handle pen drawing
     */
    private updateMovementMethods(): void {
        // Find and modify the move method to update pen drawing
        const moveMethodPos = this.output.indexOf("move: function(steps)");
        if (moveMethodPos > -1) {
            const endOfMoveMethod = this.output.indexOf("},", moveMethodPos) + 2;
            const moveMethod = this.output.substring(moveMethodPos, endOfMoveMethod);
            const updatedMoveMethod = moveMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, moveMethodPos) + updatedMoveMethod + this.output.substring(endOfMoveMethod);
        }

        // Find and modify the goTo method to update pen drawing
        const goToMethodPos = this.output.indexOf("goTo: function(x, y)");
        if (goToMethodPos > -1) {
            const endOfGoToMethod = this.output.indexOf("},", goToMethodPos) + 2;
            const goToMethod = this.output.substring(goToMethodPos, endOfGoToMethod);
            const updatedGoToMethod = goToMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, goToMethodPos) + updatedGoToMethod + this.output.substring(endOfGoToMethod);
        }
    }

    /**
     * Generates code for custom blocks (procedures)
     */
    private generateCustomBlock(block: BlockNode): void {
        if (block.name === "defineFunction") {
            // Define a custom procedure/function
            const functionName = block.args[0] as string;
            const paramList = block.args.slice(1) as string[];

            this.write(`// Define custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"] = function(${paramList.join(", ")}) {\n`);
            this.indent++;

            // Generate code for the function body
            if (block.next) {
                this.inFunction = true;
                this.generateBlockCode(block.next);
                this.inFunction = false;
            }

            this.indent--;
            this.write(`};\n\n`);
        } else if (block.name === "call") {
            // Call a custom procedure/function
            const functionName = block.args[0] as string;
            const args = block.args
                .slice(1)
                .map((arg) => this.formatArg(arg))
                .join(", ");

            this.write(`// Call custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"](${args});\n`);

            // Process the next block if it exists
            if (block.next) {
                this.generateBlockCode(block.next);
            }
        }
    }

    /**
     * Helper method to add proper indentation to the output
     */
    private write(text: string): void {
        const indentation = "    ".repeat(this.indent);
        this.output += indentation + text;
    }

    /**
     * Helper method to format arguments correctly
     */
    private formatArg(arg: string | number | object): string {
        if (typeof arg === "string") {
            // If it's a variable reference
            if (arg.startsWith("$")) {
                return `scratchRuntime.variables["${arg.substring(1)}"]`;
            }
            // If it's a list reference
            else if (arg.startsWith("#")) {
                return `scratchRuntime.lists["${arg.substring(1)}"]`;
            }
            // It's a regular string
            else {
                return `"${arg}"`;
            }
        } else if (typeof arg === "number") {
            return arg.toString();
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // It's a nested block
            const block = arg as BlockNode;
            if (block.type === "operators") {
                return this.generateOperatorsBlock(block);
            } else {
                this.write(`// Warning: Unexpected nested block type: ${block.type}\n`);
                return '""';
            }
        } else {
            return JSON.stringify(arg);
        }
    }

    /**
     * Generates HTML wrapper code
     */
    private generateHTML(): void {
        this.htmlOutput = `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Scratch-like JavaScript Program</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 0;
                padding: 20px;
                background-color: #f0f0f0;
            }
            
            .container {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                margin-bottom: 10px;
                display: flex;
                gap: 10px;
            }
            
            button {
                padding: 10px 15px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            
            button:hover {
                background-color: #45a049;
            }
            
            #stage {
                background-color: white;
                border: 2px solid #333;
                position: relative;
                overflow: hidden;
            }
            
            #console {
                width: 480px;
                height: 200px;
                margin-top: 20px;
                border: 1px solid #ccc;
                padding: 10px;
                overflow-y: auto;
                font-family: monospace;
                background-color: white;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Scratch-like JavaScript Program</h1>
            <div class="controls">
                <button id="start-button">Green Flag (Start)</button>
                <button id="stop-button">Stop</button>
                <button id="reset-button">Reset</button>
            </div>
            <div id="stage"></div>
            <div id="console"></div>
        </div>

        <script>
            // Console logging override to display in our custom console
            const originalConsoleLog = console.log;
            console.log = function() {
                // Call the original console.log
                originalConsoleLog.apply(console, arguments);
                
                // Display in our custom console
                const consoleDiv = document.getElementById('console');
                if (consoleDiv) {
                    const message = Array.from(arguments).join(' ');
                    const logLine = document.createElement('div');
                    logLine.textContent = message;
                    consoleDiv.appendChild(logLine);
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                }
                try {
                    if (window.parent && window.parent !== window) {
                        window.parent.postMessage({ type: 'scratch-log', message: Array.from(arguments).join(' ') }, '*');
                    }
                } catch (e) {}
            };
            
            // Setup controls
            document.getElementById('start-button').addEventListener('click', function() {
                // Trigger the green flag event
                const event = new Event('DOMContentLoaded');
                document.dispatchEvent(event);
            });
            
            document.getElementById('stop-button').addEventListener('click', function() {
                // For a real implementation, you would need a way to stop all running scripts
                console.log('Program stopped');
            });
            
            document.getElementById('reset-button').addEventListener('click', function() {
                // Reload the page to reset everything
                location.reload();
            });
            
            // Generated program code

            const outputProgram = async () => {
                try {
                    ${this.output}
                    return true;
                } catch (error) {
                    throw error;
                }
            };

            outputProgram()
                .then((data) => {
                    console.log(data);
                })
                .catch((error) => {
                    console.error(error);
                });
        </script>
    </body>
    </html>`;
    }
}
