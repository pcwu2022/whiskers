// Enhanced CodeGenerator: Convert AST to JavaScript code
// This class converts an Abstract Syntax Tree (AST) generated by the Parser
// into executable JavaScript code with a Scratch-like runtime environment.

import { Program, BlockNode } from "@/types/compilerTypes";
import { SCRATCH_RUNTIME, generateHTMLTemplate } from "@/templates";

export class CodeGenerator {
    // The program (AST) to generate code from
    private program: Program;
    // The generated JavaScript code output
    private output: string = "";
    // HTML output for browser display
    private htmlOutput: string = "";
    // Current indentation level for code formatting
    private indent: number = 0;
    // Track if we're inside a function definition
    private inFunction: boolean = false;
    // Custom procedures with their parameter lists
    private procedures: Map<string, string[]> = new Map();

    constructor(program: Program) {
        this.program = program;
    }

    /**
     * Main method to generate the JavaScript and HTML code
     * @returns Object containing JavaScript code and HTML
     */
    generate(): { js: string; html: string } {
        // First pass to collect all custom procedures
        this.collectProcedures();

        // Generate the JavaScript code
        this.generateJavaScript();

        // Generate the HTML wrapper
        this.generateHTML();

        return {
            js: this.output,
            html: this.htmlOutput,
        };
    }

    /**
     * Collects all custom procedures defined in the program
     */
    private collectProcedures(): void {
        this.program.scripts.forEach((script) => {
            script.blocks.forEach((block) => {
                this.findProceduresInBlock(block);
            });
        });
    }

    /**
     * Recursively searches for procedure definitions in blocks
     */
    private findProceduresInBlock(block: BlockNode): void {
        if (block.type === "custom" && block.name === "defineFunction") {
            const procedureName = block.args[0] as string;
            const parameters = block.args.slice(1) as string[];
            this.procedures.set(procedureName, parameters);
        }

        // Check next block in sequence
        if (block.next) {
            this.findProceduresInBlock(block.next);
        }
    }

    /**
     * Generates the JavaScript code from the AST
     */
    private generateJavaScript(): void {
        // Add runtime support code
        this.generateRuntimeSupport();

        // Generate code for variables
        this.generateVariablesCode();

        // Generate code for lists
        this.generateListsCode();

        // Generate code for custom procedures
        this.generateProceduresCode();

        // Generate code for scripts
        this.generateScriptsCode();
    }

    /**
     * Generates the runtime support functions
     */
    private generateRuntimeSupport(): void {
        this.output = SCRATCH_RUNTIME;
    }

    /**
     * Generates code for variables
     */
    private generateVariablesCode(): void {
        this.output += `// Variables\n`;
        if (this.program.variables.size > 0) {
            this.program.variables.forEach((value, name) => {
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${name}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${name}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${name}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for lists
     */
    private generateListsCode(): void {
        this.output += `// Lists\n`;
        if (this.program.lists.size > 0) {
            this.program.lists.forEach((values, name) => {
                const formattedValues = values.map((v) => (typeof v === "number" ? v : `"${v}"`)).join(", ");
                this.output += `scratchRuntime.lists["${name}"] = [${formattedValues}];\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for custom procedures
     */
    private generateProceduresCode(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size > 0) {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = function(${paramList}) {\n`;
                this.indent++;
                this.write(`// Function body will be generated during script processing\n`);
                this.indent--;
                this.output += `};\n\n`;
            });
        } else {
            this.output += `// No procedures defined\n`;
        }
        this.output += `\n`;
    }

    /**
     * Generates code for all scripts
     */
    private generateScriptsCode(): void {
        this.output += `// Scripts\n`;
        this.program.scripts.forEach((script, index) => {
            this.output += `// Script ${index + 1}\n`;
            script.blocks.forEach((block) => {
                this.generateBlockCode(block);
            });
            this.output += `\n`;
        });
    }

    /**
     * Generates code for a single block and its nested structure
     */
    private generateBlockCode(block: BlockNode): void {
        switch (block.type) {
            case "event":
                this.generateEventBlock(block);
                break;
            case "motion":
                this.generateMotionBlock(block);
                break;
            case "looks":
                this.generateLooksBlock(block);
                break;
            case "sound":
                this.generateSoundBlock(block);
                break;
            case "control":
                this.generateControlBlock(block);
                break;
            case "sensing":
                this.generateSensingBlock(block);
                break;
            case "operators":
                this.write(this.generateOperatorsBlock(block));
                break;
            case "variables":
                this.generateVariablesBlock(block);
                break;
            case "pen":
                this.generatePenBlock(block);
                break;
            case "custom":
                this.generateCustomBlock(block);
                break;
            default:
                this.write(`// Unsupported block type: ${block.type}, name: ${block.name}\n`);
        }
    }

    /**
     * Generates code for event blocks (when flag clicked, when key pressed, etc.)
     */
    private generateEventBlock(block: BlockNode): void {
        if (block.name === "when" && block.args[0] === "flagClicked") {
            this.write(`// When green flag clicked\n`);
            this.write(`scratchRuntime.onGreenFlag(async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "when" && typeof block.args[0] === "string" && block.args[0].includes("keyPressed")) {
            const key = (block.args[0] as string).replace("keyPressed", "").toLowerCase();
            this.write(`// When ${key} key pressed\n`);
            this.write(`scratchRuntime.onEvent("keyPressed_${key}", async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "whenReceived") {
            const message = this.formatArg(block.args[0]);
            this.write(`// When I receive ${message}\n`);
            this.write(`scratchRuntime.onBroadcast(${message}, async function() {\n`);
            this.indent++;

            // Generate code for the connected blocks
            if (block.next) {
                this.generateBlockCode(block.next);
            }

            this.indent--;
            this.write(`});\n\n`);
        } else if (block.name === "broadcast") {
            const message = this.formatArg(block.args[0]);
            this.write(`scratchRuntime.broadcast(${message});\n`);
        } else if (block.name === "broadcastAndWait") {
            const message = this.formatArg(block.args[0]);
            this.write(`// Broadcast and wait (simplified implementation)\n`);
            this.write(`scratchRuntime.broadcast(${message});\n`);
            this.write(`await new Promise(resolve => setTimeout(resolve, 100));\n`);
        }

        // Note: Do not process block.next here - event handler bodies are generated above
    }

    /**
     * Generates code for motion blocks (move, turn, go to, etc.)
     */
    private generateMotionBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "move":
                const steps = this.formatArg(block.args[0]);
                this.write(`${sprite}.move(${steps});\n`);
                break;
            case "turnRight":
                const degreesRight = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnRight(${degreesRight});\n`);
                break;
            case "turnLeft":
                const degreesLeft = this.formatArg(block.args[0]);
                this.write(`${sprite}.turnLeft(${degreesLeft});\n`);
                break;
            case "pointInDirection":
                const direction = this.formatArg(block.args[0]);
                this.write(`${sprite}.pointInDirection(${direction});\n`);
                break;
            case "goTo":
                if (block.args[0] === "random") {
                    this.write(`// Go to random position\n`);
                    this.write(
                        `const randomX = Math.floor(Math.random() * scratchRuntime.stage.width) - (scratchRuntime.stage.width / 2);\n`
                    );
                    this.write(
                        `const randomY = Math.floor(Math.random() * scratchRuntime.stage.height) - (scratchRuntime.stage.height / 2);\n`
                    );
                    this.write(`${sprite}.goTo(randomX, randomY);\n`);
                } else if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`${sprite}.goToSprite("${targetSprite}");\n`);
                } else {
                    const x = this.formatArg(block.args[0]);
                    const y = this.formatArg(block.args[1]);
                    this.write(`${sprite}.goTo(${x}, ${y});\n`);
                }
                break;
            case "setX":
                const x = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${x}, ${sprite}.y);\n`);
                break;
            case "setY":
                const y = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${y});\n`);
                break;
            case "changeX":
                const changeX = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x + ${changeX}, ${sprite}.y);\n`);
                break;
            case "changeY":
                const changeY = this.formatArg(block.args[0]);
                this.write(`${sprite}.goTo(${sprite}.x, ${sprite}.y + ${changeY});\n`);
                break;
            case "glide":
                const seconds = this.formatArg(block.args[0]);
                const targetX = this.formatArg(block.args[1]);
                const targetY = this.formatArg(block.args[2]);
                this.write(`// Glide to position\n`);
                this.write(`const startX = ${sprite}.x;\n`);
                this.write(`const startY = ${sprite}.y;\n`);
                this.write(`const targetX = ${targetX};\n`);
                this.write(`const targetY = ${targetY};\n`);
                this.write(`const duration = ${seconds} * 1000;\n`);
                this.write(`const startTime = Date.now();\n\n`);

                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function animate() {\n`);
                this.indent++;
                this.write(`const elapsed = Date.now() - startTime;\n`);
                this.write(`const progress = Math.min(elapsed / duration, 1);\n`);
                this.write(`const newX = startX + (targetX - startX) * progress;\n`);
                this.write(`const newY = startY + (targetY - startY) * progress;\n`);
                this.write(`${sprite}.goTo(newX, newY);\n\n`);

                this.write(`if (progress < 1) {\n`);
                this.indent++;
                this.write(`requestAnimationFrame(animate);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n\n`);

                this.write(`animate();\n`);
                this.indent--;
                this.write(`});\n`);
                break;
            default:
                this.write(`// Unsupported motion block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for looks blocks (say, change size, etc.)
     */
    private generateLooksBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        switch (block.name) {
            case "say":
                const message = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`${sprite}.say(${message}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say(${message});\n`);
                }
                break;
            case "think":
                const thought = this.formatArg(block.args[0]);
                if (block.args.length > 1) {
                    const seconds = this.formatArg(block.args[1]);
                    this.write(`// Think is implemented the same as say but with different styling\n`);
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought}, ${seconds});\n`);
                } else {
                    this.write(`${sprite}.say("ðŸ’­ " + ${thought});\n`);
                }
                break;
            case "show":
                this.write(`${sprite}.show();\n`);
                break;
            case "hide":
                this.write(`${sprite}.hide();\n`);
                break;
            case "changeSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changeSize(${sizeChange});\n`);
                break;
            case "setSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setSize(${size});\n`);
                break;
            case "switchCostume":
                const costume = this.formatArg(block.args[0]);
                this.write(`// Switch costume (simplified implementation)\n`);
                this.write(`console.log(\`Switching costume to \${${costume}}\`);\n`);
                break;
            default:
                this.write(`// Unsupported looks block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for sound blocks (play sound, change volume, etc.)
     */
    private generateSoundBlock(block: BlockNode): void {
        switch (block.name) {
            case "playSound":
                const sound = this.formatArg(block.args[0]);
                this.write(`// Play sound (simplified implementation)\n`);
                this.write(`console.log(\`Playing sound: \${${sound}}\`);\n`);
                break;
            case "stopAllSounds":
                this.write(`// Stop all sounds (simplified implementation)\n`);
                this.write(`console.log("Stopping all sounds");\n`);
                break;
            case "changeVolume":
                const volumeChange = this.formatArg(block.args[0]);
                this.write(`// Change volume (simplified implementation)\n`);
                this.write(
                    `scratchRuntime.stage.volume = Math.max(0, Math.min(100, scratchRuntime.stage.volume + ${volumeChange}));\n`
                );
                this.write(`console.log(\`Volume changed to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            case "setVolume":
                const volume = this.formatArg(block.args[0]);
                this.write(`// Set volume (simplified implementation)\n`);
                this.write(`scratchRuntime.stage.volume = Math.max(0, Math.min(100, ${volume}));\n`);
                this.write(`console.log(\`Volume set to \${scratchRuntime.stage.volume}%\`);\n`);
                break;
            default:
                this.write(`// Unsupported sound block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for control blocks (wait, repeat, if, etc.)
     */
    private generateControlBlock(block: BlockNode): void {
        switch (block.name) {
            case "wait":
                const seconds = this.formatArg(block.args[0]);
                this.write(`await new Promise(resolve => setTimeout(resolve, ${seconds} * 1000));\n`);

                // Process next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeat":
                const count = this.formatArg(block.args[0]);
                this.write(`// Repeat loop\n`);
                this.write(`for (let i = 0; i < ${count}; i++) {\n`);
                this.indent++;
                // Generate code for the blocks inside the loop body.
                // Prefer args[1] if present; fall back to block.next when the parser attached
                // the body incorrectly to `next` instead of as an arg.
                let nextAfterRepeat: BlockNode | undefined = undefined;
                let bodyBlock: BlockNode | undefined;

                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    bodyBlock = block.args[1] as BlockNode;
                } else if (block.next) {
                    // Treat block.next as the loop body if args don't contain it
                    bodyBlock = block.next as BlockNode;
                    nextAfterRepeat = block.next.next;
                }

                if (bodyBlock) {
                    this.generateBlockCode(bodyBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block after the repeat block if it exists
                if (!nextAfterRepeat && block.next) {
                    this.generateBlockCode(block.next);
                } else if (nextAfterRepeat) {
                    this.generateBlockCode(nextAfterRepeat);
                }
                break;
            case "forever":
                this.write(`// Forever loop (using setInterval for browser compatibility)\n`);
                this.write(`(async function forever() {\n`);
                this.indent++;
                // Prefer args[0] for body; fall back to block.next if parser attached body to next
                if (block.args.length > 0 && typeof block.args[0] === "object") {
                    this.generateBlockCode(block.args[0] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // Skip generating block.next again below
                    return;
                }

                this.write(`setTimeout(forever, 10); // Small delay to prevent UI freezing\n`);
                this.indent--;
                this.write(`})();\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "if":
                const condition = this.formatArg(block.args[0]);
                this.write(`// If statement\n`);
                this.write(`if (${condition}) {\n`);
                this.indent++;

                // Prefer args[1] for then-body; fall back to block.next when parser attached body to next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                    // If we used block.next as the body, advance the next chain appropriately below
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "ifElse":
                const ifCondition = this.formatArg(block.args[0]);
                const thenBlock = block.args[1] as BlockNode;
                const elseBlock = block.args[2] as BlockNode;

                this.write(`// If-Else statement\n`);
                this.write(`if (${ifCondition}) {\n`);
                this.indent++;

                // Generate code for the 'then' blocks
                if (thenBlock) {
                    this.generateBlockCode(thenBlock);
                }

                this.indent--;
                this.write(`} else {\n`);
                this.indent++;

                // Generate code for the 'else' blocks
                if (elseBlock) {
                    this.generateBlockCode(elseBlock);
                }

                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "waitUntil":
                const waitCondition = this.formatArg(block.args[0]);
                this.write(`// Wait until condition is true\n`);
                this.write(`await new Promise(resolve => {\n`);
                this.indent++;
                this.write(`function checkCondition() {\n`);
                this.indent++;
                this.write(`if (${waitCondition}) {\n`);
                this.indent++;
                this.write(`resolve();\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`setTimeout(checkCondition, 50);\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`checkCondition();\n`);
                this.indent--;
                this.write(`});\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "repeatUntil":
                const repeatCondition = this.formatArg(block.args[0]);
                this.write(`// Repeat until condition is true\n`);
                this.write(`while (!(${repeatCondition})) {\n`);
                this.indent++;

                // Prefer args[1] for body; fall back to block.next
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlockCode(block.args[1] as BlockNode);
                } else if (block.next) {
                    this.generateBlockCode(block.next as BlockNode);
                }

                // Add a small delay to prevent browser from freezing
                this.write(`await new Promise(resolve => setTimeout(resolve, 10));\n`);
                this.indent--;
                this.write(`}\n`);

                // Process the next block if it exists
                if (block.next) {
                    this.generateBlockCode(block.next);
                }
                break;
            case "stop":
                const target = block.args[0];
                if (target === "all") {
                    this.write(`// Stop all (simplified implementation - just returns from current execution)\n`);
                    this.write(`return;\n`);
                } else if (target === "thisScript") {
                    this.write(`// Stop this script\n`);
                    this.write(`return;\n`);
                } else {
                    this.write(`// Stop other scripts (simplified implementation)\n`);
                    this.write(`console.log("Stop other scripts requested");\n`);
                }
                break;
            default:
                this.write(`// Unsupported control block: ${block.name}\n`);
        }
    }

    /**
     * Generates code for sensing blocks (ask, touching, etc.)
     */
    private generateSensingBlock(block: BlockNode): void {
        switch (block.name) {
            case "ask":
                const question = this.formatArg(block.args[0]);
                this.write(`// Ask a question and wait for answer\n`);
                this.write(`await scratchRuntime.ask(${question});\n`);
                break;
            case "answer":
                this.write(`scratchRuntime.answer`);
                break;
            case "touching":
                const target = this.formatArg(block.args[0]);
                this.write(`// Touching detection (simplified implementation)\n`);
                this.write(`/* Simulating touch detection */\n`);
                if (typeof block.args[0] === "string" && block.args[0].startsWith("sprite:")) {
                    const targetSprite = block.args[0].replace("sprite:", "");
                    this.write(`((sprite) => {\n`);
                    this.indent++;
                    this.write(`const dx = sprite.x - scratchRuntime.sprites["${targetSprite}"].x;\n`);
                    this.write(`const dy = sprite.y - scratchRuntime.sprites["${targetSprite}"].y;\n`);
                    this.write(`return Math.sqrt(dx*dx + dy*dy) < 30; // Simple distance check\n`);
                    this.indent--;
                    this.write(`})(scratchRuntime.sprites[scratchRuntime.currentSprite])`);
                } else {
                    this.write(`false /* Touch detection for ${target} not implemented */`);
                }
                break;
            case "keyPressed":
                const key = this.formatArg(block.args[0]);
                this.write(`// Key pressed detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const pressedKeys = {};\n`);
                this.write(
                    `document.addEventListener('keydown', (e) => { pressedKeys[e.key.toLowerCase()] = true; });\n`
                );
                this.write(
                    `document.addEventListener('keyup', (e) => { delete pressedKeys[e.key.toLowerCase()]; });\n`
                );
                this.write(`return ${key}.toLowerCase() in pressedKeys;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseDown":
                this.write(`// Mouse down detection\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let isMouseDown = false;\n`);
                this.write(`document.addEventListener('mousedown', () => { isMouseDown = true; });\n`);
                this.write(`document.addEventListener('mouseup', () => { isMouseDown = false; });\n`);
                this.write(`return isMouseDown;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseX":
                this.write(`// Mouse X position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseX = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseX = e.clientX - rect.left - (rect.width / 2);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseX;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "mouseY":
                this.write(`// Mouse Y position (relative to stage center)\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`let mouseY = 0;\n`);
                this.write(`const stage = document.getElementById('stage');\n`);
                this.write(`if (stage) {\n`);
                this.indent++;
                this.write(`const rect = stage.getBoundingClientRect();\n`);
                this.write(`document.addEventListener('mousemove', (e) => {\n`);
                this.indent++;
                this.write(`mouseY = (rect.height / 2) - (e.clientY - rect.top);\n`);
                this.indent--;
                this.write(`});\n`);
                this.indent--;
                this.write(`}\n`);
                this.write(`return mouseY;\n`);
                this.indent--;
                this.write(`})()`);
                break;
            case "timer":
                this.write(`// Timer value (seconds since page load)\n`);
                this.write(`((start) => (Date.now() - start) / 1000)(Date.now())`);
                break;
            case "resetTimer":
                this.write(`// Reset timer (simplified implementation)\n`);
                this.write(`console.log("Timer reset requested");\n`);
                break;
            default:
                this.write(`// Unsupported sensing block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for operators blocks (mathematical and logical operations)
     */
    private generateOperatorsBlock(block: BlockNode): string {
        switch (block.name) {
            case "add":
                const addend1 = this.formatArg(block.args[0]);
                const addend2 = this.formatArg(block.args[1]);
                return `(Number(${addend1}) + Number(${addend2}))`;
            case "subtract":
                const minuend = this.formatArg(block.args[0]);
                const subtrahend = this.formatArg(block.args[1]);
                return `(Number(${minuend}) - Number(${subtrahend}))`;
            case "multiply":
                const factor1 = this.formatArg(block.args[0]);
                const factor2 = this.formatArg(block.args[1]);
                return `(Number(${factor1}) * Number(${factor2}))`;
            case "divide":
                const dividend = this.formatArg(block.args[0]);
                const divisor = this.formatArg(block.args[1]);
                return `(Number(${dividend}) / Number(${divisor}))`;
            case "mod":
                const modDividend = this.formatArg(block.args[0]);
                const modDivisor = this.formatArg(block.args[1]);
                return `(Number(${modDividend}) % Number(${modDivisor}))`;
            case "round":
                const roundValue = this.formatArg(block.args[0]);
                return `Math.round(Number(${roundValue}))`;
            case "abs":
                const absValue = this.formatArg(block.args[0]);
                return `Math.abs(Number(${absValue}))`;
            case "floor":
                const floorValue = this.formatArg(block.args[0]);
                return `Math.floor(Number(${floorValue}))`;
            case "ceiling":
                const ceilingValue = this.formatArg(block.args[0]);
                return `Math.ceil(Number(${ceilingValue}))`;
            case "sqrt":
                const sqrtValue = this.formatArg(block.args[0]);
                return `Math.sqrt(Number(${sqrtValue}))`;
            case "sin":
                const sinValue = this.formatArg(block.args[0]);
                return `Math.sin(Number(${sinValue}) * Math.PI / 180)`;
            case "cos":
                const cosValue = this.formatArg(block.args[0]);
                return `Math.cos(Number(${cosValue}) * Math.PI / 180)`;
            case "tan":
                const tanValue = this.formatArg(block.args[0]);
                return `Math.tan(Number(${tanValue}) * Math.PI / 180)`;
            case "greater":
                const greater1 = this.formatArg(block.args[0]);
                const greater2 = this.formatArg(block.args[1]);
                return `(Number(${greater1}) > Number(${greater2}))`;
            case "less":
                const less1 = this.formatArg(block.args[0]);
                const less2 = this.formatArg(block.args[1]);
                return `(Number(${less1}) < Number(${less2}))`;
            case "equals":
                const equals1 = this.formatArg(block.args[0]);
                const equals2 = this.formatArg(block.args[1]);
                return `(${equals1} == ${equals2})`;
            case "and":
                const and1 = this.formatArg(block.args[0]);
                const and2 = this.formatArg(block.args[1]);
                return `(${and1} && ${and2})`;
            case "or":
                const or1 = this.formatArg(block.args[0]);
                const or2 = this.formatArg(block.args[1]);
                return `(${or1} || ${or2})`;
            case "not":
                const notValue = this.formatArg(block.args[0]);
                return `!(${notValue})`;
            case "random":
                const min = this.formatArg(block.args[0]);
                const max = this.formatArg(block.args[1]);
                return `(Math.floor(Math.random() * (${max} - ${min} + 1)) + ${min})`;
            case "join":
                const string1 = this.formatArg(block.args[0]);
                const string2 = this.formatArg(block.args[1]);
                return `('' + ${string1} + ${string2})`;
            case "letterOf":
                const letter = this.formatArg(block.args[0]);
                const string = this.formatArg(block.args[1]);
                return `String(${string}).charAt(${letter} - 1)`;
            case "length":
                const lengthString = this.formatArg(block.args[0]);
                return `String(${lengthString}).length`;
            case "contains":
                const containsString = this.formatArg(block.args[0]);
                const substring = this.formatArg(block.args[1]);
                return `String(${containsString}).includes(String(${substring}))`;
            case "expression":
                const expression = this.formatArg(block.args[0]);
                return `(${expression})`;
            default:
                return `/* Unsupported operator: ${block.name} */`;
        }
    }

    /**
     * Generates code for variables blocks (set, change, etc.)
     */
    private generateVariablesBlock(block: BlockNode): void {
        switch (block.name) {
            case "set":
                const varName = block.args[0];
                const varValue = this.formatArg(block.args[1]);
                this.write(`scratchRuntime.variables["${varName}"] = ${varValue};\n`);
                break;
            case "change":
                const changeVarName = block.args[0];
                const changeValue = this.formatArg(block.args[1]);
                this.write(
                    `scratchRuntime.variables["${changeVarName}"] = Number(scratchRuntime.variables["${changeVarName}"]) + Number(${changeValue});\n`
                );
                break;
            case "showVariable":
                const showVarName = block.args[0];
                this.write(`// Show variable in the UI\n`);
                this.write(`(() => {\n`);
                this.indent++;
                this.write(`const varDisplay = document.getElementById('var-${showVarName}');\n`);
                this.write(`if (!varDisplay) {\n`);
                this.indent++;
                this.write(`const newVarDisplay = document.createElement('div');\n`);
                this.write(`newVarDisplay.id = 'var-${showVarName}';\n`);
                this.write(`newVarDisplay.className = 'scratch-variable';\n`);
                this.write(`newVarDisplay.style.position = 'absolute';\n`);
                this.write(`newVarDisplay.style.top = '10px';\n`);
                this.write(`newVarDisplay.style.left = '10px';\n`);
                this.write(`newVarDisplay.style.backgroundColor = 'rgba(255,255,255,0.7)';\n`);
                this.write(`newVarDisplay.style.padding = '5px';\n`);
                this.write(`newVarDisplay.style.borderRadius = '5px';\n`);
                this.write(
                    `newVarDisplay.textContent = '${showVarName}: ' + scratchRuntime.variables["${showVarName}"];\n`
                );
                this.write(`document.getElementById('stage').appendChild(newVarDisplay);\n`);
                this.indent--;
                this.write(`} else {\n`);
                this.indent++;
                this.write(`varDisplay.style.display = 'block';\n`);
                this.indent--;
                this.write(`}\n`);
                this.indent--;
                this.write(`})();\n`);
                break;
            case "hideVariable":
                const hideVarName = block.args[0];
                this.write(`// Hide variable in the UI\n`);
                this.write(`const varDisplay = document.getElementById('var-${hideVarName}');\n`);
                this.write(`if (varDisplay) varDisplay.style.display = 'none';\n`);
                break;
            case "addToList":
                const listName = block.args[0];
                const itemValue = this.formatArg(block.args[1]);
                this.write(`// Add item to list\n`);
                this.write(`if (!scratchRuntime.lists["${listName}"]) scratchRuntime.lists["${listName}"] = [];\n`);
                this.write(`scratchRuntime.lists["${listName}"].push(${itemValue});\n`);
                break;
            case "deleteFromList":
                const deleteListName = block.args[0];
                const deleteIndex = this.formatArg(block.args[1]);
                this.write(`// Delete item from list\n`);
                this.write(
                    `if (scratchRuntime.lists["${deleteListName}"] && ${deleteIndex} > 0 && ${deleteIndex} <= scratchRuntime.lists["${deleteListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${deleteListName}"].splice(${deleteIndex} - 1, 1);\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "insertInList":
                const insertListName = block.args[0];
                const insertValue = this.formatArg(block.args[1]);
                const insertIndex = this.formatArg(block.args[2]);
                this.write(`// Insert item in list\n`);
                this.write(
                    `if (!scratchRuntime.lists["${insertListName}"]) scratchRuntime.lists["${insertListName}"] = [];\n`
                );
                this.write(
                    `if (${insertIndex} > 0 && ${insertIndex} <= scratchRuntime.lists["${insertListName}"].length + 1) {\n`
                );
                this.indent++;
                this.write(
                    `scratchRuntime.lists["${insertListName}"].splice(${insertIndex} - 1, 0, ${insertValue});\n`
                );
                this.indent--;
                this.write(`}\n`);
                break;
            case "replaceInList":
                const replaceListName = block.args[0];
                const replaceIndex = this.formatArg(block.args[1]);
                const replaceValue = this.formatArg(block.args[2]);
                this.write(`// Replace item in list\n`);
                this.write(
                    `if (scratchRuntime.lists["${replaceListName}"] && ${replaceIndex} > 0 && ${replaceIndex} <= scratchRuntime.lists["${replaceListName}"].length) {\n`
                );
                this.indent++;
                this.write(`scratchRuntime.lists["${replaceListName}"][${replaceIndex} - 1] = ${replaceValue};\n`);
                this.indent--;
                this.write(`}\n`);
                break;
            case "itemOfList":
                const itemListName = block.args[0];
                const itemIndex = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${itemListName}"] && ${itemIndex} > 0 && ${itemIndex} <= scratchRuntime.lists["${itemListName}"].length ? scratchRuntime.lists["${itemListName}"][${itemIndex} - 1] : "")`
                );
            case "lengthOfList":
                const lengthListName = block.args[0];
                this.write(
                    `(scratchRuntime.lists["${lengthListName}"] ? scratchRuntime.lists["${lengthListName}"].length : 0)`
                );
            case "listContains":
                const containsListName = block.args[0];
                const containsItem = this.formatArg(block.args[1]);
                this.write(
                    `(scratchRuntime.lists["${containsListName}"] ? scratchRuntime.lists["${containsListName}"].includes(${containsItem}) : false)`
                );
            default:
                this.write(`// Unsupported variables block: ${block.name}\n`);
        }

        // Process next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Generates code for pen blocks
     */
    private generatePenBlock(block: BlockNode): void {
        const sprite = `scratchRuntime.sprites[scratchRuntime.currentSprite]`;

        // If pen methods don't exist yet, add them
        if (!this.penMethodsAdded) {
            this.addPenMethods();
        }

        switch (block.name) {
            case "penDown":
                this.write(`${sprite}.penDown();\n`);
                break;
            case "penUp":
                this.write(`${sprite}.penUp();\n`);
                break;
            case "setPenColor":
                const color = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenColor(${color});\n`);
                break;
            case "changePenSize":
                const sizeChange = this.formatArg(block.args[0]);
                this.write(`${sprite}.changePenSize(${sizeChange});\n`);
                break;
            case "setPenSize":
                const size = this.formatArg(block.args[0]);
                this.write(`${sprite}.setPenSize(${size});\n`);
                break;
            case "clear":
                this.write(`${sprite}.clearPen();\n`);
                break;
            case "stamp":
                this.write(`${sprite}.stamp();\n`);
                break;
            default:
                this.write(`// Unsupported pen block: ${block.name}\n`);
        }

        // Process the next block if it exists
        if (block.next) {
            this.generateBlockCode(block.next);
        }
    }

    /**
     * Flag to track if pen methods have been added to the runtime
     */
    private penMethodsAdded: boolean = false;

    /**
     * Adds pen methods to the runtime if they don't exist yet
     */
    private addPenMethods(): void {
        this.penMethodsAdded = true;

        // Add pen methods before the runtime init
        const penMethods = `
        // Add pen methods to the sprite prototype
        penDown: function() {
            this.penIsDown = true;
            console.log(\`\${scratchRuntime.currentSprite} pen down\`);
            
            // Create canvas for pen if it doesn't exist
            if (!document.getElementById('pen-canvas')) {
                const stageDiv = document.getElementById('stage');
                const canvas = document.createElement('canvas');
                canvas.id = 'pen-canvas';
                canvas.width = scratchRuntime.stage.width;
                canvas.height = scratchRuntime.stage.height;
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.pointerEvents = 'none';
                stageDiv.appendChild(canvas);
                
                // Store last position
                this.lastPenX = this.x + scratchRuntime.stage.width/2;
                this.lastPenY = scratchRuntime.stage.height/2 - this.y;
            }
        },
        
        penUp: function() {
            this.penIsDown = false;
            console.log(\`\${scratchRuntime.currentSprite} pen up\`);
        },
        
        setPenColor: function(color) {
            this.penColor = color;
            console.log(\`\${scratchRuntime.currentSprite} pen color set to \${color}\`);
        },
        
        changePenSize: function(change) {
            if (!this.penSize) this.penSize = 1;
            this.penSize += Number(change);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size changed to \${this.penSize}\`);
        },
        
        setPenSize: function(size) {
            this.penSize = Number(size);
            if (this.penSize < 1) this.penSize = 1;
            console.log(\`\${scratchRuntime.currentSprite} pen size set to \${this.penSize}\`);
        },
        
        clearPen: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            console.log('Cleared pen marks');
        },
        
        stamp: function() {
            const canvas = document.getElementById('pen-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                const spriteDiv = document.getElementById(\`sprite-\${scratchRuntime.currentSprite}\`);
                if (spriteDiv) {
                    // This is a simplified stamp implementation
                    ctx.fillStyle = 'red'; // Use sprite color
                    ctx.beginPath();
                    ctx.arc(this.x + scratchRuntime.stage.width/2, 
                        scratchRuntime.stage.height/2 - this.y, 15, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            console.log(\`\${scratchRuntime.currentSprite} stamped\`);
        },
        
        // Update pen drawing when sprite moves
        updatePenDrawing: function() {
            if (this.penIsDown) {
                const canvas = document.getElementById('pen-canvas');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    
                    // Initialize pen properties if not set
                    if (!this.penColor) this.penColor = '#000000';
                    if (!this.penSize) this.penSize = 1;
                    
                    // Set drawing styles
                    ctx.strokeStyle = this.penColor;
                    ctx.lineWidth = this.penSize;
                    ctx.lineCap = 'round';
                    
                    // Calculate current position
                    const currentX = this.x + scratchRuntime.stage.width/2;
                    const currentY = scratchRuntime.stage.height/2 - this.y;
                    
                    // If last position exists, draw line
                    if (typeof this.lastPenX === 'number' && typeof this.lastPenY === 'number') {
                        ctx.beginPath();
                        ctx.moveTo(this.lastPenX, this.lastPenY);
                        ctx.lineTo(currentX, currentY);
                        ctx.stroke();
                    }
                    
                    // Update last position
                    this.lastPenX = currentX;
                    this.lastPenY = currentY;
                }
            }
        },`;

        // Insert pen methods into the sprite definition
        const insertPoint = this.output.lastIndexOf("};") - 1;
        this.output = this.output.substring(0, insertPoint) + penMethods + this.output.substring(insertPoint);

        // Update move and goto methods to handle pen drawing
        this.updateMovementMethods();
    }

    /**
     * Updates movement methods to handle pen drawing
     */
    private updateMovementMethods(): void {
        // Find and modify the move method to update pen drawing
        const moveMethodPos = this.output.indexOf("move: function(steps)");
        if (moveMethodPos > -1) {
            const endOfMoveMethod = this.output.indexOf("},", moveMethodPos) + 2;
            const moveMethod = this.output.substring(moveMethodPos, endOfMoveMethod);
            const updatedMoveMethod = moveMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} moved to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, moveMethodPos) + updatedMoveMethod + this.output.substring(endOfMoveMethod);
        }

        // Find and modify the goTo method to update pen drawing
        const goToMethodPos = this.output.indexOf("goTo: function(x, y)");
        if (goToMethodPos > -1) {
            const endOfGoToMethod = this.output.indexOf("},", goToMethodPos) + 2;
            const goToMethod = this.output.substring(goToMethodPos, endOfGoToMethod);
            const updatedGoToMethod = goToMethod.replace(
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n",
                "console.log(`${scratchRuntime.currentSprite} went to (${Math.floor(this.x)}, ${Math.floor(this.y)})`);\n                    this.updatePenDrawing();\n"
            );
            this.output =
                this.output.substring(0, goToMethodPos) + updatedGoToMethod + this.output.substring(endOfGoToMethod);
        }
    }

    /**
     * Generates code for custom blocks (procedures)
     */
    private generateCustomBlock(block: BlockNode): void {
        if (block.name === "defineFunction") {
            // Define a custom procedure/function
            const functionName = block.args[0] as string;
            const paramList = block.args.slice(1) as string[];

            this.write(`// Define custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"] = function(${paramList.join(", ")}) {\n`);
            this.indent++;

            // Generate code for the function body
            if (block.next) {
                this.inFunction = true;
                this.generateBlockCode(block.next);
                this.inFunction = false;
            }

            this.indent--;
            this.write(`};\n\n`);
        } else if (block.name === "call") {
            // Call a custom procedure/function
            const functionName = block.args[0] as string;
            const args = block.args
                .slice(1)
                .map((arg) => this.formatArg(arg))
                .join(", ");

            this.write(`// Call custom procedure: ${functionName}\n`);
            this.write(`scratchRuntime.procedures["${functionName}"](${args});\n`);

            // Process the next block if it exists
            if (block.next) {
                this.generateBlockCode(block.next);
            }
        }
    }

    /**
     * Helper method to add proper indentation to the output
     */
    private write(text: string): void {
        const indentation = "    ".repeat(this.indent);
        this.output += indentation + text;
    }

    /**
     * Helper method to format arguments correctly
     */
    private formatArg(arg: string | number | object): string {
        if (typeof arg === "string") {
            // If it's a variable reference
            if (arg.startsWith("$")) {
                return `scratchRuntime.variables["${arg.substring(1)}"]`;
            }
            // If it's a list reference
            else if (arg.startsWith("#")) {
                return `scratchRuntime.lists["${arg.substring(1)}"]`;
            }
            // It's a regular string
            else {
                return `"${arg}"`;
            }
        } else if (typeof arg === "number") {
            return arg.toString();
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // It's a nested block
            const block = arg as BlockNode;
            if (block.type === "operators") {
                return this.generateOperatorsBlock(block);
            } else {
                this.write(`// Warning: Unexpected nested block type: ${block.type}\n`);
                return '""';
            }
        } else {
            return JSON.stringify(arg);
        }
    }

    /**
     * Generates HTML wrapper code using the template
     */
    private generateHTML(): void {
        this.htmlOutput = generateHTMLTemplate(this.output);
    }
}

/**
 * MultiSpriteCodeGenerator: Generates code for multiple sprites
 * Each sprite gets its own initialization and script code
 * Supports all Scratch 3.0 block categories
 */
export class MultiSpriteCodeGenerator {
    private sprites: { name: string; program: Program; isStage?: boolean }[];
    private output: string = "";
    private htmlOutput: string = "";
    private procedures: Map<string, string[]> = new Map();

    constructor(sprites: { name: string; program: Program; isStage?: boolean }[]) {
        this.sprites = sprites;
    }

    generate(): { js: string; html: string } {
        // Add runtime support code
        this.output = SCRATCH_RUNTIME;

        // Collect all procedures from all sprites
        this.collectAllProcedures();

        // Generate variables (global scope)
        this.generateGlobalVariables();

        // Generate lists (global scope)
        this.generateGlobalLists();

        // Initialize all sprites
        this.generateSpriteInitializations();

        // Generate custom procedures
        this.generateProcedures();

        // Generate code for each sprite's scripts
        this.generateSpriteScripts();

        // Generate HTML
        this.htmlOutput = generateHTMLTemplate(this.output);

        return {
            js: this.output,
            html: this.htmlOutput,
        };
    }

    private collectAllProcedures(): void {
        for (const sprite of this.sprites) {
            for (const script of sprite.program.scripts) {
                for (const block of script.blocks) {
                    this.findProcedures(block);
                }
            }
        }
    }

    private findProcedures(block: BlockNode): void {
        if ((block.type === "procedure" || block.type === "custom") && block.name === "define") {
            const procName = String(block.args[0]);
            const params = block.args.slice(1).map((a) => String(a));
            this.procedures.set(procName, params);
        }
        if (block.body) {
            for (const child of block.body) {
                this.findProcedures(child);
            }
        }
        if (block.next) {
            this.findProcedures(block.next);
        }
    }

    private generateGlobalVariables(): void {
        this.output += `// Variables\n`;
        const allVars = new Map<string, unknown>();
        for (const sprite of this.sprites) {
            sprite.program.variables.forEach((value, name) => {
                allVars.set(name, value);
            });
        }
        if (allVars.size > 0) {
            allVars.forEach((value, name) => {
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${name}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${name}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${name}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    private generateGlobalLists(): void {
        this.output += `// Lists\n`;
        const allLists = new Map<string, unknown[]>();
        for (const sprite of this.sprites) {
            sprite.program.lists.forEach((value, name) => {
                allLists.set(name, value);
            });
        }
        if (allLists.size > 0) {
            allLists.forEach((value, name) => {
                this.output += `scratchRuntime.lists["${name}"] = ${JSON.stringify(value)};\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    private generateSpriteInitializations(): void {
        this.output += `// Initialize Sprites\n`;
        
        // Remove default Sprite1 if it's not in our sprite list
        const spriteNames = this.sprites.map(s => s.name);
        if (!spriteNames.includes("Sprite1")) {
            this.output += `delete scratchRuntime.sprites["Sprite1"];\n`;
        }

        for (let i = 0; i < this.sprites.length; i++) {
            const sprite = this.sprites[i];
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            
            // Skip backdrop/stage visual initialization (it's the background)
            if (sprite.isStage) {
                this.output += `// Stage (backdrop) initialized - no visual sprite element\n`;
                continue;
            }
            
            // Initialize the sprite with options
            const xOffset = (i - Math.floor(this.sprites.length / 2)) * 50;
            this.output += `scratchRuntime.initSprite("${safeName}", {\n`;
            this.output += `    x: ${xOffset},\n`;
            this.output += `    y: 0,\n`;
            this.output += `    direction: 90,\n`;
            this.output += `    visible: true,\n`;
            this.output += `    size: 100,\n`;
            this.output += `    rotationStyle: 'all around',\n`;
            this.output += `    costumes: ['costume1'],\n`;
            this.output += `    currentCostume: 0\n`;
            this.output += `});\n`;
        }
        
        this.output += `\n`;
    }

    private generateProcedures(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size === 0) {
            this.output += `// No procedures defined\n`;
        } else {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = async function(${paramList}) {\n`;
                this.output += `    // Procedure body will be filled by scripts\n`;
                this.output += `};\n`;
            });
        }
        this.output += `\n`;
    }

    private generateSpriteScripts(): void {
        this.output += `// Scripts\n`;
        
        for (const sprite of this.sprites) {
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            const isStage = sprite.isStage || false;
            this.output += `// === ${sprite.name} Scripts ===\n`;
            this.output += `(function() {\n`;
            this.output += `    const CURRENT_SPRITE = "${safeName}";\n`;
            this.output += `    const IS_STAGE = ${isStage};\n`;
            if (!isStage) {
                this.output += `    const sprite = scratchRuntime.sprites[CURRENT_SPRITE];\n`;
            }
            this.output += `\n`;
            
            // Generate each script
            for (let i = 0; i < sprite.program.scripts.length; i++) {
                const script = sprite.program.scripts[i];
                this.output += `    // Script ${i + 1}\n`;
                
                for (const block of script.blocks) {
                    this.generateBlock(block, 1, safeName, isStage);
                }
            }
            
            this.output += `})();\n\n`;
        }
    }

    private generateBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean = false): void {
        const spaces = "    ".repeat(indent);
        const spriteRef = isStage ? `null` : `scratchRuntime.sprites["${spriteName}"]`;
        
        // Track if the block handler consumed block.next internally
        let nextHandled = false;

        switch (block.type) {
            case "event":
                nextHandled = this.generateEventBlock(block, indent, spriteName, isStage);
                break;
            case "motion":
                if (!isStage) {
                    this.generateMotionBlock(block, indent, spriteRef, spriteName);
                }
                break;
            case "looks":
                this.generateLooksBlock(block, indent, spriteRef, spriteName, isStage);
                break;
            case "control":
                nextHandled = this.generateControlBlock(block, indent, spriteName, isStage);
                break;
            case "sound":
                this.generateSoundBlock(block, indent);
                break;
            case "sensing":
                this.generateSensingBlock(block, indent, spriteName, isStage);
                break;
            case "operators":
            case "operator":
                // Operators are usually inline expressions, handled by formatArg
                break;
            case "variables":
            case "variable":
                this.generateVariableBlock(block, indent);
                break;
            case "list":
                this.generateListBlock(block, indent);
                break;
            case "procedure":
            case "custom":
                this.generateProcedureBlock(block, indent, spriteName, isStage);
                break;
            case "pen":
                if (!isStage) {
                    this.generatePenBlock(block, indent, spriteRef);
                }
                break;
            default:
                this.output += `${spaces}// Unknown block type: ${block.type}, name: ${block.name}\n`;
        }

        // Only process block.next if the handler didn't already consume it
        if (block.next && !nextHandled) {
            this.generateBlock(block.next, indent, spriteName, isStage);
        }
    }

    private generateEventBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): boolean {
        const spaces = "    ".repeat(indent);

        // Mark that we handled the event to prevent block.next from being generated twice
        let eventHandled = false;
        
        if (block.name === "when" && block.args[0] === "flagClicked") {
            this.output += `${spaces}// When green flag clicked\n`;
            this.output += `${spaces}scratchRuntime.onGreenFlag(async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "when" && (String(block.args[0]) === "keyPressed" || String(block.args[0]).includes("keyPressed"))) {
            // Handle "when keyPressed space" where args are ["keyPressed", "space"]
            // or "when keyPressed_space" where args are ["keyPressed_space"]
            let key = "";
            if (block.args.length > 1 && typeof block.args[1] === "string") {
                key = String(block.args[1]).toLowerCase();
            } else {
                key = String(block.args[0]).replace("keyPressed", "").replace("_", "").toLowerCase();
            }
            // Map common key names
            if (key === "up" || key === "arrowup") key = "arrowup";
            else if (key === "down" || key === "arrowdown") key = "arrowdown";
            else if (key === "left" || key === "arrowleft") key = "arrowleft";
            else if (key === "right" || key === "arrowright") key = "arrowright";
            else if (key === "space" || key === " ") key = " ";
            
            this.output += `${spaces}// When ${key} key pressed\n`;
            this.output += `${spaces}scratchRuntime.onEvent("keyPressed_${key}", async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "when" && String(block.args[0]) === "thisSprite" && String(block.args[1]) === "clicked") {
            this.output += `${spaces}// When this sprite clicked\n`;
            this.output += `${spaces}scratchRuntime.onEvent("spriteClicked_${spriteName}", async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "when" && String(block.args[0]) === "backdrop" && String(block.args[1]) === "switches") {
            const backdrop = this.formatArg(block.args[2]);
            this.output += `${spaces}// When backdrop switches to ${backdrop}\n`;
            this.output += `${spaces}scratchRuntime.onEvent("backdropSwitch_" + ${backdrop}, async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (
            // Handle multiple patterns for "when I start as a clone"
            (block.name === "when" && String(block.args[0]) === "clone" && String(block.args[1]) === "starts") ||
            (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "start" && String(block.args[2]) === "as") ||
            (block.name === "when" && String(block.args[0]) === "cloneStarted") ||
            block.name === "whenCloneStarted"
        ) {
            this.output += `${spaces}// When I start as a clone\n`;
            this.output += `${spaces}scratchRuntime.onEvent("cloneStart_${spriteName}", async function() {\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (
            // Handle multiple patterns for "when I receive"
            block.name === "whenReceived" ||
            (block.name === "when" && block.args[0] === "receive") ||
            (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "receive")
        ) {
            // Find the message argument - it could be at different positions depending on parsing
            let message: string;
            if (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "receive") {
                message = this.formatArg(block.args[2]);
            } else if (block.name === "when" && block.args[0] === "receive") {
                message = this.formatArg(block.args[1]);
            } else {
                message = this.formatArg(block.args[0]);
            }
            this.output += `${spaces}// When I receive ${message}\n`;
            this.output += `${spaces}scratchRuntime.onBroadcast(${message}, async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "broadcast") {
            this.output += `${spaces}scratchRuntime.broadcast(${this.formatArg(block.args[0])});\n`;
        } else if (block.name === "broadcastAndWait") {
            this.output += `${spaces}await scratchRuntime.broadcastAndWait(${this.formatArg(block.args[0])});\n`;
        }
        
        // Return whether this was an event that handled its own block.next
        return eventHandled;
    }

    private generateMotionBlock(block: BlockNode, indent: number, spriteRef: string, _spriteName: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "move":
                this.output += `${spaces}${spriteRef}.move(${this.formatArg(block.args[0])});\n`;
                break;
            case "turn":
            case "turnRight":
                this.output += `${spaces}${spriteRef}.turnRight(${this.formatArg(block.args[0])});\n`;
                break;
            case "turnLeft":
                this.output += `${spaces}${spriteRef}.turnLeft(${this.formatArg(block.args[0])});\n`;
                break;
            case "goTo":
            case "goto":
                if (block.args.length === 2 && typeof block.args[0] === "number") {
                    this.output += `${spaces}${spriteRef}.goTo(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                } else {
                    this.output += `${spaces}${spriteRef}.goToTarget(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goToXY":
                this.output += `${spaces}${spriteRef}.goTo(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                break;
            case "glide":
            case "glideToXY":
                const seconds = this.formatArg(block.args[0]);
                const targetX = this.formatArg(block.args[1]);
                const targetY = this.formatArg(block.args[2]);
                this.output += `${spaces}// Glide to position\n`;
                this.output += `${spaces}await (async function() {\n`;
                this.output += `${spaces}    const startX = ${spriteRef}.x;\n`;
                this.output += `${spaces}    const startY = ${spriteRef}.y;\n`;
                this.output += `${spaces}    const duration = ${seconds} * 1000;\n`;
                this.output += `${spaces}    const startTime = Date.now();\n`;
                this.output += `${spaces}    while (Date.now() - startTime < duration) {\n`;
                this.output += `${spaces}        const progress = (Date.now() - startTime) / duration;\n`;
                this.output += `${spaces}        ${spriteRef}.goTo(startX + (${targetX} - startX) * progress, startY + (${targetY} - startY) * progress);\n`;
                this.output += `${spaces}        await scratchRuntime.wait(0.016);\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}    ${spriteRef}.goTo(${targetX}, ${targetY});\n`;
                this.output += `${spaces}})();\n`;
                break;
            case "glideTo":
                const glideSeconds = this.formatArg(block.args[0]);
                const target = this.formatArg(block.args[1]);
                this.output += `${spaces}// Glide to target\n`;
                this.output += `${spaces}await (async function() {\n`;
                this.output += `${spaces}    let targetX, targetY;\n`;
                this.output += `${spaces}    if (${target} === 'mouse-pointer') {\n`;
                this.output += `${spaces}        targetX = scratchRuntime.mouse.x; targetY = scratchRuntime.mouse.y;\n`;
                this.output += `${spaces}    } else if (${target} === 'random') {\n`;
                this.output += `${spaces}        targetX = Math.random() * scratchRuntime.stage.width - scratchRuntime.stage.width/2;\n`;
                this.output += `${spaces}        targetY = Math.random() * scratchRuntime.stage.height - scratchRuntime.stage.height/2;\n`;
                this.output += `${spaces}    } else if (scratchRuntime.sprites[${target}]) {\n`;
                this.output += `${spaces}        targetX = scratchRuntime.sprites[${target}].x; targetY = scratchRuntime.sprites[${target}].y;\n`;
                this.output += `${spaces}    } else { return; }\n`;
                this.output += `${spaces}    const startX = ${spriteRef}.x, startY = ${spriteRef}.y;\n`;
                this.output += `${spaces}    const duration = ${glideSeconds} * 1000;\n`;
                this.output += `${spaces}    const startTime = Date.now();\n`;
                this.output += `${spaces}    while (Date.now() - startTime < duration) {\n`;
                this.output += `${spaces}        const progress = (Date.now() - startTime) / duration;\n`;
                this.output += `${spaces}        ${spriteRef}.goTo(startX + (targetX - startX) * progress, startY + (targetY - startY) * progress);\n`;
                this.output += `${spaces}        await scratchRuntime.wait(0.016);\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}    ${spriteRef}.goTo(targetX, targetY);\n`;
                this.output += `${spaces}})();\n`;
                break;
            case "setX":
                this.output += `${spaces}${spriteRef}.setX(${this.formatArg(block.args[0])});\n`;
                break;
            case "setY":
                this.output += `${spaces}${spriteRef}.setY(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeX":
                this.output += `${spaces}${spriteRef}.changeX(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeY":
                this.output += `${spaces}${spriteRef}.changeY(${this.formatArg(block.args[0])});\n`;
                break;
            case "pointInDirection":
                this.output += `${spaces}${spriteRef}.pointInDirection(${this.formatArg(block.args[0])});\n`;
                break;
            case "pointTowards":
                this.output += `${spaces}${spriteRef}.pointTowards(${this.formatArg(block.args[0])});\n`;
                break;
            case "ifOnEdgeBounce":
                this.output += `${spaces}${spriteRef}.ifOnEdgeBounce();\n`;
                break;
            case "setRotationStyle":
                this.output += `${spaces}${spriteRef}.setRotationStyle(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Motion block: ${block.name}\n`;
        }
    }

    private generateLooksBlock(block: BlockNode, indent: number, spriteRef: string, spriteName: string, isStage: boolean): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "say":
            case "sayFor":
                if (!isStage) {
                    if (block.args.length > 1 && typeof block.args[1] === "number") {
                        this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                        this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[1])});\n`;
                    } else {
                        this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])});\n`;
                    }
                }
                break;
            case "think":
            case "thinkFor":
                if (!isStage) {
                    if (block.args.length > 1 && typeof block.args[1] === "number") {
                        this.output += `${spaces}${spriteRef}.think(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                        this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[1])});\n`;
                    } else {
                        this.output += `${spaces}${spriteRef}.think(${this.formatArg(block.args[0])});\n`;
                    }
                }
                break;
            case "show":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.show();\n`;
                }
                break;
            case "hide":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.hide();\n`;
                }
                break;
            case "switchCostume":
            case "switch":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.switchCostume(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "nextCostume":
            case "next":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.nextCostume();\n`;
                }
                break;
            case "switchBackdrop":
                this.output += `${spaces}scratchRuntime.switchBackdrop(${this.formatArg(block.args[0])});\n`;
                break;
            case "nextBackdrop":
                this.output += `${spaces}scratchRuntime.nextBackdrop();\n`;
                break;
            case "changeEffect":
            case "change":
                if (!isStage && block.args.length >= 2) {
                    this.output += `${spaces}${spriteRef}.changeEffect(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                }
                break;
            case "setEffect":
            case "set":
                if (!isStage && block.args.length >= 2) {
                    this.output += `${spaces}${spriteRef}.setEffect(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                }
                break;
            case "clearEffects":
            case "clear":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.clearEffects();\n`;
                }
                break;
            case "changeSize":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.changeSize(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "setSize":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.setSize(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goToFrontLayer":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goToFrontLayer();\n`;
                }
                break;
            case "goToBackLayer":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goToBackLayer();\n`;
                }
                break;
            case "goForwardLayers":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goForwardLayers(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goBackwardLayers":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goBackwardLayers(${this.formatArg(block.args[0])});\n`;
                }
                break;
            default:
                this.output += `${spaces}// Looks block: ${block.name}\n`;
        }
    }

    private generateSoundBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "playSound":
            case "play":
                this.output += `${spaces}scratchRuntime.playSound(${this.formatArg(block.args[0])});\n`;
                break;
            case "playSoundUntilDone":
                this.output += `${spaces}await scratchRuntime.playSoundUntilDone(${this.formatArg(block.args[0])});\n`;
                break;
            case "startSound":
                this.output += `${spaces}scratchRuntime.playSound(${this.formatArg(block.args[0])});\n`;
                break;
            case "stopAllSounds":
            case "stop":
                if (block.args[0] === "all" || block.args[0] === "sounds") {
                    this.output += `${spaces}scratchRuntime.stopAllSounds();\n`;
                }
                break;
            case "changeVolume":
                this.output += `${spaces}scratchRuntime.changeVolume(${this.formatArg(block.args[0])});\n`;
                break;
            case "setVolume":
                this.output += `${spaces}scratchRuntime.setVolume(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Sound block: ${block.name}\n`;
        }
    }

    private generateControlBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): boolean {
        const spaces = "    ".repeat(indent);
        // Note: spriteRef could be used for clone-specific behavior
        // const spriteRef = isStage ? `null` : `scratchRuntime.sprites["${spriteName}"]`;
        
        // Track if we consumed block.next as a loop/conditional body
        let consumedNext = false;
        
        switch (block.name) {
            case "wait":
                this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[0])});\n`;
                break;
            case "repeat": {
                this.output += `${spaces}for (let _i = 0; _i < ${this.formatArg(block.args[0])}; _i++) {\n`;
                // Handle body from args[1], block.body, or block.next (parser may attach body to next)
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlock(block.args[1] as BlockNode, indent + 1, spriteName, isStage);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next - generate the entire chain inside the loop
                    this.generateBlock(block.next, indent + 1, spriteName, isStage);
                    consumedNext = true;
                }
                this.output += `${spaces}}\n`;
                break;
            }
            case "forever": {
                this.output += `${spaces}(async function _forever() {\n`;
                this.output += `${spaces}    while (scratchRuntime.running) {\n`;
                if (block.args.length > 0 && typeof block.args[0] === "object") {
                    this.generateBlock(block.args[0] as BlockNode, indent + 2, spriteName, isStage);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 2, spriteName, isStage);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next
                    this.generateBlock(block.next, indent + 2, spriteName, isStage);
                    consumedNext = true;
                }
                this.output += `${spaces}        await scratchRuntime.wait(0.01);\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}})();\n`;
                break;
            }
            case "if": {
                this.output += `${spaces}if (${this.formatCondition(block.args[0])}) {\n`;
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlock(block.args[1] as BlockNode, indent + 1, spriteName, isStage);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next
                    this.generateBlock(block.next, indent + 1, spriteName, isStage);
                    consumedNext = true;
                }
                this.output += `${spaces}}\n`;
                break;
            }
            case "ifElse":
                this.output += `${spaces}if (${this.formatCondition(block.args[0])}) {\n`;
                if (block.body) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage);
                    }
                }
                this.output += `${spaces}} else {\n`;
                if (block.elseBody) {
                    for (const child of block.elseBody) {
                        this.generateBlock(child, indent + 1, spriteName, isStage);
                    }
                }
                this.output += `${spaces}}\n`;
                break;
            case "waitUntil":
                this.output += `${spaces}while (!(${this.formatCondition(block.args[0])})) {\n`;
                this.output += `${spaces}    await scratchRuntime.wait(0.05);\n`;
                this.output += `${spaces}}\n`;
                break;
            case "repeatUntil": {
                this.output += `${spaces}while (!(${this.formatCondition(block.args[0])})) {\n`;
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlock(block.args[1] as BlockNode, indent + 1, spriteName, isStage);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage);
                    }
                } else if (block.next) {
                    this.generateBlock(block.next, indent + 1, spriteName, isStage);
                    consumedNext = true;
                }
                this.output += `${spaces}    await scratchRuntime.wait(0.01);\n`;
                this.output += `${spaces}}\n`;
                break;
            }
            case "stop":
                const stopTarget = block.args[0];
                if (stopTarget === "all") {
                    this.output += `${spaces}scratchRuntime.stopAll(); return;\n`;
                } else if (stopTarget === "thisScript" || stopTarget === "this") {
                    this.output += `${spaces}return;\n`;
                } else {
                    this.output += `${spaces}// Stop other scripts in sprite\n`;
                }
                break;
            case "createClone":
            case "create": {
                const cloneTarget = block.args[0] === "myself" ? `"${spriteName}"` : this.formatArg(block.args[0]);
                this.output += `${spaces}scratchRuntime.createClone(${cloneTarget});\n`;
                break;
            }
            case "deleteThisClone":
            case "deleteClone":
            case "delete":
                if (!isStage) {
                    this.output += `${spaces}scratchRuntime.deleteClone(CURRENT_SPRITE); return;\n`;
                }
                break;
            default:
                this.output += `${spaces}// Control block: ${block.name}\n`;
        }
        
        return consumedNext;
    }

    private generateSensingBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): void {
        const spaces = "    ".repeat(indent);
        const spriteRef = isStage ? `null` : `scratchRuntime.sprites["${spriteName}"]`;
        
        switch (block.name) {
            case "ask":
            case "askAndWait":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])});\n`;
                }
                this.output += `${spaces}await scratchRuntime.ask(${this.formatArg(block.args[0])});\n`;
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.say('');\n`;
                }
                break;
            case "resetTimer":
            case "reset":
                this.output += `${spaces}scratchRuntime.resetTimer();\n`;
                break;
            case "setDragMode":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.draggable = (${this.formatArg(block.args[0])} === 'draggable');\n`;
                }
                break;
            default:
                this.output += `${spaces}// Sensing block: ${block.name}\n`;
        }
    }

    private generateVariableBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        const varName = String(block.args[0]);
        
        switch (block.name) {
            case "set":
            case "setVariable":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] = ${this.formatArg(block.args[1])};\n`;
                break;
            case "change":
            case "changeVariable":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] = Number(scratchRuntime.variables["${varName}"]) + Number(${this.formatArg(block.args[1])});\n`;
                break;
            case "showVariable":
                this.output += `${spaces}// Show variable: ${varName}\n`;
                break;
            case "hideVariable":
                this.output += `${spaces}// Hide variable: ${varName}\n`;
                break;
            default:
                this.output += `${spaces}// Variable block: ${block.name}\n`;
        }
    }

    private generateListBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        const listName = String(block.args[0]);
        
        switch (block.name) {
            case "add":
            case "addToList":
                this.output += `${spaces}scratchRuntime.addToList("${listName}", ${this.formatArg(block.args[1])});\n`;
                break;
            case "delete":
            case "deleteOfList":
                this.output += `${spaces}scratchRuntime.deleteOfList("${listName}", ${this.formatArg(block.args[1])});\n`;
                break;
            case "deleteAllOfList":
                this.output += `${spaces}scratchRuntime.lists["${listName}"] = [];\n`;
                break;
            case "insert":
            case "insertAtList":
                this.output += `${spaces}scratchRuntime.insertAtList("${listName}", ${this.formatArg(block.args[1])}, ${this.formatArg(block.args[2])});\n`;
                break;
            case "replace":
            case "replaceItemOfList":
                this.output += `${spaces}scratchRuntime.replaceItemOfList("${listName}", ${this.formatArg(block.args[1])}, ${this.formatArg(block.args[2])});\n`;
                break;
            case "showList":
                this.output += `${spaces}// Show list: ${listName}\n`;
                break;
            case "hideList":
                this.output += `${spaces}// Hide list: ${listName}\n`;
                break;
            default:
                this.output += `${spaces}// List block: ${block.name}\n`;
        }
    }

    private generateProcedureBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): void {
        const spaces = "    ".repeat(indent);
        
        if (block.name === "define") {
            const procName = String(block.args[0]);
            const params = block.args.slice(1).map(a => String(a)).join(", ");
            this.output += `${spaces}scratchRuntime.procedures["${procName}"] = async function(${params}) {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.body) {
                for (const child of block.body) {
                    this.generateBlock(child, indent + 1, spriteName, isStage);
                }
            }
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}};\n`;
        } else if (block.name === "call") {
            const procName = String(block.args[0]);
            const args = block.args.slice(1).map(a => this.formatArg(a)).join(", ");
            this.output += `${spaces}await scratchRuntime.procedures["${procName}"](${args});\n`;
        }
    }

    private generatePenBlock(block: BlockNode, indent: number, spriteRef: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "penDown":
            case "pen":
                if (block.args[0] === "down") {
                    this.output += `${spaces}${spriteRef}.penDown && ${spriteRef}.penDown();\n`;
                } else if (block.args[0] === "up") {
                    this.output += `${spaces}${spriteRef}.penUp && ${spriteRef}.penUp();\n`;
                }
                break;
            case "penUp":
                this.output += `${spaces}${spriteRef}.penUp && ${spriteRef}.penUp();\n`;
                break;
            case "eraseAll":
            case "erase":
                this.output += `${spaces}// Erase all pen marks\n`;
                this.output += `${spaces}const canvas = document.getElementById('pen-canvas');\n`;
                this.output += `${spaces}if (canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n`;
                break;
            case "stamp":
                this.output += `${spaces}${spriteRef}.stamp && ${spriteRef}.stamp();\n`;
                break;
            case "setPenColor":
                this.output += `${spaces}${spriteRef}.setPenColor && ${spriteRef}.setPenColor(${this.formatArg(block.args[0])});\n`;
                break;
            case "setPenSize":
                this.output += `${spaces}${spriteRef}.setPenSize && ${spriteRef}.setPenSize(${this.formatArg(block.args[0])});\n`;
                break;
            case "changePenSize":
                this.output += `${spaces}${spriteRef}.changePenSize && ${spriteRef}.changePenSize(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Pen block: ${block.name}\n`;
        }
    }

    private formatArg(arg: unknown): string {
        if (typeof arg === "string") {
            // Check if it's a variable reference
            if (arg.startsWith("var:") || arg.startsWith("$")) {
                const varName = arg.startsWith("var:") ? arg.slice(4) : arg.slice(1);
                return `scratchRuntime.variables["${varName}"]`;
            }
            // Check if it's a list reference
            if (arg.startsWith("list:") || arg.startsWith("#")) {
                const listName = arg.startsWith("list:") ? arg.slice(5) : arg.slice(1);
                return `scratchRuntime.lists["${listName}"]`;
            }
            return `"${arg}"`;
        } else if (typeof arg === "number") {
            return String(arg);
        } else if (typeof arg === "boolean") {
            return String(arg);
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // Handle nested blocks/expressions
            const block = arg as BlockNode;
            return this.formatExpression(block);
        }
        return JSON.stringify(arg);
    }

    private formatExpression(block: BlockNode): string {
        switch (block.type) {
            case "operator":
            case "operators":
                return this.formatOperator(block);
            case "sensing":
                return this.formatSensingReporter(block);
            case "motion":
                return this.formatMotionReporter(block);
            case "looks":
                return this.formatLooksReporter(block);
            case "variable":
            case "variables":
                return `scratchRuntime.variables["${block.args[0]}"]`;
            case "list":
                return this.formatListReporter(block);
        }
        return JSON.stringify(block);
    }

    private formatOperator(block: BlockNode): string {
        switch (block.name) {
            case "add":
                return `(Number(${this.formatArg(block.args[0])}) + Number(${this.formatArg(block.args[1])}))`;
            case "subtract":
                return `(Number(${this.formatArg(block.args[0])}) - Number(${this.formatArg(block.args[1])}))`;
            case "multiply":
                return `(Number(${this.formatArg(block.args[0])}) * Number(${this.formatArg(block.args[1])}))`;
            case "divide":
                return `(Number(${this.formatArg(block.args[0])}) / Number(${this.formatArg(block.args[1])}))`;
            case "mod":
                return `(Number(${this.formatArg(block.args[0])}) % Number(${this.formatArg(block.args[1])}))`;
            case "random":
            case "pickRandom":
                return `scratchRuntime.pickRandom(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])})`;
            case "greaterThan":
            case "greater":
                return `(Number(${this.formatArg(block.args[0])}) > Number(${this.formatArg(block.args[1])}))`;
            case "lessThan":
            case "less":
                return `(Number(${this.formatArg(block.args[0])}) < Number(${this.formatArg(block.args[1])}))`;
            case "equals":
                return `(${this.formatArg(block.args[0])} == ${this.formatArg(block.args[1])})`;
            case "and":
                return `(${this.formatCondition(block.args[0])} && ${this.formatCondition(block.args[1])})`;
            case "or":
                return `(${this.formatCondition(block.args[0])} || ${this.formatCondition(block.args[1])})`;
            case "not":
                return `!(${this.formatCondition(block.args[0])})`;
            case "join":
                return `(String(${this.formatArg(block.args[0])}) + String(${this.formatArg(block.args[1])}))`;
            case "letterOf":
            case "letter":
                return `String(${this.formatArg(block.args[1])}).charAt(${this.formatArg(block.args[0])} - 1)`;
            case "length":
            case "lengthOf":
                return `String(${this.formatArg(block.args[0])}).length`;
            case "contains":
                return `String(${this.formatArg(block.args[0])}).includes(String(${this.formatArg(block.args[1])}))`;
            case "round":
                return `Math.round(Number(${this.formatArg(block.args[0])}))`;
            case "abs":
                return `Math.abs(Number(${this.formatArg(block.args[0])}))`;
            case "floor":
                return `Math.floor(Number(${this.formatArg(block.args[0])}))`;
            case "ceiling":
                return `Math.ceil(Number(${this.formatArg(block.args[0])}))`;
            case "sqrt":
                return `Math.sqrt(Number(${this.formatArg(block.args[0])}))`;
            case "sin":
                return `Math.sin(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "cos":
                return `Math.cos(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "tan":
                return `Math.tan(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "asin":
                return `(Math.asin(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "acos":
                return `(Math.acos(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "atan":
                return `(Math.atan(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "ln":
                return `Math.log(Number(${this.formatArg(block.args[0])}))`;
            case "log":
                return `Math.log10(Number(${this.formatArg(block.args[0])}))`;
            case "ePow":
            case "e^":
                return `Math.exp(Number(${this.formatArg(block.args[0])}))`;
            case "tenPow":
            case "10^":
                return `Math.pow(10, Number(${this.formatArg(block.args[0])}))`;
        }
        return "null";
    }

    private formatSensingReporter(block: BlockNode): string {
        switch (block.name) {
            case "answer":
                return `scratchRuntime.answer`;
            case "mouseX":
                return `scratchRuntime.mouse.x`;
            case "mouseY":
                return `scratchRuntime.mouse.y`;
            case "mouseDown":
                return `scratchRuntime.mouse.down`;
            case "keyPressed":
            case "key":
                return `scratchRuntime.isKeyPressed(${this.formatArg(block.args[0])})`;
            case "touching":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].isTouching(${this.formatArg(block.args[0])})`;
            case "distanceTo":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].distanceTo(${this.formatArg(block.args[0])})`;
            case "timer":
                return `scratchRuntime.getTimer()`;
            case "loudness":
                return `0`; // Placeholder
            case "username":
                return `scratchRuntime.getUsername()`;
            case "current":
                const dateOption = block.args[0];
                if (dateOption === "year") return `new Date().getFullYear()`;
                if (dateOption === "month") return `(new Date().getMonth() + 1)`;
                if (dateOption === "date") return `new Date().getDate()`;
                if (dateOption === "dayofweek") return `(new Date().getDay() + 1)`;
                if (dateOption === "hour") return `new Date().getHours()`;
                if (dateOption === "minute") return `new Date().getMinutes()`;
                if (dateOption === "second") return `new Date().getSeconds()`;
                return `0`;
            case "daysSince2000":
                return `Math.floor((Date.now() - new Date(2000, 0, 1).getTime()) / 86400000)`;
        }
        return "null";
    }

    private formatMotionReporter(block: BlockNode): string {
        switch (block.name) {
            case "xPosition":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].x`;
            case "yPosition":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].y`;
            case "direction":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].direction`;
        }
        return "0";
    }

    private formatLooksReporter(block: BlockNode): string {
        switch (block.name) {
            case "costumeNumber":
                return `(scratchRuntime.sprites[scratchRuntime.currentSprite].currentCostume + 1)`;
            case "costumeName":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].costumes[scratchRuntime.sprites[scratchRuntime.currentSprite].currentCostume]`;
            case "backdropNumber":
                return `(scratchRuntime.stage.currentBackdrop + 1)`;
            case "backdropName":
                return `scratchRuntime.stage.backdrops[scratchRuntime.stage.currentBackdrop]`;
            case "size":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].size`;
        }
        return "0";
    }

    private formatListReporter(block: BlockNode): string {
        const listName = String(block.args[0]);
        switch (block.name) {
            case "itemOfList":
                return `scratchRuntime.itemOfList("${listName}", ${this.formatArg(block.args[1])})`;
            case "itemNumberInList":
                return `scratchRuntime.itemNumberInList("${listName}", ${this.formatArg(block.args[1])})`;
            case "lengthOfList":
                return `scratchRuntime.lengthOfList("${listName}")`;
            case "listContains":
                return `scratchRuntime.listContains("${listName}", ${this.formatArg(block.args[1])})`;
        }
        return "[]";
    }

    private formatCondition(condition: unknown): string {
        if (typeof condition === "object" && condition !== null && "type" in condition) {
            return this.formatExpression(condition as BlockNode);
        }
        if (typeof condition === "boolean") {
            return String(condition);
        }
        return String(condition);
    }
}
