// Enhanced CodeGenerator: Convert AST to JavaScript code
// This class converts an Abstract Syntax Tree (AST) generated by the Parser
// into executable JavaScript code with a Scratch-like runtime environment.

import { Program, BlockNode } from "@/types/compilerTypes";
import { SCRATCH_RUNTIME, generateHTMLTemplate } from "@/templates";

/**
 * MultiSpriteCodeGenerator: Generates code for multiple sprites
 * Each sprite gets its own initialization and script code
 * Supports all Scratch 3.0 block categories
 */
export class MultiSpriteCodeGenerator {
    private sprites: { 
        name: string; 
        program: Program; 
        isStage?: boolean;
        costumeNames?: string[];
        costumeUrls?: string[];
        currentCostume?: number;
        soundNames?: string[];
        soundUrls?: string[];
    }[];
    private output: string = "";
    private userCode: string = "";
    private htmlOutput: string = "";
    private procedures: Map<string, string[]> = new Map();
    private currentProcedureParams: Set<string> = new Set(); // Track parameters in current procedure scope

    constructor(sprites: { 
        name: string; 
        program: Program; 
        isStage?: boolean;
        costumeNames?: string[];
        costumeUrls?: string[];
        currentCostume?: number;
        soundNames?: string[];
        soundUrls?: string[];
    }[]) {
        this.sprites = sprites;
    }

    /**
     * Helper method to strip $ or # prefix from variable/list names
     */
    private stripVarPrefix(name: string): string {
        if (name.startsWith("$") || name.startsWith("#")) {
            return name.substring(1);
        }
        return name;
    }

    generate(): { js: string; html: string; userCode: string } {
        // Add runtime support code
        this.output = SCRATCH_RUNTIME;

        // Mark the start of user code
        const userCodeStart = this.output.length;

        // Collect all procedures from all sprites
        this.collectAllProcedures();

        // Generate variables (global scope)
        this.generateGlobalVariables();

        // Generate lists (global scope)
        this.generateGlobalLists();

        // Initialize all sprites
        this.generateSpriteInitializations();

        // Generate custom procedures
        this.generateProcedures();

        // Generate code for each sprite's scripts
        this.generateSpriteScripts();

        // Extract just the user code (everything after the runtime)
        this.userCode = this.output.substring(userCodeStart);

        // Generate HTML
        this.htmlOutput = generateHTMLTemplate(this.output);

        return {
            js: this.output,
            html: this.htmlOutput,
            userCode: this.userCode,
        };
    }

    private collectAllProcedures(): void {
        for (const sprite of this.sprites) {
            for (const script of sprite.program.scripts) {
                for (const block of script.blocks) {
                    this.findProcedures(block);
                }
            }
        }
    }

    private findProcedures(block: BlockNode): void {
        if ((block.type === "procedure" || block.type === "custom") && block.name === "define") {
            const procName = String(block.args[0]);
            const params = block.args.slice(1).map((a) => String(a));
            this.procedures.set(procName, params);
        }
        if (block.body) {
            for (const child of block.body) {
                this.findProcedures(child);
            }
        }
        if (block.next) {
            this.findProcedures(block.next);
        }
    }

    private generateGlobalVariables(): void {
        this.output += `// Variables\n`;
        const allVars = new Map<string, unknown>();
        for (const sprite of this.sprites) {
            sprite.program.variables.forEach((value, name) => {
                allVars.set(name, value);
            });
        }
        if (allVars.size > 0) {
            allVars.forEach((value, name) => {
                // Strip $ prefix from variable name
                const cleanName = this.stripVarPrefix(name);
                if (typeof value === "number") {
                    this.output += `scratchRuntime.variables["${cleanName}"] = ${value};\n`;
                    this.output += `scratchRuntime.initialVariables["${cleanName}"] = ${value};\n`;
                } else if (typeof value === "string") {
                    this.output += `scratchRuntime.variables["${cleanName}"] = "${value}";\n`;
                    this.output += `scratchRuntime.initialVariables["${cleanName}"] = "${value}";\n`;
                } else {
                    this.output += `scratchRuntime.variables["${cleanName}"] = ${JSON.stringify(value)};\n`;
                    this.output += `scratchRuntime.initialVariables["${cleanName}"] = ${JSON.stringify(value)};\n`;
                }
            });
        } else {
            this.output += `// No variables defined\n`;
        }
        this.output += `\n`;
    }

    private generateGlobalLists(): void {
        this.output += `// Lists\n`;
        const allLists = new Map<string, unknown[]>();
        for (const sprite of this.sprites) {
            sprite.program.lists.forEach((value, name) => {
                allLists.set(name, value);
            });
        }
        if (allLists.size > 0) {
            allLists.forEach((value, name) => {
                this.output += `scratchRuntime.lists["${name}"] = ${JSON.stringify(value)};\n`;
                this.output += `scratchRuntime.initialLists["${name}"] = ${JSON.stringify(value)};\n`;
            });
        } else {
            this.output += `// No lists defined\n`;
        }
        this.output += `\n`;
    }

    private generateSpriteInitializations(): void {
        this.output += `// Initialize Sprites\n`;
        
        // Remove default Sprite1 if it's not in our sprite list
        const spriteNames = this.sprites.map(s => s.name);
        if (!spriteNames.includes("Sprite1")) {
            this.output += `delete scratchRuntime.sprites["Sprite1"];\n`;
        }

        for (let i = 0; i < this.sprites.length; i++) {
            const sprite = this.sprites[i];
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            
            // Skip backdrop/stage visual initialization (it's the background)
            if (sprite.isStage) {
                this.output += `// Stage (backdrop) initialized - no visual sprite element\n`;
                continue;
            }
            
            // Get costume names and URLs
            const costumeNames = sprite.costumeNames || ['costume1'];
            const costumeUrls = sprite.costumeUrls || [];
            const currentCostume = sprite.currentCostume || 0;
            
            // Get sound names and URLs
            const soundNames = sprite.soundNames || [];
            const soundUrls = sprite.soundUrls || [];
            
            // Initialize the sprite with options
            const xOffset = (i - Math.floor(this.sprites.length / 2)) * 50;
            this.output += `scratchRuntime.initSprite("${safeName}", {\n`;
            this.output += `    x: ${xOffset},\n`;
            this.output += `    y: 0,\n`;
            this.output += `    direction: 90,\n`;
            this.output += `    visible: true,\n`;
            this.output += `    size: 100,\n`;
            this.output += `    rotationStyle: 'all around',\n`;
            this.output += `    costumes: ${JSON.stringify(costumeNames)},\n`;
            this.output += `    costumeUrls: ${JSON.stringify(costumeUrls)},\n`;
            this.output += `    currentCostume: ${currentCostume},\n`;
            this.output += `    sounds: ${JSON.stringify(soundNames)},\n`;
            this.output += `    soundUrls: ${JSON.stringify(soundUrls)}\n`;
            this.output += `});\n`;
        }
        
        this.output += `\n`;
    }

    private generateProcedures(): void {
        this.output += `// Custom Procedures\n`;
        if (this.procedures.size === 0) {
            this.output += `// No procedures defined\n`;
        } else {
            this.procedures.forEach((params, name) => {
                const paramList = params.join(", ");
                this.output += `scratchRuntime.procedures["${name}"] = async function(${paramList}) {\n`;
                this.output += `    // Procedure body will be filled by scripts\n`;
                this.output += `};\n`;
            });
        }
        this.output += `\n`;
    }

    private generateSpriteScripts(): void {
        this.output += `// Scripts\n`;
        
        for (const sprite of this.sprites) {
            const safeName = sprite.name.replace(/[^a-zA-Z0-9_]/g, "_");
            const isStage = sprite.isStage || false;
            this.output += `// === ${sprite.name} Scripts ===\n`;
            this.output += `(function() {\n`;
            this.output += `    const CURRENT_SPRITE = "${safeName}";\n`;
            this.output += `    const IS_STAGE = ${isStage};\n`;
            if (!isStage) {
                this.output += `    const sprite = scratchRuntime.sprites[CURRENT_SPRITE];\n`;
            }
            this.output += `\n`;
            
            // Generate each script
            for (let i = 0; i < sprite.program.scripts.length; i++) {
                const script = sprite.program.scripts[i];
                this.output += `    // Script ${i + 1}\n`;
                
                for (const block of script.blocks) {
                    this.generateBlock(block, 1, safeName, isStage);
                }
            }
            
            this.output += `})();\n\n`;
        }
    }

    private generateBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean = false, inCloneContext: boolean = false): void {
        const spaces = "    ".repeat(indent);
        // In clone context, use dynamic sprite reference since currentSprite is set by createClone
        const spriteRef = isStage ? `null` : 
            (inCloneContext ? `scratchRuntime.sprites[scratchRuntime.currentSprite]` : `scratchRuntime.sprites["${spriteName}"]`);
        
        // Track if the block handler consumed block.next internally
        let nextHandled = false;

        switch (block.type) {
            case "event":
                nextHandled = this.generateEventBlock(block, indent, spriteName, isStage);
                break;
            case "motion":
                if (!isStage) {
                    this.generateMotionBlock(block, indent, spriteRef, spriteName, inCloneContext);
                }
                break;
            case "looks":
                this.generateLooksBlock(block, indent, spriteRef, spriteName, isStage, inCloneContext);
                break;
            case "control":
                nextHandled = this.generateControlBlock(block, indent, spriteName, isStage, inCloneContext);
                break;
            case "sound":
                this.generateSoundBlock(block, indent);
                break;
            case "sensing":
                this.generateSensingBlock(block, indent, spriteName, isStage, inCloneContext);
                break;
            case "operators":
            case "operator":
                // Operators are usually inline expressions, handled by formatArg
                break;
            case "variables":
            case "variable":
                this.generateVariableBlock(block, indent);
                break;
            case "list":
                this.generateListBlock(block, indent);
                break;
            case "procedure":
            case "custom":
                this.generateProcedureBlock(block, indent, spriteName, isStage);
                break;
            case "pen":
                if (!isStage) {
                    this.generatePenBlock(block, indent, spriteRef);
                }
                break;
            default:
                this.output += `${spaces}// Unknown block type: ${block.type}, name: ${block.name}\n`;
        }

        // Only process block.next if the handler didn't already consume it
        if (block.next && !nextHandled) {
            this.generateBlock(block.next, indent, spriteName, isStage, inCloneContext);
        }
    }

    private generateEventBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): boolean {
        const spaces = "    ".repeat(indent);

        // Mark that we handled the event to prevent block.next from being generated twice
        let eventHandled = false;
        
        if (block.name === "whenFlagClicked" || 
            (block.name === "when" && block.args[0] === "flagClicked") ||
            (block.name === "when" && block.args[0] === "green" && block.args[1] === "flag")) {
            this.output += `${spaces}// When green flag clicked\n`;
            this.output += `${spaces}scratchRuntime.onGreenFlag(async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "whenKeyPressed" ||
            (block.name === "when" && (String(block.args[0]) === "keyPressed" || String(block.args[0]).includes("keyPressed")))) {
            // Handle "when keyPressed space" where args are ["keyPressed", "space"]
            // or "when keyPressed_space" where args are ["keyPressed_space"]
            let key = "";
            if (block.name === "whenKeyPressed") {
                key = String(block.args[0]).replace(/"/g, "").toLowerCase();
            } else if (block.args.length > 1 && typeof block.args[1] === "string") {
                key = String(block.args[1]).toLowerCase();
            } else {
                key = String(block.args[0]).replace("keyPressed", "").replace("_", "").toLowerCase();
            }
            // Map common key names to browser event key names
            if (key === "up" || key === "arrowup" || key === "up arrow") key = "arrowup";
            else if (key === "down" || key === "arrowdown" || key === "down arrow") key = "arrowdown";
            else if (key === "left" || key === "arrowleft" || key === "left arrow") key = "arrowleft";
            else if (key === "right" || key === "arrowright" || key === "right arrow") key = "arrowright";
            else if (key === "space" || key === " ") key = " ";
            
            this.output += `${spaces}// When ${key} key pressed\n`;
            this.output += `${spaces}scratchRuntime.onEvent("keyPressed_${key}", async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "whenSpriteClicked" ||
            (block.name === "when" && String(block.args[0]) === "thisSprite" && String(block.args[1]) === "clicked") ||
            (block.name === "when" && String(block.args[0]) === "this" && String(block.args[1]) === "sprite") ||
            (block.name === "when" && block.args[0] === "spriteClicked")) {
            this.output += `${spaces}// When this sprite clicked\n`;
            this.output += `${spaces}scratchRuntime.onEvent("spriteClicked_${spriteName}", async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "when" && String(block.args[0]) === "backdrop" && String(block.args[1]) === "switches") {
            const backdrop = this.formatArg(block.args[2]);
            this.output += `${spaces}// When backdrop switches to ${backdrop}\n`;
            this.output += `${spaces}scratchRuntime.onEvent("backdropSwitch_" + ${backdrop}, async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (
            // Handle multiple patterns for "when I start as a clone"
            block.name === "whenIStartAsClone" ||
            (block.name === "when" && String(block.args[0]) === "clone" && String(block.args[1]) === "starts") ||
            (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "start" && String(block.args[2]) === "as") ||
            (block.name === "when" && String(block.args[0]) === "cloneStarted") ||
            block.name === "whenCloneStarted"
        ) {
            this.output += `${spaces}// When I start as a clone\n`;
            this.output += `${spaces}scratchRuntime.onEvent("cloneStart_${spriteName}", async function() {\n`;
            // In clone context, scratchRuntime.currentSprite is set by createClone callback
            // Pass true for inCloneContext so motion blocks use dynamic sprite reference
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage, true);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (
            // Handle multiple patterns for "when I receive"
            block.name === "whenIReceive" ||
            block.name === "whenReceived" ||
            (block.name === "when" && block.args[0] === "receive") ||
            (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "receive")
        ) {
            // Find the message argument - it could be at different positions depending on parsing
            let message: string;
            if (block.name === "whenIReceive") {
                // New format: whenIReceive + [message]
                message = this.formatArg(block.args[0]);
            } else if (block.name === "when" && String(block.args[0]) === "I" && String(block.args[1]) === "receive") {
                message = this.formatArg(block.args[2]);
            } else if (block.name === "when" && block.args[0] === "receive") {
                message = this.formatArg(block.args[1]);
            } else {
                message = this.formatArg(block.args[0]);
            }
            this.output += `${spaces}// When I receive ${message}\n`;
            this.output += `${spaces}scratchRuntime.onBroadcast(${message}, async function() {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}});\n\n`;
            eventHandled = true;
        } else if (block.name === "broadcast") {
            this.output += `${spaces}scratchRuntime.broadcast(${this.formatArg(block.args[0])});\n`;
        } else if (block.name === "broadcastAndWait") {
            this.output += `${spaces}await scratchRuntime.broadcastAndWait(${this.formatArg(block.args[0])});\n`;
        }
        
        // Return whether this was an event that handled its own block.next
        return eventHandled;
    }

    private generateMotionBlock(block: BlockNode, indent: number, spriteRef: string, _spriteName: string, _inCloneContext: boolean = false): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "move":
                this.output += `${spaces}${spriteRef}.move(${this.formatArg(block.args[0])});\n`;
                break;
            case "turn":
            case "turnRight":
                this.output += `${spaces}${spriteRef}.turnRight(${this.formatArg(block.args[0])});\n`;
                break;
            case "turnLeft":
                this.output += `${spaces}${spriteRef}.turnLeft(${this.formatArg(block.args[0])});\n`;
                break;
            case "goTo":
            case "goto":
                if (block.args.length === 2 && typeof block.args[0] === "number") {
                    this.output += `${spaces}${spriteRef}.goTo(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                } else {
                    this.output += `${spaces}${spriteRef}.goToTarget(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goToXY":
                this.output += `${spaces}${spriteRef}.goTo(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                break;
            case "glide":
            case "glideToXY":
                const seconds = this.formatArg(block.args[0]);
                const targetX = this.formatArg(block.args[1]);
                const targetY = this.formatArg(block.args[2]);
                this.output += `${spaces}// Glide to position\n`;
                this.output += `${spaces}await (async function() {\n`;
                this.output += `${spaces}    const startX = ${spriteRef}.x;\n`;
                this.output += `${spaces}    const startY = ${spriteRef}.y;\n`;
                this.output += `${spaces}    const duration = ${seconds} * 1000;\n`;
                this.output += `${spaces}    const startTime = Date.now();\n`;
                this.output += `${spaces}    while (Date.now() - startTime < duration) {\n`;
                this.output += `${spaces}        const progress = (Date.now() - startTime) / duration;\n`;
                this.output += `${spaces}        ${spriteRef}.goTo(startX + (${targetX} - startX) * progress, startY + (${targetY} - startY) * progress);\n`;
                this.output += `${spaces}        await scratchRuntime.wait(0.016);\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}    ${spriteRef}.goTo(${targetX}, ${targetY});\n`;
                this.output += `${spaces}})();\n`;
                break;
            case "glideTo":
                const glideSeconds = this.formatArg(block.args[0]);
                const target = this.formatArg(block.args[1]);
                this.output += `${spaces}// Glide to target\n`;
                this.output += `${spaces}await (async function() {\n`;
                this.output += `${spaces}    let targetX, targetY;\n`;
                this.output += `${spaces}    if (${target} === 'mouse-pointer') {\n`;
                this.output += `${spaces}        targetX = scratchRuntime.mouse.x; targetY = scratchRuntime.mouse.y;\n`;
                this.output += `${spaces}    } else if (${target} === 'random') {\n`;
                this.output += `${spaces}        targetX = Math.random() * scratchRuntime.stage.width - scratchRuntime.stage.width/2;\n`;
                this.output += `${spaces}        targetY = Math.random() * scratchRuntime.stage.height - scratchRuntime.stage.height/2;\n`;
                this.output += `${spaces}    } else if (scratchRuntime.sprites[${target}]) {\n`;
                this.output += `${spaces}        targetX = scratchRuntime.sprites[${target}].x; targetY = scratchRuntime.sprites[${target}].y;\n`;
                this.output += `${spaces}    } else { return; }\n`;
                this.output += `${spaces}    const startX = ${spriteRef}.x, startY = ${spriteRef}.y;\n`;
                this.output += `${spaces}    const duration = ${glideSeconds} * 1000;\n`;
                this.output += `${spaces}    const startTime = Date.now();\n`;
                this.output += `${spaces}    while (Date.now() - startTime < duration) {\n`;
                this.output += `${spaces}        const progress = (Date.now() - startTime) / duration;\n`;
                this.output += `${spaces}        ${spriteRef}.goTo(startX + (targetX - startX) * progress, startY + (targetY - startY) * progress);\n`;
                this.output += `${spaces}        await scratchRuntime.wait(0.016);\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}    ${spriteRef}.goTo(targetX, targetY);\n`;
                this.output += `${spaces}})();\n`;
                break;
            case "setX":
                this.output += `${spaces}${spriteRef}.setX(${this.formatArg(block.args[0])});\n`;
                break;
            case "setY":
                this.output += `${spaces}${spriteRef}.setY(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeX":
                this.output += `${spaces}${spriteRef}.changeX(${this.formatArg(block.args[0])});\n`;
                break;
            case "changeY":
                this.output += `${spaces}${spriteRef}.changeY(${this.formatArg(block.args[0])});\n`;
                break;
            case "point":
                // Handle "point in direction <value>" parsed as point with args ["in", "direction", value]
                if (block.args[0] === "in" && block.args[1] === "direction") {
                    this.output += `${spaces}${spriteRef}.pointInDirection(${this.formatArg(block.args[2])});\n`;
                } else if (block.args[0] === "towards") {
                    this.output += `${spaces}${spriteRef}.pointTowards(${this.formatArg(block.args[1])});\n`;
                } else {
                    this.output += `${spaces}${spriteRef}.pointInDirection(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "pointInDirection":
                this.output += `${spaces}${spriteRef}.pointInDirection(${this.formatArg(block.args[0])});\n`;
                break;
            case "pointTowards":
                this.output += `${spaces}${spriteRef}.pointTowards(${this.formatArg(block.args[0])});\n`;
                break;
            case "ifOnEdgeBounce":
                this.output += `${spaces}${spriteRef}.ifOnEdgeBounce();\n`;
                break;
            case "setRotationStyle":
                this.output += `${spaces}${spriteRef}.setRotationStyle(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Motion block: ${block.name}\n`;
        }
    }

    private generateLooksBlock(block: BlockNode, indent: number, spriteRef: string, spriteName: string, isStage: boolean, _inCloneContext: boolean = false): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "say":
            case "sayFor":
                if (!isStage) {
                    if (block.args.length > 1 && typeof block.args[1] === "number") {
                        this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                        this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[1])});\n`;
                    } else {
                        this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])});\n`;
                    }
                }
                break;
            case "think":
            case "thinkFor":
                if (!isStage) {
                    if (block.args.length > 1 && typeof block.args[1] === "number") {
                        this.output += `${spaces}${spriteRef}.think(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])});\n`;
                        this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[1])});\n`;
                    } else {
                        this.output += `${spaces}${spriteRef}.think(${this.formatArg(block.args[0])});\n`;
                    }
                }
                break;
            case "show":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.show();\n`;
                }
                break;
            case "hide":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.hide();\n`;
                }
                break;
            case "switchCostume":
            case "switch":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.switchCostume(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "nextCostume":
            case "next":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.nextCostume();\n`;
                }
                break;
            case "switchBackdrop":
                this.output += `${spaces}scratchRuntime.switchBackdrop(${this.formatArg(block.args[0])});\n`;
                break;
            case "nextBackdrop":
                this.output += `${spaces}scratchRuntime.nextBackdrop();\n`;
                break;
            case "changeEffect":
            case "change":
                if (block.args.length >= 2) {
                    // Check if this is a variable change, motion change, or effect change
                    // Effect names are: color, fisheye, whirl, pixelate, mosaic, brightness, ghost
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    
                    // Try to find effect name - could be in args[0] or as a keyword before "effect"
                    let effectName = "";
                    let valueArg: unknown = null;
                    
                    // Check if "effect" keyword is in args - indicates pattern like "[color] effect by 20"
                    const effectIndex = block.args.findIndex(a => a === "effect");
                    if (effectIndex >= 0) {
                        // Look for effect name before "effect" keyword or in the list block
                        for (let i = effectIndex - 1; i >= 0; i--) {
                            const arg = block.args[i];
                            const argName = this.extractName(arg);
                            if (effectNames.includes(argName.toLowerCase())) {
                                effectName = argName;
                                break;
                            }
                        }
                        // Value is after "effect", skip "by" keyword
                        const byIndex = block.args.findIndex(a => a === "by");
                        if (byIndex >= 0 && byIndex + 1 < block.args.length) {
                            valueArg = block.args[byIndex + 1];
                        } else if (effectIndex + 1 < block.args.length) {
                            valueArg = block.args[effectIndex + 1];
                        }
                    }
                    
                    // Fallback to original logic if effect pattern not found
                    if (!effectName) {
                        const firstArg = block.args[0];
                        effectName = this.extractName(firstArg);
                        valueArg = this.extractValueArg(block.args, 1);
                    }
                    
                    if (effectName.toLowerCase() === "x") {
                        // This is change x by
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.changeX(${this.formatArg(valueArg)});\n`;
                        }
                    } else if (effectName.toLowerCase() === "y") {
                        // This is change y by
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.changeY(${this.formatArg(valueArg)});\n`;
                        }
                    } else if (effectName.toLowerCase() === "size") {
                        // This is change size by
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.changeSize(${this.formatArg(valueArg)});\n`;
                        }
                    } else if (effectNames.includes(effectName.toLowerCase())) {
                        // This is an effect change
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.changeEffect("${effectName}", ${this.formatArg(valueArg)});\n`;
                        }
                    } else {
                        // This is a variable change
                        this.output += `${spaces}scratchRuntime.variables["${effectName}"] = Number(scratchRuntime.variables["${effectName}"]) + Number(${this.formatArg(valueArg)});\n`;
                    }
                }
                break;
            case "setEffect":
            case "set":
                if (block.args.length >= 2) {
                    // Check if this is a variable set, size set, or effect set
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    
                    // Try to find effect name - could be in args[0] or as a keyword before "effect"
                    let effectName = "";
                    let valueArg: unknown = null;
                    
                    // Check if "effect" keyword is in args
                    const effectIndex = block.args.findIndex(a => a === "effect");
                    if (effectIndex >= 0) {
                        // Look for effect name before "effect" keyword
                        for (let i = effectIndex - 1; i >= 0; i--) {
                            const arg = block.args[i];
                            const argName = this.extractName(arg);
                            if (effectNames.includes(argName.toLowerCase())) {
                                effectName = argName;
                                break;
                            }
                        }
                        // Value is after "effect", skip "to" keyword
                        const toIndex = block.args.findIndex(a => a === "to");
                        if (toIndex >= 0 && toIndex + 1 < block.args.length) {
                            valueArg = block.args[toIndex + 1];
                        } else if (effectIndex + 1 < block.args.length) {
                            valueArg = block.args[effectIndex + 1];
                        }
                    }
                    
                    // Fallback to original logic
                    if (!effectName) {
                        const firstArg = block.args[0];
                        effectName = this.extractName(firstArg);
                        valueArg = this.extractValueArg(block.args, 1);
                    }
                    
                    if (effectNames.includes(effectName.toLowerCase())) {
                        // This is an effect set
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.setEffect("${effectName}", ${this.formatArg(valueArg)});\n`;
                        }
                    } else if (effectName.toLowerCase() === "size") {
                        // This is set size - find the value (skip "to" and "%")
                        const toIdx = block.args.findIndex(a => a === "to");
                        let sizeValue = valueArg;
                        if (toIdx >= 0 && toIdx + 1 < block.args.length) {
                            sizeValue = block.args[toIdx + 1];
                        }
                        if (!isStage) {
                            this.output += `${spaces}${spriteRef}.setSize(${this.formatArg(sizeValue)});\n`;
                        }
                    } else {
                        // This is a variable set
                        this.output += `${spaces}scratchRuntime.variables["${effectName}"] = ${this.formatArg(valueArg)};\n`;
                    }
                }
                break;
            case "clearEffects":
            case "clear":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.clearEffects();\n`;
                }
                break;
            case "changeSize":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.changeSize(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "setSize":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.setSize(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goToFrontLayer":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goToFrontLayer();\n`;
                }
                break;
            case "goToBackLayer":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goToBackLayer();\n`;
                }
                break;
            case "goForwardLayers":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goForwardLayers(${this.formatArg(block.args[0])});\n`;
                }
                break;
            case "goBackwardLayers":
            case "goBackLayers":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.goBackLayers(${this.formatArg(block.args[0])});\n`;
                }
                break;
            default:
                this.output += `${spaces}// Looks block: ${block.name}\n`;
        }
    }

    private generateSoundBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "playSound":
            case "play":
                this.output += `${spaces}scratchRuntime.playSound(${this.formatArg(block.args[0])});\n`;
                break;
            case "playSoundUntilDone":
                this.output += `${spaces}await scratchRuntime.playSoundUntilDone(${this.formatArg(block.args[0])});\n`;
                break;
            case "startSound":
                this.output += `${spaces}scratchRuntime.playSound(${this.formatArg(block.args[0])});\n`;
                break;
            case "stopAllSounds":
                this.output += `${spaces}scratchRuntime.stopAllSounds();\n`;
                break;
            case "stop":
                if (block.args[0] === "all" || block.args[0] === "sounds") {
                    this.output += `${spaces}scratchRuntime.stopAllSounds();\n`;
                }
                break;
            case "changeVolume":
                this.output += `${spaces}scratchRuntime.changeVolume(${this.formatArg(block.args[0])});\n`;
                break;
            case "setVolume":
                this.output += `${spaces}scratchRuntime.setVolume(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Sound block: ${block.name}\n`;
        }
    }

    private generateControlBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean, inCloneContext: boolean = false): boolean {
        const spaces = "    ".repeat(indent);
        // Note: spriteRef could be used for clone-specific behavior
        // const spriteRef = isStage ? `null` : `scratchRuntime.sprites["${spriteName}"]`;
        
        // Track if we consumed block.next as a loop/conditional body
        let consumedNext = false;
        
        switch (block.name) {
            case "wait":
                this.output += `${spaces}await scratchRuntime.wait(${this.formatArg(block.args[0])});\n`;
                break;
            case "repeat": {
                this.output += `${spaces}for (let _i = 0; _i < ${this.formatArg(block.args[0])} && scratchRuntime.running; _i++) {\n`;
                // Handle body from args[1], block.body, or block.next (parser may attach body to next)
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlock(block.args[1] as BlockNode, indent + 1, spriteName, isStage, inCloneContext);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage, inCloneContext);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next - generate the entire chain inside the loop
                    this.generateBlock(block.next, indent + 1, spriteName, isStage, inCloneContext);
                    consumedNext = true;
                }
                this.output += `${spaces}}\n`;
                break;
            }
            case "forever": {
                this.output += `${spaces}scratchRuntime.startForeverLoop();\n`;
                this.output += `${spaces}(async function _forever() {\n`;
                this.output += `${spaces}    try {\n`;
                this.output += `${spaces}        while (scratchRuntime.running) {\n`;
                if (block.args.length > 0 && typeof block.args[0] === "object") {
                    this.generateBlock(block.args[0] as BlockNode, indent + 3, spriteName, isStage, inCloneContext);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 3, spriteName, isStage, inCloneContext);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next
                    this.generateBlock(block.next, indent + 3, spriteName, isStage, inCloneContext);
                    consumedNext = true;
                }
                this.output += `${spaces}            await scratchRuntime.wait(0.01);\n`;
                this.output += `${spaces}        }\n`;
                this.output += `${spaces}    } finally {\n`;
                this.output += `${spaces}        scratchRuntime.endForeverLoop();\n`;
                this.output += `${spaces}    }\n`;
                this.output += `${spaces}})();\n`;
                break;
            }
            case "if": {
                // Check for special case: "if on edge, bounce" which gets parsed as if with args ["on", "edge", "bounce"] or similar
                if (block.args[0] === "on" && block.args[1] === "edge" && (block.args[2] === "bounce" || block.args.includes("bounce"))) {
                    if (!isStage) {
                        const spriteRef = inCloneContext 
                            ? `scratchRuntime.sprites[scratchRuntime.currentSprite]`
                            : `scratchRuntime.sprites["${spriteName}"]`;
                        this.output += `${spaces}${spriteRef}.ifOnEdgeBounce();\n`;
                    }
                    break;
                }
                
                // Build condition from args - handle both simple conditions and comparison expressions
                // Args might be: [{cond}] or [{expr}, "=", value, "then", {body}] or [{expr}, ">", value, "then", {body}]
                const condition = this.buildConditionFromArgs(block.args);
                const bodyBlock = this.findBodyBlockFromArgs(block.args);
                
                this.output += `${spaces}if (${condition}) {\n`;
                if (bodyBlock) {
                    this.generateBlock(bodyBlock, indent + 1, spriteName, isStage, inCloneContext);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage, inCloneContext);
                    }
                } else if (block.next) {
                    // Parser attached body to block.next
                    this.generateBlock(block.next, indent + 1, spriteName, isStage, inCloneContext);
                    consumedNext = true;
                }
                this.output += `${spaces}}\n`;
                break;
            }
            case "ifElse": {
                const condition = this.buildConditionFromArgs(block.args);
                const bodyBlock = this.findBodyBlockFromArgs(block.args);
                
                this.output += `${spaces}if (${condition}) {\n`;
                if (bodyBlock) {
                    this.generateBlock(bodyBlock, indent + 1, spriteName, isStage, inCloneContext);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage, inCloneContext);
                    }
                }
                this.output += `${spaces}} else {\n`;
                if (block.elseBody && block.elseBody.length > 0) {
                    for (const child of block.elseBody) {
                        this.generateBlock(child, indent + 1, spriteName, isStage, inCloneContext);
                    }
                }
                this.output += `${spaces}}\n`;
                break;
            }
            case "waitUntil":
                this.output += `${spaces}while (scratchRuntime.running && !(${this.buildConditionFromArgs(block.args)})) {\n`;
                this.output += `${spaces}    await scratchRuntime.wait(0.05);\n`;
                this.output += `${spaces}}\n`;
                break;
            case "repeatUntil": {
                this.output += `${spaces}while (scratchRuntime.running && !(${this.buildConditionFromArgs(block.args)})) {\n`;
                if (block.args.length > 1 && typeof block.args[1] === "object") {
                    this.generateBlock(block.args[1] as BlockNode, indent + 1, spriteName, isStage, inCloneContext);
                } else if (block.body && block.body.length > 0) {
                    for (const child of block.body) {
                        this.generateBlock(child, indent + 1, spriteName, isStage, inCloneContext);
                    }
                } else if (block.next) {
                    this.generateBlock(block.next, indent + 1, spriteName, isStage, inCloneContext);
                    consumedNext = true;
                }
                this.output += `${spaces}    await scratchRuntime.wait(0.01);\n`;
                this.output += `${spaces}}\n`;
                break;
            }
            case "stopAll":
                this.output += `${spaces}scratchRuntime.stopAll(); return;\n`;
                break;
            case "stopThisScript":
                this.output += `${spaces}return;\n`;
                break;
            case "stop":
                const stopTarget = block.args[0];
                if (stopTarget === "all") {
                    this.output += `${spaces}scratchRuntime.stopAll(); return;\n`;
                } else if (stopTarget === "thisScript" || stopTarget === "this") {
                    this.output += `${spaces}return;\n`;
                } else {
                    this.output += `${spaces}// Stop other scripts in sprite\n`;
                }
                break;
            case "createClone":
            case "create": {
                const cloneTarget = block.args[0] === "myself" ? `"${spriteName}"` : this.formatArg(block.args[0]);
                this.output += `${spaces}scratchRuntime.createClone(${cloneTarget});\n`;
                break;
            }
            case "deleteThisClone":
            case "deleteClone":
                if (!isStage) {
                    this.output += `${spaces}scratchRuntime.deleteClone(CURRENT_SPRITE); return;\n`;
                }
                break;
            case "delete":
                // Check if this is "delete all of [list]" vs "delete this clone"
                if (block.args[0] === "all" && block.args[1] === "of") {
                    // This is "delete all of [list]" - handle as list operation
                    const listName = this.extractName(block.args[2]);
                    this.output += `${spaces}scratchRuntime.lists["${listName}"] = [];\n`;
                } else if (block.args[0] === "this" || block.args[0] === "clone") {
                    // This is "delete this clone"
                    if (!isStage) {
                        this.output += `${spaces}scratchRuntime.deleteClone(CURRENT_SPRITE); return;\n`;
                    }
                } else {
                    // "delete <index> of [list]" - list deletion by index
                    const listName = this.extractName(block.args[2] || block.args[1]);
                    this.output += `${spaces}scratchRuntime.deleteOfList("${listName}", ${this.formatArg(block.args[0])});\n`;
                }
                break;
            default:
                this.output += `${spaces}// Control block: ${block.name}\n`;
        }
        
        return consumedNext;
    }

    private generateSensingBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean, inCloneContext: boolean = false): void {
        const spaces = "    ".repeat(indent);
        const spriteRef = isStage ? `null` : 
            (inCloneContext ? `scratchRuntime.sprites[scratchRuntime.currentSprite]` : `scratchRuntime.sprites["${spriteName}"]`);
        
        switch (block.name) {
            case "ask":
            case "askAndWait":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.say(${this.formatArg(block.args[0])});\n`;
                }
                this.output += `${spaces}await scratchRuntime.ask(${this.formatArg(block.args[0])});\n`;
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.say('');\n`;
                }
                break;
            case "resetTimer":
            case "reset":
                this.output += `${spaces}scratchRuntime.resetTimer();\n`;
                break;
            case "setDragMode":
                if (!isStage) {
                    this.output += `${spaces}${spriteRef}.draggable = (${this.formatArg(block.args[0])} === 'draggable');\n`;
                }
                break;
            default:
                this.output += `${spaces}// Sensing block: ${block.name}\n`;
        }
    }

    /**
     * Extract variable/list name from an argument that might be a string or a block object
     * Handles both "varName" and {type: "operators", name: "list", args: ["varName"]}
     */
    private extractName(arg: unknown): string {
        let name: string;
        if (typeof arg === "string") {
            name = arg;
        } else if (typeof arg === "object" && arg !== null && "args" in arg) {
            const block = arg as BlockNode;
            // Handle bracket notation parsed as list block: {type: "operators", name: "list", args: ["varName"]}
            if (block.name === "list" && block.args && block.args.length > 0) {
                name = String(block.args[0]);
            // Handle expression block: {type: "operators", name: "expression", args: ["varName"]}
            } else if (block.name === "expression" && block.args && block.args.length > 0) {
                name = String(block.args[0]);
            } else {
                name = String(arg);
            }
        } else {
            name = String(arg);
        }
        // Strip $ or # prefix if present (variable/list markers from parser)
        if (name.startsWith("$") || name.startsWith("#")) {
            return name.substring(1);
        }
        return name;
    }

    /**
     * Find the actual value in a "set [var] to VALUE" or "change [var] by VALUE" statement
     * The args might be: [{varBlock}, "to", value] or [{varBlock}, value] 
     */
    private extractValueArg(args: (string | number | BlockNode)[], startIndex: number = 1): unknown {
        // Skip keywords like "to", "by"
        let valueIndex = startIndex;
        for (let i = startIndex; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === "string" && (arg === "to" || arg === "by")) {
                continue;
            }
            valueIndex = i;
            break;
        }
        
        const value = args[valueIndex];
        
        // Check if there are trailing arithmetic operators after the value
        // This handles cases like: [expr, "/", 2] -> should be (expr / 2)
        const arithmeticOps = ["+", "-", "*", "/", "mod", "%"];
        if (valueIndex + 2 <= args.length) {
            const nextArg = args[valueIndex + 1];
            if (typeof nextArg === "string" && arithmeticOps.includes(nextArg)) {
                // Build an expression from the value and remaining arithmetic operations
                const exprArgs: (string | number | BlockNode)[] = [value];
                for (let i = valueIndex + 1; i < args.length; i++) {
                    const arg = args[i];
                    // Stop at non-arithmetic tokens (like "then" or body blocks)
                    if (typeof arg === "object" && arg !== null && "type" in arg) {
                        const block = arg as BlockNode;
                        if (block.type !== "operators" && block.name !== "expression") {
                            break;
                        }
                    }
                    if (typeof arg === "string" && !arithmeticOps.includes(arg) && 
                        !["$", "#"].some(p => arg.startsWith(p)) && 
                        isNaN(Number(arg))) {
                        break;
                    }
                    exprArgs.push(arg);
                }
                
                if (exprArgs.length > 1) {
                    // Return a synthetic expression block
                    return {
                        type: "operators",
                        name: "expression",
                        args: exprArgs
                    } as BlockNode;
                }
            }
        }
        
        return value;
    }

    private generateVariableBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        
        // Check if this is actually an effect block: "set [effect] effect to value"
        // Args pattern: [{list: ["ghost"]}, "effect", "to", 50]
        const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
        const firstArgName = this.extractName(block.args[0]);
        const hasEffectKeyword = block.args.includes("effect");
        
        if ((block.name === "set" || block.name === "change") && hasEffectKeyword && effectNames.includes(firstArgName)) {
            // This is an effect block, not a variable block
            // Find the value (after "to" or "by")
            const toIndex = block.args.findIndex(a => a === "to");
            const byIndex = block.args.findIndex(a => a === "by");
            const valueIndex = toIndex >= 0 ? toIndex + 1 : (byIndex >= 0 ? byIndex + 1 : block.args.length - 1);
            const value = block.args[valueIndex];
            
            if (block.name === "set") {
                this.output += `${spaces}scratchRuntime.currentSpriteObj?.setEffect("${firstArgName}", ${this.formatArg(value)});\n`;
            } else {
                this.output += `${spaces}scratchRuntime.currentSpriteObj?.changeEffect("${firstArgName}", ${this.formatArg(value)});\n`;
            }
            return;
        }
        
        // Check for "set size to X %" pattern
        // Args pattern: [{list: ["size"]}, "to", 100, "%"]
        if (block.name === "set" && firstArgName === "size") {
            const toIndex = block.args.findIndex(a => a === "to");
            if (toIndex >= 0 && toIndex + 1 < block.args.length) {
                const value = block.args[toIndex + 1];
                this.output += `${spaces}scratchRuntime.currentSpriteObj?.setSize(${this.formatArg(value)});\n`;
                return;
            }
        }
        
        const varName = firstArgName;
        const valueArg = this.extractValueArg(block.args, 1);
        
        switch (block.name) {
            case "set":
            case "setVariable":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] = ${this.formatArg(valueArg)};\n`;
                break;
            case "change":
            case "changeVariable":
                this.output += `${spaces}scratchRuntime.variables["${varName}"] = Number(scratchRuntime.variables["${varName}"]) + Number(${this.formatArg(valueArg)});\n`;
                break;
            case "showVariable":
                this.output += `${spaces}// Show variable: ${varName}\n`;
                break;
            case "hideVariable":
                this.output += `${spaces}// Hide variable: ${varName}\n`;
                break;
            default:
                this.output += `${spaces}// Variable block: ${block.name}\n`;
        }
    }

    private generateListBlock(block: BlockNode, indent: number): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "add":
            case "addToList": {
                // Handle "add (value) to [list]" - parsed as: args[0]=value, args[1]="to", args[2]=list
                // Or "add item to [list]" - args[0]=item, args[1]="to", args[2]=list
                let listName: string;
                let value: unknown;
                
                // Find the list name (look for block with name "list" or check for "to" keyword)
                const toIndex = block.args.findIndex(a => a === "to");
                if (toIndex >= 0 && toIndex + 1 < block.args.length) {
                    // List is after "to"
                    listName = this.extractName(block.args[toIndex + 1]);
                    value = block.args[0]; // Value is before "to"
                } else {
                    // Fallback to first two args
                    listName = this.extractName(block.args[0]);
                    value = block.args[1];
                }
                
                this.output += `${spaces}scratchRuntime.addToList("${listName}", ${this.formatArg(value)});\n`;
                break;
            }
            case "delete":
            case "deleteOfList": {
                const listName = this.extractName(block.args[0]);
                const valueArg = this.extractValueArg(block.args, 1);
                this.output += `${spaces}scratchRuntime.deleteOfList("${listName}", ${this.formatArg(valueArg)});\n`;
                break;
            }
            case "deleteAllOfList": {
                const listName = this.extractName(block.args[0]);
                this.output += `${spaces}scratchRuntime.lists["${listName}"] = [];\n`;
                break;
            }
            case "insert":
            case "insertAtList": {
                // Args pattern: ["value", "at", index, "of", "#listName"]
                // or: [listName, index, value] for direct format
                let listName: string;
                let index: unknown;
                let value: unknown;
                
                // Check for "at ... of" pattern
                const atIdx = block.args.indexOf("at");
                const ofIdx = block.args.indexOf("of");
                if (atIdx !== -1 && ofIdx !== -1 && ofIdx > atIdx) {
                    value = block.args[0];
                    index = block.args[atIdx + 1];
                    listName = this.extractName(block.args[ofIdx + 1]);
                } else {
                    listName = this.extractName(block.args[0]);
                    index = block.args[1];
                    value = block.args[2];
                }
                
                this.output += `${spaces}scratchRuntime.insertAtList("${listName}", ${this.formatArg(index)}, ${this.formatArg(value)});\n`;
                break;
            }
            case "replace":
            case "replaceItemOfList": {
                // Args patterns:
                // 1. [{itemOf block}, "with", value] - when parser creates itemOf block for "item X of list"
                // 2. ["item", index, "of", "#listName", "with", value] - raw tokens
                // 3. [listName, index, value] - direct format
                let listName: string;
                let index: unknown;
                let value: unknown;
                
                // Check if first arg is an itemOf block
                const firstArg = block.args[0];
                if (typeof firstArg === "object" && firstArg !== null && "name" in firstArg && (firstArg as BlockNode).name === "itemOf") {
                    const itemOfBlock = firstArg as BlockNode;
                    index = itemOfBlock.args[0];
                    listName = this.extractName(itemOfBlock.args[1]);
                    // Find value after "with"
                    const withIdx = block.args.indexOf("with");
                    value = withIdx !== -1 && withIdx + 1 < block.args.length ? block.args[withIdx + 1] : block.args[2];
                }
                // Check for "item ... of ... with" pattern
                else if (block.args.includes("of") && block.args.includes("with")) {
                    const ofIdx = block.args.indexOf("of");
                    const withIdx = block.args.indexOf("with");
                    // Pattern: "item", index, "of", listName, "with", value
                    index = block.args[1]; // index is after "item"
                    listName = this.extractName(block.args[ofIdx + 1]);
                    value = block.args[withIdx + 1];
                } else {
                    listName = this.extractName(block.args[0]);
                    index = block.args[1];
                    value = block.args[2];
                }
                
                this.output += `${spaces}scratchRuntime.replaceItemOfList("${listName}", ${this.formatArg(index)}, ${this.formatArg(value)});\n`;
                break;
            }
            case "showList":
                this.output += `${spaces}// Show list: ${this.extractName(block.args[0])}\n`;
                break;
            case "hideList":
                this.output += `${spaces}// Hide list: ${this.extractName(block.args[0])}\n`;
                break;
            default:
                this.output += `${spaces}// List block: ${block.name}\n`;
        }
    }

    private generateProcedureBlock(block: BlockNode, indent: number, spriteName: string, isStage: boolean): void {
        const spaces = "    ".repeat(indent);
        const spriteRef = isStage ? `null` : `scratchRuntime.sprites["${spriteName}"]`;
        
        // Handle "clear graphic effects" which may be parsed as custom block
        if (block.name === "clear" && block.args.includes("graphic") && block.args.includes("effects")) {
            if (!isStage) {
                this.output += `${spaces}${spriteRef}.clearEffects();\n`;
            }
            return;
        }
        
        if (block.name === "define") {
            const procName = String(block.args[0]);
            const paramNames = block.args.slice(1).map(a => String(a));
            const params = paramNames.join(", ");
            
            // Set procedure parameters in scope for formatArg to use
            this.currentProcedureParams = new Set(paramNames);
            
            this.output += `${spaces}scratchRuntime.procedures["${procName}"] = async function(${params}) {\n`;
            this.output += `${spaces}    scratchRuntime.currentSprite = "${spriteName}";\n`;
            if (block.body) {
                for (const child of block.body) {
                    this.generateBlock(child, indent + 1, spriteName, isStage);
                }
            }
            if (block.next) {
                this.generateBlock(block.next, indent + 1, spriteName, isStage);
            }
            this.output += `${spaces}};\n`;
            
            // Clear procedure parameters after exiting the procedure
            this.currentProcedureParams = new Set();
        } else if (block.name === "call") {
            const procName = String(block.args[0]);
            const args = block.args.slice(1).map(a => this.formatArg(a)).join(", ");
            this.output += `${spaces}await scratchRuntime.procedures["${procName}"](${args});\n`;
        }
    }

    private generatePenBlock(block: BlockNode, indent: number, spriteRef: string): void {
        const spaces = "    ".repeat(indent);
        
        switch (block.name) {
            case "penDown":
            case "pen":
                if (block.args[0] === "down") {
                    this.output += `${spaces}${spriteRef}.penDown && ${spriteRef}.penDown();\n`;
                } else if (block.args[0] === "up") {
                    this.output += `${spaces}${spriteRef}.penUp && ${spriteRef}.penUp();\n`;
                }
                break;
            case "penUp":
                this.output += `${spaces}${spriteRef}.penUp && ${spriteRef}.penUp();\n`;
                break;
            case "eraseAll":
            case "erase":
                this.output += `${spaces}// Erase all pen marks\n`;
                this.output += `${spaces}(function() { const c = document.getElementById('pen-canvas'); if (c) c.getContext('2d').clearRect(0, 0, c.width, c.height); })();\n`;
                break;
            case "stamp":
                this.output += `${spaces}${spriteRef}.stamp && ${spriteRef}.stamp();\n`;
                break;
            case "setPenColor":
                this.output += `${spaces}${spriteRef}.setPenColor && ${spriteRef}.setPenColor(${this.formatArg(block.args[0])});\n`;
                break;
            case "setPenSize":
                this.output += `${spaces}${spriteRef}.setPenSize && ${spriteRef}.setPenSize(${this.formatArg(block.args[0])});\n`;
                break;
            case "changePenSize":
                this.output += `${spaces}${spriteRef}.changePenSize && ${spriteRef}.changePenSize(${this.formatArg(block.args[0])});\n`;
                break;
            default:
                this.output += `${spaces}// Pen block: ${block.name}\n`;
        }
    }

    private formatArg(arg: unknown): string {
        if (typeof arg === "string") {
            // Check if it's a variable reference
            if (arg.startsWith("var:") || arg.startsWith("$")) {
                const varName = arg.startsWith("var:") ? arg.slice(4) : arg.slice(1);
                
                // Handle built-in reporters specially
                const builtInCode = this.getBuiltInReporterCode(varName);
                if (builtInCode) {
                    return builtInCode;
                }
                
                // Check if this is a procedure parameter (local scope takes precedence)
                if (this.currentProcedureParams.has(varName)) {
                    return varName;
                }
                
                return `scratchRuntime.variables["${varName}"]`;
            }
            // Check if it's a list reference
            if (arg.startsWith("list:") || arg.startsWith("#")) {
                const listName = arg.startsWith("list:") ? arg.slice(5) : arg.slice(1);
                return `scratchRuntime.lists["${listName}"]`;
            }
            return `"${arg}"`;
        } else if (typeof arg === "number") {
            return String(arg);
        } else if (typeof arg === "boolean") {
            return String(arg);
        } else if (typeof arg === "object" && arg !== null && "type" in arg) {
            // Handle nested blocks/expressions
            const block = arg as BlockNode;
            return this.formatExpression(block);
        }
        return JSON.stringify(arg);
    }

    // Get JavaScript code for built-in reporter names
    private getBuiltInReporterCode(name: string): string | null {
        const spriteRef = "scratchRuntime.sprites[scratchRuntime.currentSprite]";
        
        switch (name) {
            // Motion reporters
            case "x":
            case "x position":
                return `${spriteRef}.x`;
            case "y":
            case "y position":
                return `${spriteRef}.y`;
            case "direction":
                return `${spriteRef}.direction`;
            
            // Looks reporters
            case "size":
                return `${spriteRef}.size`;
            case "costume number":
                return `${spriteRef}.currentCostume + 1`;  // Scratch uses 1-based index
            case "costume name":
                return `${spriteRef}.costumes[${spriteRef}.currentCostume]`;
            case "backdrop number":
                return `scratchRuntime.stage.currentBackdrop + 1`;  // Scratch uses 1-based index
            case "backdrop name":
                return `scratchRuntime.stage.backdrops[scratchRuntime.stage.currentBackdrop]`;
            
            // Sound reporters
            case "volume":
                return `scratchRuntime.stage.volume`;
            
            // Sensing reporters
            case "answer":
                return `scratchRuntime.answer`;
            case "mouse x":
                return `scratchRuntime.mouse.x`;
            case "mouse y":
                return `scratchRuntime.mouse.y`;
            case "loudness":
                return `0`;  // Placeholder - microphone not implemented
            case "timer":
                return `scratchRuntime.getTimer()`;
            case "username":
                return `scratchRuntime.getUsername()`;
            case "current year":
                return `new Date().getFullYear()`;
            case "current month":
                return `new Date().getMonth() + 1`;  // JS months are 0-indexed
            case "current date":
                return `new Date().getDate()`;
            case "current day of week":
                return `new Date().getDay() + 1`;  // Scratch is 1-indexed (1=Sun)
            case "current hour":
                return `new Date().getHours()`;
            case "current minute":
                return `new Date().getMinutes()`;
            case "current second":
                return `new Date().getSeconds()`;
            case "days since 2000":
                return `Math.floor((Date.now() - new Date(2000, 0, 1).getTime()) / 86400000)`;
            
            default:
                return null;  // Not a built-in reporter
        }
    }

    private formatExpression(block: BlockNode): string {
        switch (block.type) {
            case "operator":
            case "operators":
                return this.formatOperator(block);
            case "sensing":
                return this.formatSensingReporter(block);
            case "motion":
                return this.formatMotionReporter(block);
            case "looks":
                return this.formatLooksReporter(block);
            case "variable":
            case "variables":
                return `scratchRuntime.variables["${block.args[0]}"]`;
            case "list":
                return this.formatListReporter(block);
        }
        return JSON.stringify(block);
    }

    private formatOperator(block: BlockNode): string {
        switch (block.name) {
            case "add":
                return `(Number(${this.formatArg(block.args[0])}) + Number(${this.formatArg(block.args[1])}))`;
            case "subtract":
                return `(Number(${this.formatArg(block.args[0])}) - Number(${this.formatArg(block.args[1])}))`;
            case "multiply":
                return `(Number(${this.formatArg(block.args[0])}) * Number(${this.formatArg(block.args[1])}))`;
            case "divide":
                return `(Number(${this.formatArg(block.args[0])}) / Number(${this.formatArg(block.args[1])}))`;
            case "mod":
                return `(Number(${this.formatArg(block.args[0])}) % Number(${this.formatArg(block.args[1])}))`;
            case "random":
            case "pickRandom":
                return `scratchRuntime.pickRandom(${this.formatArg(block.args[0])}, ${this.formatArg(block.args[1])})`;
            case "greaterThan":
            case "greater":
                return `(Number(${this.formatArg(block.args[0])}) > Number(${this.formatArg(block.args[1])}))`;
            case "lessThan":
            case "less":
                return `(Number(${this.formatArg(block.args[0])}) < Number(${this.formatArg(block.args[1])}))`;
            case "equals":
                return `(${this.formatArg(block.args[0])} == ${this.formatArg(block.args[1])})`;
            case "and":
                return `(${this.formatCondition(block.args[0])} && ${this.formatCondition(block.args[1])})`;
            case "or":
                return `(${this.formatCondition(block.args[0])} || ${this.formatCondition(block.args[1])})`;
            case "not":
                return `!(${this.formatCondition(block.args[0])})`;
            case "join":
                return `(String(${this.formatArg(block.args[0])}) + String(${this.formatArg(block.args[1])}))`;
            case "letterOf":
            case "letter":
                return `String(${this.formatArg(block.args[1])}).charAt(${this.formatArg(block.args[0])} - 1)`;
            case "length":
            case "lengthOf": {
                // Check if the arg is a list (starts with #) or a string
                const arg = block.args[0];
                if (typeof arg === "string" && arg.startsWith("#")) {
                    // It's a list - use list length
                    const listName = arg.substring(1);
                    return `scratchRuntime.lengthOfList("${listName}")`;
                }
                // It's a string - use string length
                return `String(${this.formatArg(arg)}).length`;
            }
            case "contains":
                return `String(${this.formatArg(block.args[0])}).includes(String(${this.formatArg(block.args[1])}))`;
            case "round":
                return `Math.round(Number(${this.formatArg(block.args[0])}))`;
            case "abs":
                return `Math.abs(Number(${this.formatArg(block.args[0])}))`;
            case "floor":
                return `Math.floor(Number(${this.formatArg(block.args[0])}))`;
            case "ceiling":
                return `Math.ceil(Number(${this.formatArg(block.args[0])}))`;
            case "sqrt":
                return `Math.sqrt(Number(${this.formatArg(block.args[0])}))`;
            case "sin":
                return `Math.sin(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "cos":
                return `Math.cos(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "tan":
                return `Math.tan(Number(${this.formatArg(block.args[0])}) * Math.PI / 180)`;
            case "asin":
                return `(Math.asin(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "acos":
                return `(Math.acos(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "atan":
                return `(Math.atan(Number(${this.formatArg(block.args[0])})) * 180 / Math.PI)`;
            case "ln":
                return `Math.log(Number(${this.formatArg(block.args[0])}))`;
            case "log":
                return `Math.log10(Number(${this.formatArg(block.args[0])}))`;
            case "ePow":
            case "e^":
                return `Math.exp(Number(${this.formatArg(block.args[0])}))`;
            case "tenPow":
            case "10^":
                return `Math.pow(10, Number(${this.formatArg(block.args[0])}))`;
            case "expression":
                // Expression block can be:
                // 1. Simple: (variableName) - just wraps a variable
                // 2. Complex: [value, operator, value, operator, value, ...] - arithmetic expression
                if (block.args.length === 1) {
                    const singleArg = block.args[0];
                    if (typeof singleArg === "string" && singleArg.startsWith("$")) {
                        return `scratchRuntime.variables["${singleArg.substring(1)}"]`;
                    }
                    return `(${this.formatArg(singleArg)})`;
                }
                // Build the expression from all args
                // First, check if this is a "not" expression - not is a prefix operator
                // Args like ["not", 10, "<", 5] should become !(10 < 5)
                if (block.args.length > 0 && block.args[0] === "not") {
                    // Build the rest of the expression and negate it
                    const restArgs = block.args.slice(1);
                    let restExpr = "";
                    for (let i = 0; i < restArgs.length; i++) {
                        const arg = restArgs[i];
                        if (typeof arg === "string" && ["+", "-", "*", "/", "%", "mod", ">", "<", "=", "==", "===", "and", "or", "&&", "||"].includes(arg)) {
                            let op = arg;
                            if (op === "mod") op = "%";
                            if (op === "and") op = "&&";
                            if (op === "or") op = "||";
                            if (op === "=") op = "==";
                            restExpr += ` ${op} `;
                        } else {
                            restExpr += this.formatArg(arg);
                        }
                    }
                    return `!(${restExpr})`;
                }
                
                let expr = "";
                for (let i = 0; i < block.args.length; i++) {
                    const arg = block.args[i];
                    if (typeof arg === "string" && ["+", "-", "*", "/", "%", "mod", ">", "<", "=", "==", "===", "and", "or", "&&", "||"].includes(arg)) {
                        // It's an operator
                        let op = arg;
                        if (op === "mod") op = "%";
                        if (op === "and") op = "&&";
                        if (op === "or") op = "||";
                        if (op === "=") op = "==";
                        expr += ` ${op} `;
                    } else {
                        expr += this.formatArg(arg);
                    }
                }
                return `(${expr})`;
            case "list":
                // List name block, just return the name for use elsewhere
                return String(block.args[0]);
        }
        return "null";
    }

    private formatSensingReporter(block: BlockNode): string {
        switch (block.name) {
            case "answer":
                return `scratchRuntime.answer`;
            case "mouseX":
                return `scratchRuntime.mouse.x`;
            case "mouseY":
                return `scratchRuntime.mouse.y`;
            case "mouseDown":
                return `scratchRuntime.mouse.down`;
            case "keyPressed":
            case "key":
                return `scratchRuntime.isKeyPressed(${this.formatArg(block.args[0])})`;
            case "touching":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].isTouching(${this.formatArg(block.args[0])})`;
            case "distanceTo":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].distanceTo(${this.formatArg(block.args[0])})`;
            case "timer":
                return `scratchRuntime.getTimer()`;
            case "loudness":
                return `0`; // Placeholder
            case "username":
                return `scratchRuntime.getUsername()`;
            case "current":
                const dateOption = block.args[0];
                if (dateOption === "year") return `new Date().getFullYear()`;
                if (dateOption === "month") return `(new Date().getMonth() + 1)`;
                if (dateOption === "date") return `new Date().getDate()`;
                if (dateOption === "dayofweek") return `(new Date().getDay() + 1)`;
                if (dateOption === "hour") return `new Date().getHours()`;
                if (dateOption === "minute") return `new Date().getMinutes()`;
                if (dateOption === "second") return `new Date().getSeconds()`;
                return `0`;
            case "daysSince2000":
                return `Math.floor((Date.now() - new Date(2000, 0, 1).getTime()) / 86400000)`;
        }
        return "null";
    }

    private formatMotionReporter(block: BlockNode): string {
        switch (block.name) {
            case "xPosition":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].x`;
            case "yPosition":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].y`;
            case "direction":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].direction`;
        }
        return "0";
    }

    private formatLooksReporter(block: BlockNode): string {
        switch (block.name) {
            case "costumeNumber":
                return `(scratchRuntime.sprites[scratchRuntime.currentSprite].currentCostume + 1)`;
            case "costumeName":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].costumes[scratchRuntime.sprites[scratchRuntime.currentSprite].currentCostume]`;
            case "backdropNumber":
                return `(scratchRuntime.stage.currentBackdrop + 1)`;
            case "backdropName":
                return `scratchRuntime.stage.backdrops[scratchRuntime.stage.currentBackdrop]`;
            case "size":
                return `scratchRuntime.sprites[scratchRuntime.currentSprite].size`;
        }
        return "0";
    }

    private formatListReporter(block: BlockNode): string {
        // Handle different arg patterns - the list name might be in different positions
        let listName: string;
        let indexOrItem: unknown;
        
        // For itemOf: args = [index, listName or #listName]
        // For lengthOfList: args = [listName or #listName]
        // For listContains: args = [listName, item]
        
        switch (block.name) {
            case "itemOf":
            case "itemOfList":
                // args[0] = index, args[1] = list reference
                indexOrItem = block.args[0];
                listName = this.stripVarPrefix(String(block.args[1]));
                return `scratchRuntime.itemOfList("${listName}", ${this.formatArg(indexOrItem)})`;
            case "itemNumberInList":
                indexOrItem = block.args[1];
                listName = this.stripVarPrefix(String(block.args[0]));
                return `scratchRuntime.itemNumberInList("${listName}", ${this.formatArg(indexOrItem)})`;
            case "length":
            case "lengthOfList":
                listName = this.stripVarPrefix(String(block.args[0]));
                return `scratchRuntime.lengthOfList("${listName}")`;
            case "listContains":
            case "contains":
                listName = this.stripVarPrefix(String(block.args[0]));
                indexOrItem = block.args[1];
                return `scratchRuntime.listContains("${listName}", ${this.formatArg(indexOrItem)})`;
        }
        return "[]";
    }

    private formatCondition(condition: unknown): string {
        if (typeof condition === "object" && condition !== null && "type" in condition) {
            return this.formatExpression(condition as BlockNode);
        }
        if (typeof condition === "boolean") {
            return String(condition);
        }
        return String(condition);
    }

    /**
     * Build a complete condition from args array
     * Handles patterns like: [{expr}, "=", value, "then", {body}] or [{expr}, ">", value, "then", {body}]
     * Also handles complex expressions like: [var, "mod", 2, "=", 0, "then", {body}]
     * Also handles simple conditions like: [{cond}]
     * Also handles "key X pressed" patterns: ["key", "space", "pressed", "then", ...]
     */
    private buildConditionFromArgs(args: (string | number | BlockNode)[]): string {
        if (args.length === 0) {
            return "true";
        }

        // Check for "key X pressed" pattern: ["key", keyName, "pressed", ...]
        if (args.length >= 3 && args[0] === "key" && typeof args[1] === "string") {
            // Find "pressed" keyword (it might be at index 2 or later if key name is multi-word like "up arrow")
            let keyName = args[1] as string;
            let pressedIdx = 2;
            
            // Handle multi-word key names like "up arrow", "left arrow", etc.
            if (args[2] === "arrow" || args[2] === "Arrow") {
                keyName = keyName + " arrow";
                pressedIdx = 3;
            }
            
            if (args[pressedIdx] === "pressed") {
                // Map arrow key names to standard key names
                const keyMap: Record<string, string> = {
                    "up arrow": "ArrowUp",
                    "down arrow": "ArrowDown", 
                    "left arrow": "ArrowLeft",
                    "right arrow": "ArrowRight",
                    "space": " ",
                };
                const mappedKey = keyMap[keyName.toLowerCase()] || keyName.toLowerCase();
                return `scratchRuntime.isKeyPressed("${mappedKey}")`;
            }
        }

        // First, handle "not" as a prefix operator - it negates the entire following expression
        // Pattern: ["not", 10, "<", 5] should become !(10 < 5)
        if (args.length > 0 && args[0] === "not") {
            const restArgs = args.slice(1);
            // Filter out "then" if present
            const thenIdx = restArgs.findIndex(a => a === "then");
            const filteredArgs = thenIdx >= 0 ? restArgs.slice(0, thenIdx) : restArgs;
            const innerCond = this.buildConditionFromArgs(filteredArgs);
            return `!(${innerCond})`;
        }

        // Next, check for logical operators (and/or) - these have LOWEST precedence
        // Split on "and" / "or" first, then recursively handle each sub-condition
        const logicalOps = ["and", "or"];
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === "string" && logicalOps.includes(arg)) {
                // Found a logical operator - split here
                const leftArgs = args.slice(0, i);
                const rightArgs = args.slice(i + 1);
                
                // Filter out "then" from rightArgs if present
                const thenIdx = rightArgs.findIndex(a => a === "then");
                const filteredRightArgs = thenIdx >= 0 ? rightArgs.slice(0, thenIdx) : rightArgs;
                
                const leftCond = this.buildConditionFromArgs(leftArgs);
                const rightCond = this.buildConditionFromArgs(filteredRightArgs);
                const jsOp = arg === "and" ? "&&" : "||";
                return `(${leftCond} ${jsOp} ${rightCond})`;
            }
        }

        // Comparison operators (split on these next)
        const comparisonOps = ["=", ">", "<", ">=", "<=", "!="];
        // Arithmetic operators (highest precedence - group these together)
        const arithmeticOps = ["+", "-", "*", "/", "mod", "%"];

        // Find the comparison operator index (first one found)
        let opIndex = -1;
        let op = "";
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === "string" && comparisonOps.includes(arg)) {
                opIndex = i;
                op = arg;
                break;
            }
        }

        if (opIndex > 0 && opIndex < args.length - 1) {
            // Found a comparison operator - build the comparison expression
            // The left side is everything before the comparison operator
            const leftArgs = args.slice(0, opIndex);
            
            // Find the right argument (skip "then" keyword if present)
            // The right side is everything after the comparison operator until "then" or a body block
            let rightEnd = args.length;
            for (let i = opIndex + 1; i < args.length; i++) {
                const arg = args[i];
                if (arg === "then") {
                    rightEnd = i;
                    break;
                }
                // Check if it's a body block (not an expression block)
                if (typeof arg === "object" && arg !== null && "type" in arg) {
                    const block = arg as BlockNode;
                    if (block.type !== "operators" && block.name !== "expression" && block.name !== "list" && block.name !== "mod") {
                        rightEnd = i;
                        break;
                    }
                }
            }
            const rightArgs = args.slice(opIndex + 1, rightEnd);
            
            // Build left expression
            const left = this.buildExpressionFromArgs(leftArgs);
            // Build right expression  
            const right = rightArgs.length === 1 
                ? this.formatArg(rightArgs[0])
                : this.buildExpressionFromArgs(rightArgs);
            
            // Map operator to JS
            const jsOp = op === "=" ? "==" : op;
            return `(${left} ${jsOp} ${right})`;
        }

        // No comparison operator - just format the first argument as a condition
        return this.formatCondition(args[0]);
    }

    /**
     * Build an expression string from an array of args
     * Handles arithmetic expressions like: [var, "mod", 2] or [a, "+", b, "*", c]
     */
    private buildExpressionFromArgs(args: (string | number | BlockNode)[]): string {
        if (args.length === 0) {
            return "0";
        }
        if (args.length === 1) {
            return this.formatArg(args[0]);
        }
        
        // Handle "not" as a prefix operator
        if (args[0] === "not") {
            const restArgs = args.slice(1);
            const innerExpr = this.buildExpressionFromArgs(restArgs);
            return `!(${innerExpr})`;
        }
        
        // Build the expression from all args
        let expr = "";
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === "string" && ["+", "-", "*", "/", "%", "mod", "and", "or"].includes(arg)) {
                // It's an operator
                let op = arg;
                if (op === "mod") op = "%";
                if (op === "and") op = "&&";
                if (op === "or") op = "||";
                expr += ` ${op} `;
            } else {
                expr += this.formatArg(arg);
            }
        }
        return `(${expr})`;
    }

    /**
     * Format an argument for use in a condition expression
     * Handles expression blocks and variable references
     */
    private formatConditionArg(arg: unknown): string {
        if (typeof arg === "object" && arg !== null && "type" in arg) {
            const block = arg as BlockNode;
            if (block.name === "expression" && block.args && block.args.length > 0) {
                // Check if it's a simple variable reference (single string arg starting with $)
                const firstArg = block.args[0];
                if (typeof firstArg === "string" && firstArg.startsWith("$")) {
                    // Simple variable reference like (varName)
                    return `scratchRuntime.variables["${firstArg.slice(1)}"]`;
                }
                // Otherwise it's a complex expression - format it properly
                return this.formatExpression(block);
            }
            return this.formatExpression(block);
        }
        return this.formatArg(arg);
    }

    /**
     * Find the body block from args array
     * The body is usually after "then" keyword or is the last BlockNode that isn't a condition
     */
    private findBodyBlockFromArgs(args: (string | number | BlockNode)[]): BlockNode | null {
        // Look for block after "then" keyword
        for (let i = 0; i < args.length; i++) {
            if (args[i] === "then" && i + 1 < args.length) {
                const nextArg = args[i + 1];
                if (typeof nextArg === "object" && nextArg !== null && "type" in nextArg) {
                    return nextArg as BlockNode;
                }
            }
        }
        
        // Look for the last BlockNode that could be a body (not an expression/condition)
        for (let i = args.length - 1; i >= 0; i--) {
            const arg = args[i];
            if (typeof arg === "object" && arg !== null && "type" in arg) {
                const block = arg as BlockNode;
                // Skip condition-related blocks
                if (block.name !== "expression" && block.name !== "list" && block.type !== "operators") {
                    return block;
                }
            }
        }
        
        return null;
    }
}
