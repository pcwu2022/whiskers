// Parser: Convert tokens to an AST (Abstract Syntax Tree)
// This class, Parser, takes an array of tokens generated by the Lexer and constructs
// an Abstract Syntax Tree (AST). The AST represents the structure of the program,
// making it easier to analyze and execute.

import { Program, BlockNode, Script, BlockType, Token, TokenType, blockTypeMap, CompilerError, ErrorCodes } from "@/types/compilerTypes";
import { Lexer } from "./lexer";
// import { SimpleDebugger } from "./debugger";

// const d: SimpleDebugger = new SimpleDebugger();

export class Parser {
    // Array of tokens to be parsed.
    private tokens: Token[];
    // Current position in the token array.
    private position: number = 0;
    // Stack to track block nesting for indentation-based blocks
    // Each entry stores the block and the indentation level at which it lives
    private blockStack: { block: BlockNode; indent: number }[] = [];
    // Track the last block seen at each indentation level to connect `.next` chains correctly
    private lastAtIndent: (BlockNode | null)[] = [];
    // Current indentation level
    private indentLevel: number = 0;
    // Collection of errors found during parsing
    private errors: CompilerError[] = [];
    // Declared variables (for undeclared variable checking)
    private declaredVariables: Set<string> = new Set();
    // Declared lists
    private declaredLists: Set<string> = new Set();

    // Constructor: Initializes the Parser with the token array.
    constructor(tokens: Token[]) {
        this.tokens = tokens;
    }

    // Get collected errors
    getErrors(): CompilerError[] {
        return this.errors;
    }

    // Add an error
    private addError(code: string, message: string, token?: Token, suggestion?: string): void {
        const line = token?.line || this.current?.line || 1;
        const column = token?.column || this.current?.column || 1;
        this.errors.push({
            code,
            message,
            line,
            column,
            severity: "error",
            suggestion,
        });
    }

    // Get the current token
    private get current(): Token {
        return this.tokens[this.position];
    }

    // Check if we've reached the end of the tokens
    private isAtEnd(): boolean {
        return this.position >= this.tokens.length || this.current.type === TokenType.EOF;
    }

    // Advance to the next token and return the previous one
    private advance(): Token {
        const token = this.current;
        if (!this.isAtEnd()) {
            this.position++;
        }
        return token;
    }

    // Look ahead at the next token without advancing
    private peek(offset: number = 1): Token | null {
        if (this.position + offset >= this.tokens.length) {
            return null;
        }
        return this.tokens[this.position + offset];
    }

    // Check if the current token's type matches the expected type
    private match(type: TokenType): boolean {
        if (this.isAtEnd()) return false;
        return this.current.type === type;
    }

    // Consume a token if it matches the expected type, otherwise throw an error
    private consume(type: TokenType, errorMessage: string): Token {
        if (this.match(type)) {
            return this.advance();
        }
        throw new Error(`${errorMessage} at line ${this.current.line}, column ${this.current.column}`);
    }

    // Skip newlines and comments
    private skipIrrelevant(): void {
        while (!this.isAtEnd() && (this.match(TokenType.NEWLINE) || this.match(TokenType.COMMENT))) {
            this.advance();
        }
    }

    // parse: Main method to generate the AST (Program).
    parse(): Program {
        // Initialize the program structure with empty scripts, variables, and lists.
        const program: Program = {
            scripts: [],
            variables: new Map(),
            lists: new Map(),
        };

        // Reset declared variables and lists
        this.declaredVariables.clear();
        this.declaredLists.clear();
        
        // Add built-in variables (sensing reporters, etc.)
        const builtInVariables = [
            "x", "y", "direction", "size", "volume", "timer", "answer",
            "mouse x", "mouse y", "loudness", "username",
            "costume number", "costume name", "backdrop number", "backdrop name"
        ];
        builtInVariables.forEach(v => this.declaredVariables.add(v));

        // Skip any initial newlines or comments
        this.skipIrrelevant();

        // First pass: collect all variable and list declarations
        const savedPosition = this.position;
        while (!this.isAtEnd()) {
            this.skipIrrelevant();
            if (this.isAtEnd()) break;

            if (this.match(TokenType.KEYWORD)) {
                const keyword = this.current.value;
                if (keyword === "var" || keyword === "variable") {
                    this.advance(); // Skip 'var'
                    if (this.match(TokenType.IDENTIFIER)) {
                        this.declaredVariables.add(this.current.value);
                    }
                } else if (keyword === "list") {
                    this.advance(); // Skip 'list'
                    if (this.match(TokenType.IDENTIFIER)) {
                        this.declaredLists.add(this.current.value);
                    }
                }
            }
            this.advance();
        }
        
        // Reset position for actual parsing
        this.position = savedPosition;

        // Skip any initial newlines or comments
        this.skipIrrelevant();

        // Loop through the tokens until we reach the end.
        while (!this.isAtEnd()) {
            try {
                // Skip any additional newlines or comments
                this.skipIrrelevant();

                if (this.isAtEnd()) break;

                // Check for declarations and scripts
                if (this.match(TokenType.KEYWORD)) {
                    const keyword = this.current.value;

                    if (keyword === "when") {
                        // Parse a script starting with 'when'
                        const script = this.parseScript();
                        program.scripts.push(script);
                    } else if (keyword === "var" || keyword === "variable") {
                        // Parse variable declaration
                        this.parseVariableDeclaration(program);
                    } else if (keyword === "list") {
                        // Parse list declaration
                        this.parseListDeclaration(program);
                    } else if (keyword === "define") {
                        // Parse custom block definition
                        this.parseCustomBlockDefinition(program);
                    } else {
                        // Unknown keyword or statement at top level
                        this.advance();
                    }
                } else {
                    // Skip unknown tokens at top level
                    this.advance();
                }
            } catch (error) {
                // Log the error and try to recover
                console.error(error);
                this.synchronize();
            }
        }

        // Return the constructed program (AST).
        return program;
    }

    // synchronize: Skip tokens until a safe point to continue parsing
    private synchronize(): void {
        this.advance();

        while (!this.isAtEnd()) {
            // Skip until we find a keyword that could start a new statement
            if (
                this.current.type === TokenType.KEYWORD &&
                ["when", "var", "variable", "list", "define"].includes(this.current.value)
            ) {
                return;
            }

            // Skip until we find a newline, which might indicate a new statement
            if (this.current.type === TokenType.NEWLINE) {
                this.advance();
                return;
            }

            this.advance();
        }
    }

    // parseScript: Parses a script (sequence of blocks).
    private parseScript(): Script {
        // Create a new script with an empty array of blocks
        const script: Script = {
            blocks: [],
        };

        // Reset the block stack for this script
        this.blockStack = [];
        this.lastAtIndent = [];
        this.indentLevel = 0;

        // Parse the first block (usually an event block)
        const firstBlock = this.parseBlock();
        if (firstBlock) {
            script.blocks.push(firstBlock);
            // track the top-level block with indent 0
            this.blockStack.push({ block: firstBlock, indent: 0 });
            this.lastAtIndent[0] = firstBlock;

            // Parse subsequent blocks
            this.parseScriptBlocks(script);
        }

        // Return the script with its blocks.
        return script;
    }

    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    private parseScriptBlocks(script: Script): void {
        // Continue parsing blocks until we reach the end of the script
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Check for indentation changes
            if (this.match(TokenType.INDENT)) {
                // Increase indentation level and consume the INDENT token
                this.indentLevel++;
                this.advance();

                // If there is no parent block on the stack, nothing to attach to
                if (!this.blockStack.length) {
                    break;
                }

                const parentEntry = this.blockStack[this.blockStack.length - 1];
                const parentBlock = parentEntry.block;

                // Parse the first nested block in this indented region
                const firstNestedBlock = this.parseBlock();
                if (!firstNestedBlock) {
                    continue;
                }

                // Attach the nested sequence to the parent block
                // For event blocks (e.g., 'when') attach as `next` so handlers execute sequentially
                if (parentBlock.type === "event" || parentBlock.name === "when") {
                    parentBlock.next = firstNestedBlock;
                } else {
                    // Common convention: args[0] is condition/count, body goes at next index
                    parentBlock.args.push(firstNestedBlock);
                }

                // Track the first block at this indent level and push onto the stack
                this.lastAtIndent[this.indentLevel] = firstNestedBlock;
                this.blockStack.push({ block: firstNestedBlock, indent: this.indentLevel });

                // Parse additional sibling blocks at the same indentation level
                let currentBlock = firstNestedBlock;
                while (!this.isAtEnd() && !this.match(TokenType.DEDENT) && !this.match(TokenType.INDENT)) {
                    this.skipIrrelevant();
                    if (this.isAtEnd() || this.match(TokenType.DEDENT) || this.match(TokenType.INDENT)) break;

                    if (this.isBlockStart()) {
                        const nextBlock = this.parseBlock();
                        if (nextBlock) {
                            currentBlock.next = nextBlock;
                            currentBlock = nextBlock;
                            // update the last block at this indent and push onto stack
                            this.lastAtIndent[this.indentLevel] = nextBlock;
                            this.blockStack.push({ block: nextBlock, indent: this.indentLevel });
                        }
                    } else {
                        this.advance();
                    }
                }
            } else if (this.match(TokenType.DEDENT)) {
                // Consume DEDENT and reduce indent level
                this.advance();
                this.indentLevel = Math.max(0, this.indentLevel - 1);

                // Pop any blocks that belonged to deeper indentation levels
                while (this.blockStack.length && this.blockStack[this.blockStack.length - 1].indent > this.indentLevel) {
                    this.blockStack.pop();
                }
                // Clear lastAtIndent entries deeper than current indent
                for (let i = this.lastAtIndent.length - 1; i > this.indentLevel; i--) {
                    this.lastAtIndent[i] = null;
                }

                // If we've reduced indentation below our starting level, we're done with this script
                if (this.indentLevel <= 0) {
                    this.indentLevel = 0;
                    // keep the top-level block on the stack but exit if at base
                    if (this.blockStack.length <= 1) break;
                }
            } else if (this.isBlockStart()) {
                // Parse a new block at the current indentation level
                const block = this.parseBlock();
                if (block) {
                    // If there is an existing block at this indent, connect as `.next`
                    const last = this.lastAtIndent[this.indentLevel];
                    if (last) {
                        last.next = block;
                    } else {
                        // This is a top-level block in the script for this indent
                        script.blocks.push(block);
                    }

                    // Track this block as the last at this indent and push onto the stack
                    this.lastAtIndent[this.indentLevel] = block;
                    this.blockStack.push({ block, indent: this.indentLevel });
                }
            } else {
                // Skip tokens that don't start a block
                this.advance();
            }
        }
    }

    // isBlockStart: Checks if the current token can start a block
    private isBlockStart(): boolean {
        if (!this.match(TokenType.KEYWORD)) return false;

        const blockStartKeywords = [
            // Events
            "when",
            "broadcast",
            "receive",
            
            // Motion
            "move",
            "turn",
            "go",
            "goto",
            "glide",
            "point",
            
            // Looks
            "say",
            "think",
            "show",
            "hide",
            "switch",
            "change",
            "set",
            "clear",
            "next",
            
            // Sound
            "play",
            "start",
            "stop",
            
            // Control
            "wait",
            "repeat",
            "forever",
            "if",
            "else",
            "until",
            "create",
            "delete",
            
            // Sensing
            "ask",
            "touching",
            "reset",
            
            // Variables
            "add",
            "insert",
            "replace",
            
            // Operators (rarely start blocks)
            "join",
            "pick",
            
            // Pen
            "pen",
            "stamp",
            "erase",
            
            // Custom
            "define",
        ];

        return blockStartKeywords.includes(this.current.value);
    }

    // parseBlock: Parses a single block.
    private parseBlock(): BlockNode | null {
        // Check if the current token can start a block
        if (!this.isBlockStart()) {
            return null;
        }

        // Get the block name (keyword)
        let blockKeyword = this.consume(TokenType.KEYWORD, "Expected block keyword").value;

        // Normalize multi-word block keywords (e.g., 'turn right' -> 'turnRight', 'repeat until' -> 'repeatUntil')
        if (blockKeyword === "turn") {
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "right" || this.current.value === "left")) {
                const dir = this.advance().value;
                blockKeyword = dir === "right" ? "turnRight" : "turnLeft";
            }
        } else if (blockKeyword === "go") {
            // Handle "go to x: y:", "go to random position", "go to mouse-pointer", "go to front/back layer"
            // Also handle "go back N layers" and "go forward N layers"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const firstWord = this.current.value as string;
                
                if (firstWord === "to") {
                    this.advance(); // Consume 'to'
                    this.skipIrrelevant();
                    
                    // Check what follows "go to"
                    if (!this.isAtEnd()) {
                        if (this.match(TokenType.KEYWORD)) {
                            const nextWord = this.current.value as string;
                            if (nextWord === "x" || nextWord === "x:") {
                                blockKeyword = "goToXY";
                            } else if (nextWord === "random") {
                                this.advance(); // Consume 'random'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "position") {
                                    this.advance(); // Consume 'position'
                                }
                                blockKeyword = "goToRandom";
                            } else if (nextWord === "mouse-pointer") {
                                this.advance(); // Consume 'mouse-pointer'
                                blockKeyword = "goToMouse";
                            } else if (nextWord === "front") {
                                this.advance(); // Consume 'front'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "layer") {
                                    this.advance(); // Consume 'layer'
                                }
                                blockKeyword = "goToFront";
                            } else if (nextWord === "back") {
                                this.advance(); // Consume 'back'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "layer") {
                                    this.advance(); // Consume 'layer'
                                }
                                blockKeyword = "goToBack";
                            } else {
                                // go to "SpriteName"
                                blockKeyword = "goToSprite";
                            }
                        } else if (this.match(TokenType.STRING)) {
                            // go to "SpriteName"
                            blockKeyword = "goToSprite";
                        } else {
                            blockKeyword = "goToXY";
                        }
                    }
                } else if (firstWord === "back") {
                    // "go back N layers" - looks block
                    this.advance(); // Consume 'back'
                    blockKeyword = "goBackLayers";
                    // The number will be parsed as an argument
                } else if (firstWord === "forward") {
                    // "go forward N layers" - looks block
                    this.advance(); // Consume 'forward'
                    blockKeyword = "goForwardLayers";
                    // The number will be parsed as an argument
                }
            }
        } else if (blockKeyword === "glide") {
            // Handle "glide N secs to x: y:" or "glide N secs to random position" etc
            blockKeyword = "glide";
        } else if (blockKeyword === "point") {
            // Handle "point in direction N" or "point towards X"
            this.skipIrrelevant();;
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "in") {
                    this.advance(); // Consume 'in'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "direction") {
                        this.advance(); // Consume 'direction'
                    }
                    blockKeyword = "pointInDirection";
                } else if (nextWord === "towards") {
                    this.advance(); // Consume 'towards'
                    blockKeyword = "pointTowards";
                }
            }
        } else if (blockKeyword === "set") {
            // Handle "set x to", "set y to", "set size to", "set rotation style", "set pen color/size"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "x") {
                    this.advance(); // Consume 'x'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setX";
                } else if (nextWord === "y") {
                    this.advance(); // Consume 'y'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setY";
                } else if (nextWord === "size") {
                    this.advance(); // Consume 'size'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setSize";
                } else if (nextWord === "rotation") {
                    this.advance(); // Consume 'rotation'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "style") {
                        this.advance(); // Consume 'style'
                    }
                    blockKeyword = "setRotationStyle";
                } else if (nextWord === "pen") {
                    this.advance(); // Consume 'pen'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const penProp = this.current.value as string;
                        if (penProp === "color") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                                this.advance();
                            }
                            blockKeyword = "setPenColor";
                        } else if (penProp === "size") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                                this.advance();
                            }
                            blockKeyword = "setPenSize";
                        }
                    }
                } else if (nextWord === "volume") {
                    this.advance(); // Consume 'volume'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setVolume";
                } else {
                    // set variable to value - check for effect names
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    if (effectNames.includes(nextWord)) {
                        this.advance(); // Consume effect name
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "effect") {
                            this.advance(); // Consume 'effect'
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
                                this.advance(); // Consume 'to'
                            }
                        }
                        blockKeyword = "setEffect";
                    } else {
                        // set variable to value
                        blockKeyword = "setVariable";
                    }
                }
            } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
                // set <variableName> to <value> - the variable name is an IDENTIFIER
                blockKeyword = "setVariable";
            }
        } else if (blockKeyword === "change") {
            // Handle "change x by", "change y by", "change size by", "change effect by", "change pen size by", "change volume by"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "x") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                        this.advance();
                    }
                    blockKeyword = "changeX";
                } else if (nextWord === "y") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                        this.advance();
                    }
                    blockKeyword = "changeY";
                } else if (nextWord === "size") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                        this.advance();
                    }
                    blockKeyword = "changeSize";
                } else if (nextWord === "pen") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const penProp = this.current.value as string;
                        if (penProp === "size") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                                this.advance();
                            }
                            blockKeyword = "changePenSize";
                        }
                    }
                } else if (nextWord === "volume") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                        this.advance();
                    }
                    blockKeyword = "changeVolume";
                } else {
                    // Check for effects
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    if (effectNames.includes(nextWord)) {
                        this.advance();
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "effect") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "by") {
                                this.advance();
                            }
                        }
                        blockKeyword = "changeEffect";
                    } else {
                        // change variable by
                        blockKeyword = "changeVariable";
                    }
                }
            }
        } else if (blockKeyword === "repeat") {
            // support 'repeat until' as a combined keyword
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "until") {
                this.advance();
                blockKeyword = "repeatUntil";
            }
        } else if (blockKeyword === "create") {
            // Handle "create clone of myself" or "create clone of <sprite>"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "clone") {
                this.advance(); // consume "clone"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "of") {
                    this.advance(); // consume "of"
                }
                blockKeyword = "createClone";
            }
        } else if (blockKeyword === "delete") {
            // Handle "delete this clone"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "this") {
                this.advance(); // consume "this"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "clone") {
                    this.advance(); // consume "clone"
                    blockKeyword = "deleteThisClone";
                }
            }
        } else if (blockKeyword === "when") {
            // Handle multi-word "when" keywords
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                
                if (nextWord === "green") {
                    // "when green flag clicked"
                    this.advance(); // Consume 'green'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "flag") {
                        this.advance(); // Consume 'flag'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "clicked") {
                            this.advance(); // Consume 'clicked'
                        }
                    }
                    blockKeyword = "whenFlagClicked";
                } else if (nextWord === "this") {
                    // "when this sprite clicked"
                    this.advance(); // Consume 'this'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "sprite") {
                        this.advance(); // Consume 'sprite'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "clicked") {
                            this.advance(); // Consume 'clicked'
                        }
                    }
                    blockKeyword = "whenSpriteClicked";
                } else if (nextWord === "I") {
                    this.advance(); // Consume 'I'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const word = this.current.value as string;
                        if (word === "receive") {
                            this.advance(); // Consume 'receive'
                            blockKeyword = "whenIReceive";
                        } else if (word === "start") {
                            this.advance(); // Consume 'start'
                            // Optionally consume "as a clone"
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "as") {
                                this.advance(); // Consume 'as'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "a") {
                                    this.advance(); // Consume 'a'
                                    this.skipIrrelevant();
                                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "clone") {
                                        this.advance(); // Consume 'clone'
                                    }
                                }
                            }
                            blockKeyword = "whenIStartAsClone";
                        }
                    }
                } else if (nextWord === "flagClicked") {
                    // Support old syntax "when flagClicked" 
                    this.advance();
                    blockKeyword = "whenFlagClicked";
                } else if (nextWord === "spriteClicked") {
                    // Support old syntax "when spriteClicked"
                    this.advance();
                    blockKeyword = "whenSpriteClicked";
                } else if (nextWord === "cloneStarted") {
                    // Support old syntax "when cloneStarted"
                    this.advance();
                    blockKeyword = "whenIStartAsClone";
                } else if (nextWord === "receive") {
                    // Support old syntax "when receive"
                    this.advance();
                    blockKeyword = "whenIReceive";
                } else {
                    // Check for "when X key pressed" pattern
                    // nextWord could be the key name (space, up arrow, a, etc.)
                    const keyName = nextWord;
                    this.advance(); // Consume the key name
                    this.skipIrrelevant();
                    
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "key") {
                        this.advance(); // Consume 'key'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "pressed") {
                            this.advance(); // Consume 'pressed'
                            blockKeyword = "whenKeyPressed";
                            // Store the key name by encoding it temporarily
                            blockKeyword = `whenKeyPressed:${keyName}`;
                        }
                    }
                }
            } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
                // Handle "when <identifier> key pressed" (e.g., "when a key pressed")
                const keyName = this.current.value as string;
                this.advance(); // Consume the key name
                this.skipIrrelevant();
                
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "key") {
                    this.advance(); // Consume 'key'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "pressed") {
                        this.advance(); // Consume 'pressed'
                        blockKeyword = `whenKeyPressed:${keyName}`;
                    }
                }
            }
        }

        // Determine the block type based on the keyword
        // Handle special encoded block keywords like "whenKeyPressed:space"
        let keyPressedKey: string | null = null;
        if (blockKeyword.startsWith("whenKeyPressed:")) {
            keyPressedKey = blockKeyword.split(":")[1];
            blockKeyword = "whenKeyPressed";
        }
        
        const blockType: BlockType = this.determineBlockType(blockKeyword);

        // Parse block arguments (with special handling for certain blocks)
        let args: (string | number | BlockNode)[];
        
        if (keyPressedKey !== null) {
            // Key was already captured during "when X key pressed" parsing
            args = [keyPressedKey];
        } else if (blockKeyword === "goToXY") {
            // Parse "x: N y: N" format
            args = this.parseGoToXYArguments();
        } else if (blockKeyword === "glide") {
            // Parse "N secs to x: N y: N" format
            args = this.parseGlideArguments();
        } else if (blockKeyword === "goBackLayers" || blockKeyword === "goForwardLayers") {
            // Parse "N layers" - just get the number, skip "layers"
            args = this.parseLayersArguments();
        } else {
            args = this.parseBlockArguments();
        }

        // Create the block node
        const block: BlockNode = {
            type: blockType,
            name: blockKeyword,
            args,
        };

        // Handle special case for if-else blocks
        if (blockKeyword === "if") {
            // Check for an else clause
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "else") {
                this.advance(); // Consume 'else'

                // Parse the else block
                const elseBlock = this.parseBlock();
                if (elseBlock) {
                    // Add the else block as a special argument
                    block.args.push("else");
                    block.args.push(elseBlock);
                }
            }
        }

        return block;
    }

    // Parse "x: N y: N" arguments for goToXY block
    private parseGoToXYArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Expect "x:" or "x" followed by number, then "y:" or "y" followed by number
        // Pattern: x: 100 y: 50  OR  x 100 y 50
        
        // Skip 'x' or 'x:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "x" || this.current.value === "x:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get x value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0); // default
        }
        
        this.skipIrrelevant();
        
        // Skip 'y' or 'y:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "y" || this.current.value === "y:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get y value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0); // default
        }
        
        return args;
    }
    
    // Parse "N secs to x: N y: N" arguments for glide block
    private parseGlideArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Get duration (number of seconds)
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else {
            args.push(1); // default 1 second
        }
        
        this.skipIrrelevant();
        
        // Skip 'secs' or 'seconds' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && 
            (this.current.value === "secs" || this.current.value === "seconds" || this.current.value === "sec")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip 'to' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "to") {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip 'x' or 'x:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "x" || this.current.value === "x:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get x value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0);
        }
        
        this.skipIrrelevant();
        
        // Skip 'y' or 'y:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "y" || this.current.value === "y:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get y value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0);
        }
        
        return args;
    }
    
    // Parse "N layers" arguments for go back/forward layers blocks
    private parseLayersArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Get number of layers
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else {
            args.push(1); // default 1 layer
        }
        
        this.skipIrrelevant();
        
        // Skip 'layers' or 'layer' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && 
            (this.current.value === "layers" || this.current.value === "layer")) {
            this.advance();
        }
        
        return args;
    }

    // determineBlockType: Determine the type of block based on its keyword
    private determineBlockType(keyword: string): BlockType {
        // Maps common Scratch block keywords to their respective types
        return blockTypeMap[keyword] || "custom";
    }

    // parseBlockArguments: Parse arguments for a block based on its type
    private parseBlockArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];

        // Continue parsing arguments until we hit a new block, indentation change, or end of line
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Stop if we encounter a new block start, indent, or dedent
            if (
                this.match(TokenType.INDENT) ||
                this.match(TokenType.DEDENT) ||
                (this.match(TokenType.KEYWORD) && this.isBlockStart())
            ) {
                break;
            }

            // Parse different types of arguments
            if (this.match(TokenType.STRING)) {
                // String argument
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                // Number argument
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                // Check if this identifier is a declared variable or list
                const token = this.current;
                const identifierName = this.advance().value;
                
                // Check if it's a known variable or list
                if (!this.declaredVariables.has(identifierName) && 
                    !this.declaredLists.has(identifierName) &&
                    !Lexer.RESERVED_KEYWORDS.has(identifierName)) {
                    // Unknown identifier - could be undeclared variable
                    this.addError(
                        ErrorCodes.UNDECLARED_VARIABLE,
                        `'${identifierName}' is not declared. Did you forget to declare it?`,
                        token,
                        `Add 'var ${identifierName} = 0' or 'list ${identifierName} = []' at the top of your code.`
                    );
                }
                args.push(identifierName);
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                // Nested expression in parentheses
                args.push(this.parseExpression());
            } else if (this.match(TokenType.BRACKET_OPEN)) {
                // Brackets are not allowed in block arguments (only for list init)
                const bracketToken = this.current;
                this.addError(
                    ErrorCodes.INVALID_BRACKET,
                    "Square brackets are not allowed here.",
                    bracketToken,
                    "Use variable names directly without brackets."
                );
                // Skip the bracketed content
                this.advance(); // Skip '['
                while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance();
                }
                if (this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance(); // Skip ']'
                }
            } else if (this.match(TokenType.KEYWORD)) {
                // Keyword argument
                args.push(this.advance().value);
            } else if (this.match(TokenType.OPERATOR)) {
                // Operator
                args.push(this.advance().value);
            } else if (this.match(TokenType.COLON)) {
                // Colon (for x: y: syntax)
                args.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        return args;
    }

    // parseExpression: Parse a parenthesized expression
    private parseExpression(): BlockNode {
        this.consume(TokenType.PARENTHESIS_OPEN, "Expected '('");

        const args: (string | number | BlockNode)[] = [];

        // Parse the expression until we hit the closing parenthesis
        while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
            if (this.match(TokenType.STRING)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.OPERATOR)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                args.push(this.parseExpression());
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.PARENTHESIS_CLOSE, "Expected ')'");

        // Create an operator block for the expression
        return {
            type: "operators",
            name: "expression",
            args,
        };
    }

    // parseListLiteral: Parse a list literal [value1, value2, ...]
    // Also handles [varName] and [effectName] in Scratch syntax
    private parseListLiteral(): (string | number)[] {
        this.consume(TokenType.BRACKET_OPEN, "Expected '['");

        const values: (string | number)[] = [];

        // Parse list values until we hit the closing bracket
        while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
            // Skip commas between values
            if (this.match(TokenType.COMMA)) {
                this.advance();
                continue;
            }

            if (this.match(TokenType.STRING)) {
                values.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                values.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                values.push(this.advance().value);
            } else if (this.match(TokenType.KEYWORD)) {
                // Keywords inside brackets should be treated as values (e.g., [color], [ghost])
                values.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.BRACKET_CLOSE, "Expected ']'");

        return values;
    }

    // parseVariableDeclaration: Parses a variable declaration.
    private parseVariableDeclaration(program: Program): void {
        // Skip 'var' or 'variable' keyword
        const varKeywordToken = this.advance();

        // Expect a variable name (identifier)
        if (!this.match(TokenType.IDENTIFIER)) {
            this.addError(
                ErrorCodes.INVALID_SYNTAX,
                "Expected variable name after 'var'.",
                varKeywordToken,
                "Variable names must start with a letter and contain only letters, numbers, and underscores."
            );
            this.synchronize();
            return;
        }
        
        const nameToken = this.advance();
        const variableName = nameToken.value;

        // Check if the variable name is a reserved keyword
        if (Lexer.RESERVED_KEYWORDS.has(variableName)) {
            this.addError(
                ErrorCodes.RESERVED_KEYWORD,
                `'${variableName}' is a reserved keyword and cannot be used as a variable name.`,
                nameToken,
                `Choose a different name for your variable. Reserved keywords include: color, ghost, fisheye, etc.`
            );
            this.synchronize();
            return;
        }

        // Add to declared variables
        this.declaredVariables.add(variableName);

        // Check for initial value assignment
        let initialValue: string | number | object | undefined | null = 0; // Default value

        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse the initial value
            if (this.match(TokenType.NUMBER)) {
                initialValue = parseFloat(this.advance().value);
            } else if (this.match(TokenType.STRING)) {
                initialValue = this.advance().value;
            } else if (this.match(TokenType.IDENTIFIER)) {
                initialValue = this.advance().value;
            } else {
                this.addError(
                    ErrorCodes.MISSING_VALUE,
                    "Expected a value after '=' in variable declaration.",
                    this.current,
                    "Provide an initial value like: var score = 0 or var name = \"Player\""
                );
            }
        }

        // Add the variable to the program
        program.variables.set(variableName, initialValue);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseListDeclaration: Parses a list declaration.
    private parseListDeclaration(program: Program): void {
        // Skip 'list' keyword
        const listKeywordToken = this.advance();

        // Expect a list name (identifier)
        if (!this.match(TokenType.IDENTIFIER)) {
            this.addError(
                ErrorCodes.INVALID_SYNTAX,
                "Expected list name after 'list'.",
                listKeywordToken,
                "List names must start with a letter and contain only letters, numbers, and underscores."
            );
            this.synchronize();
            return;
        }
        
        const nameToken = this.advance();
        const listName = nameToken.value;

        // Check if the list name is a reserved keyword
        if (Lexer.RESERVED_KEYWORDS.has(listName)) {
            this.addError(
                ErrorCodes.RESERVED_KEYWORD,
                `'${listName}' is a reserved keyword and cannot be used as a list name.`,
                nameToken,
                `Choose a different name for your list. Reserved keywords include: color, ghost, fisheye, etc.`
            );
            this.synchronize();
            return;
        }

        // Add to declared lists
        this.declaredLists.add(listName);

        // Initialize with an empty list
        let listValues: (string | number | object | undefined | null)[] = [];

        // Check for initial values - ONLY [] is allowed
        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse list initialization - must be []
            if (this.match(TokenType.BRACKET_OPEN)) {
                const openBracket = this.advance();
                
                // Check if it's empty []
                if (this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance(); // Skip ']'
                    // Empty list - this is valid
                } else {
                    // Non-empty brackets - not allowed
                    this.addError(
                        ErrorCodes.INVALID_BRACKET,
                        "Only empty brackets '[]' are allowed for list initialization.",
                        openBracket,
                        "Use 'list myList = []' to create an empty list, then use 'add' to add items."
                    );
                    // Skip to closing bracket
                    while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
                        this.advance();
                    }
                    if (this.match(TokenType.BRACKET_CLOSE)) {
                        this.advance();
                    }
                }
            } else {
                this.addError(
                    ErrorCodes.INVALID_SYNTAX,
                    "Lists must be initialized with '[]'.",
                    this.current,
                    "Use: list myList = []"
                );
            }
        }

        // Add the list to the program
        program.lists.set(listName, listValues);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseCustomBlockDefinition: Parse a custom block definition (procedure).
    private parseCustomBlockDefinition(program: Program): void {
        // Skip 'define' keyword
        this.advance();

        // Expect the block name (identifier)
        const blockName = this.consume(TokenType.IDENTIFIER, "Expected custom block name").value;

        // Parse parameter list if available
        const parameters: string[] = [];

        if (!this.isAtEnd() && this.match(TokenType.PARENTHESIS_OPEN)) {
            this.advance(); // Skip '('

            // Parse parameters until closing parenthesis
            while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
                if (this.match(TokenType.IDENTIFIER)) {
                    parameters.push(this.advance().value);
                } else if (this.match(TokenType.COMMA)) {
                    this.advance(); // Skip commas between parameters
                } else {
                    this.advance(); // Skip other tokens
                }
            }

            if (!this.isAtEnd()) {
                this.advance(); // Skip ')'
            }
        }

        // Create a custom block script
        const customScript: Script = {
            blocks: [],
        };

        // Parse the custom block body
        this.skipIrrelevant();

        if (!this.isAtEnd() && this.match(TokenType.INDENT)) {
            this.advance(); // Skip indent

            // Reset indentation for parsing this block
            const oldIndentLevel = this.indentLevel;
            this.indentLevel = 1;

            // Parse the body of the custom block
            this.parseScriptBlocks(customScript);

            // Restore indentation level
            this.indentLevel = oldIndentLevel;
        }

        // Add this custom block to the program
        // For now, we'll add it as a special script with metadata
        customScript.blocks.unshift({
            type: "custom",
            name: "define",
            args: [blockName, ...parameters],
        });

        program.scripts.push(customScript);
    }
}
