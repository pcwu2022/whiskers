// Parser: Convert tokens to an AST (Abstract Syntax Tree)
// This class, Parser, takes an array of tokens generated by the Lexer and constructs
// an Abstract Syntax Tree (AST). The AST represents the structure of the program,
// making it easier to analyze and execute.

import { Program, BlockNode, Script, BlockType, Token, TokenType, blockTypeMap } from "@/types/compilerTypes";
// import { SimpleDebugger } from "./debugger";

// const d: SimpleDebugger = new SimpleDebugger();

export class Parser {
    // Array of tokens to be parsed.
    private tokens: Token[];
    // Current position in the token array.
    private position: number = 0;
    // Stack to track block nesting for indentation-based blocks
    // Each entry stores the block and the indentation level at which it lives
    private blockStack: { block: BlockNode; indent: number }[] = [];
    // Track the last block seen at each indentation level to connect `.next` chains correctly
    private lastAtIndent: (BlockNode | null)[] = [];
    // Current indentation level
    private indentLevel: number = 0;

    // Constructor: Initializes the Parser with the token array.
    constructor(tokens: Token[]) {
        this.tokens = tokens;
    }

    // Get the current token
    private get current(): Token {
        return this.tokens[this.position];
    }

    // Check if we've reached the end of the tokens
    private isAtEnd(): boolean {
        return this.position >= this.tokens.length || this.current.type === TokenType.EOF;
    }

    // Advance to the next token and return the previous one
    private advance(): Token {
        const token = this.current;
        if (!this.isAtEnd()) {
            this.position++;
        }
        return token;
    }

    // Look ahead at the next token without advancing
    private peek(offset: number = 1): Token | null {
        if (this.position + offset >= this.tokens.length) {
            return null;
        }
        return this.tokens[this.position + offset];
    }

    // Check if the current token's type matches the expected type
    private match(type: TokenType): boolean {
        if (this.isAtEnd()) return false;
        return this.current.type === type;
    }

    // Consume a token if it matches the expected type, otherwise throw an error
    private consume(type: TokenType, errorMessage: string): Token {
        if (this.match(type)) {
            return this.advance();
        }
        throw new Error(`${errorMessage} at line ${this.current.line}, column ${this.current.column}`);
    }

    // Skip newlines and comments
    private skipIrrelevant(): void {
        while (!this.isAtEnd() && (this.match(TokenType.NEWLINE) || this.match(TokenType.COMMENT))) {
            this.advance();
        }
    }

    // parse: Main method to generate the AST (Program).
    parse(): Program {
        // Initialize the program structure with empty scripts, variables, and lists.
        const program: Program = {
            scripts: [],
            variables: new Map(),
            lists: new Map(),
        };

        // Skip any initial newlines or comments
        this.skipIrrelevant();

        // Loop through the tokens until we reach the end.
        while (!this.isAtEnd()) {
            try {
                // Skip any additional newlines or comments
                this.skipIrrelevant();

                if (this.isAtEnd()) break;

                // Check for declarations and scripts
                if (this.match(TokenType.KEYWORD)) {
                    const keyword = this.current.value;

                    if (keyword === "when") {
                        // Parse a script starting with 'when'
                        const script = this.parseScript();
                        program.scripts.push(script);
                    } else if (keyword === "var" || keyword === "variable") {
                        // Parse variable declaration
                        this.parseVariableDeclaration(program);
                    } else if (keyword === "list") {
                        // Parse list declaration
                        this.parseListDeclaration(program);
                    } else if (keyword === "define") {
                        // Parse custom block definition
                        this.parseCustomBlockDefinition(program);
                    } else {
                        // Unknown keyword or statement at top level
                        this.advance();
                    }
                } else {
                    // Skip unknown tokens at top level
                    this.advance();
                }
            } catch (error) {
                // Log the error and try to recover
                console.error(error);
                this.synchronize();
            }
        }

        // Return the constructed program (AST).
        return program;
    }

    // synchronize: Skip tokens until a safe point to continue parsing
    private synchronize(): void {
        this.advance();

        while (!this.isAtEnd()) {
            // Skip until we find a keyword that could start a new statement
            if (
                this.current.type === TokenType.KEYWORD &&
                ["when", "var", "variable", "list", "define"].includes(this.current.value)
            ) {
                return;
            }

            // Skip until we find a newline, which might indicate a new statement
            if (this.current.type === TokenType.NEWLINE) {
                this.advance();
                return;
            }

            this.advance();
        }
    }

    // parseScript: Parses a script (sequence of blocks).
    private parseScript(): Script {
        // Create a new script with an empty array of blocks
        const script: Script = {
            blocks: [],
        };

        // Reset the block stack for this script
        this.blockStack = [];
        this.lastAtIndent = [];
        this.indentLevel = 0;

        // Parse the first block (usually an event block)
        const firstBlock = this.parseBlock();
        if (firstBlock) {
            script.blocks.push(firstBlock);
            // track the top-level block with indent 0
            this.blockStack.push({ block: firstBlock, indent: 0 });
            this.lastAtIndent[0] = firstBlock;

            // Parse subsequent blocks
            this.parseScriptBlocks(script);
        }

        // Return the script with its blocks.
        return script;
    }

    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    private parseScriptBlocks(script: Script): void {
        // Continue parsing blocks until we reach the end of the script
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Check for indentation changes
            if (this.match(TokenType.INDENT)) {
                // Increase indentation level and consume the INDENT token
                this.indentLevel++;
                this.advance();

                // If there is no parent block on the stack, nothing to attach to
                if (!this.blockStack.length) {
                    break;
                }

                const parentEntry = this.blockStack[this.blockStack.length - 1];
                const parentBlock = parentEntry.block;

                // Parse the first nested block in this indented region
                const firstNestedBlock = this.parseBlock();
                if (!firstNestedBlock) {
                    continue;
                }

                // Attach the nested sequence to the parent block
                // For event blocks (e.g., 'when') attach as `next` so handlers execute sequentially
                if (parentBlock.type === "event" || parentBlock.name === "when") {
                    parentBlock.next = firstNestedBlock;
                } else {
                    // Common convention: args[0] is condition/count, body goes at next index
                    parentBlock.args.push(firstNestedBlock);
                }

                // Track the first block at this indent level and push onto the stack
                this.lastAtIndent[this.indentLevel] = firstNestedBlock;
                this.blockStack.push({ block: firstNestedBlock, indent: this.indentLevel });

                // Parse additional sibling blocks at the same indentation level
                let currentBlock = firstNestedBlock;
                while (!this.isAtEnd() && !this.match(TokenType.DEDENT) && !this.match(TokenType.INDENT)) {
                    this.skipIrrelevant();
                    if (this.isAtEnd() || this.match(TokenType.DEDENT) || this.match(TokenType.INDENT)) break;

                    if (this.isBlockStart()) {
                        const nextBlock = this.parseBlock();
                        if (nextBlock) {
                            currentBlock.next = nextBlock;
                            currentBlock = nextBlock;
                            // update the last block at this indent and push onto stack
                            this.lastAtIndent[this.indentLevel] = nextBlock;
                            this.blockStack.push({ block: nextBlock, indent: this.indentLevel });
                        }
                    } else {
                        this.advance();
                    }
                }
            } else if (this.match(TokenType.DEDENT)) {
                // Consume DEDENT and reduce indent level
                this.advance();
                this.indentLevel = Math.max(0, this.indentLevel - 1);

                // Pop any blocks that belonged to deeper indentation levels
                while (this.blockStack.length && this.blockStack[this.blockStack.length - 1].indent > this.indentLevel) {
                    this.blockStack.pop();
                }
                // Clear lastAtIndent entries deeper than current indent
                for (let i = this.lastAtIndent.length - 1; i > this.indentLevel; i--) {
                    this.lastAtIndent[i] = null;
                }

                // If we've reduced indentation below our starting level, we're done with this script
                if (this.indentLevel <= 0) {
                    this.indentLevel = 0;
                    // keep the top-level block on the stack but exit if at base
                    if (this.blockStack.length <= 1) break;
                }
            } else if (this.isBlockStart()) {
                // Parse a new block at the current indentation level
                const block = this.parseBlock();
                if (block) {
                    // If there is an existing block at this indent, connect as `.next`
                    const last = this.lastAtIndent[this.indentLevel];
                    if (last) {
                        last.next = block;
                    } else {
                        // This is a top-level block in the script for this indent
                        script.blocks.push(block);
                    }

                    // Track this block as the last at this indent and push onto the stack
                    this.lastAtIndent[this.indentLevel] = block;
                    this.blockStack.push({ block, indent: this.indentLevel });
                }
            } else {
                // Skip tokens that don't start a block
                this.advance();
            }
        }
    }

    // isBlockStart: Checks if the current token can start a block
    private isBlockStart(): boolean {
        if (!this.match(TokenType.KEYWORD)) return false;

        const blockStartKeywords = [
            // Events
            "when",
            "broadcast",
            "receive",
            
            // Motion
            "move",
            "turn",
            "go",
            "goto",
            "glide",
            "point",
            
            // Looks
            "say",
            "think",
            "show",
            "hide",
            "switch",
            "change",
            "set",
            "clear",
            "next",
            
            // Sound
            "play",
            "start",
            "stop",
            
            // Control
            "wait",
            "repeat",
            "forever",
            "if",
            "else",
            "until",
            "create",
            "delete",
            
            // Sensing
            "ask",
            "touching",
            "reset",
            
            // Variables
            "add",
            "insert",
            "replace",
            
            // Operators (rarely start blocks)
            "join",
            "pick",
            
            // Pen
            "pen",
            "stamp",
            "erase",
            
            // Custom
            "define",
        ];

        return blockStartKeywords.includes(this.current.value);
    }

    // parseBlock: Parses a single block.
    private parseBlock(): BlockNode | null {
        // Check if the current token can start a block
        if (!this.isBlockStart()) {
            return null;
        }

        // Get the block name (keyword)
        let blockKeyword = this.consume(TokenType.KEYWORD, "Expected block keyword").value;

        // Normalize multi-word block keywords (e.g., 'turn right' -> 'turnRight', 'repeat until' -> 'repeatUntil')
        if (blockKeyword === "turn") {
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "right" || this.current.value === "left")) {
                const dir = this.advance().value;
                blockKeyword = dir === "right" ? "turnRight" : "turnLeft";
            }
        } else if (blockKeyword === "repeat") {
            // support 'repeat until' as a combined keyword
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "until") {
                this.advance();
                blockKeyword = "repeatUntil";
            }
        } else if (blockKeyword === "create") {
            // Handle "create clone of myself" or "create clone of <sprite>"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "clone") {
                this.advance(); // consume "clone"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "of") {
                    this.advance(); // consume "of"
                }
                blockKeyword = "createClone";
            }
        } else if (blockKeyword === "delete") {
            // Handle "delete this clone"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "this") {
                this.advance(); // consume "this"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "clone") {
                    this.advance(); // consume "clone"
                    blockKeyword = "deleteThisClone";
                }
            }
        } else if (blockKeyword === "when") {
            // Handle multi-word "when" keywords like "when I receive" and "when I start as a clone"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "I") {
                this.advance(); // Consume 'I'
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                    const nextWord = this.current.value as string;
                    if (nextWord === "receive") {
                        this.advance(); // Consume 'receive'
                        blockKeyword = "whenIReceive";
                    } else if (nextWord === "start") {
                        this.advance(); // Consume 'start'
                        // Optionally consume "as a clone"
                        this.skipIrrelevant();
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "as") {
                            this.advance(); // Consume 'as'
                            this.skipIrrelevant();
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "a") {
                                this.advance(); // Consume 'a'
                                this.skipIrrelevant();
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "clone") {
                                    this.advance(); // Consume 'clone'
                                }
                            }
                        }
                        blockKeyword = "whenIStartAsClone";
                    }
                }
            }
        }

        // Determine the block type based on the keyword
        const blockType: BlockType = this.determineBlockType(blockKeyword);

        // Parse block arguments
        const args: (string | number | BlockNode)[] = this.parseBlockArguments();

        // Create the block node
        const block: BlockNode = {
            type: blockType,
            name: blockKeyword,
            args,
        };

        // Handle special case for if-else blocks
        if (blockKeyword === "if") {
            // Check for an else clause
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && this.current.value === "else") {
                this.advance(); // Consume 'else'

                // Parse the else block
                const elseBlock = this.parseBlock();
                if (elseBlock) {
                    // Add the else block as a special argument
                    block.args.push("else");
                    block.args.push(elseBlock);
                }
            }
        }

        return block;
    }

    // determineBlockType: Determine the type of block based on its keyword
    private determineBlockType(keyword: string): BlockType {
        // Maps common Scratch block keywords to their respective types
        return blockTypeMap[keyword] || "custom";
    }

    // parseBlockArguments: Parse arguments for a block based on its type
    private parseBlockArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];

        // Continue parsing arguments until we hit a new block, indentation change, or end of line
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Stop if we encounter a new block start, indent, or dedent
            if (
                this.match(TokenType.INDENT) ||
                this.match(TokenType.DEDENT) ||
                (this.match(TokenType.KEYWORD) && this.isBlockStart())
            ) {
                break;
            }

            // Parse different types of arguments
            if (this.match(TokenType.STRING)) {
                // String argument
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                // Number argument
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                // Variable or identifier
                args.push(this.advance().value);
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                // Nested expression in parentheses
                args.push(this.parseExpression());
            } else if (this.match(TokenType.BRACKET_OPEN)) {
                // List value in brackets
                const listValues = this.parseListLiteral();
                args.push({
                    type: "operators",
                    name: "list",
                    args: listValues,
                });
            } else if (this.match(TokenType.KEYWORD)) {
                // Keyword argument
                args.push(this.advance().value);
            } else if (this.match(TokenType.OPERATOR)) {
                // Operator
                args.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        return args;
    }

    // parseExpression: Parse a parenthesized expression
    private parseExpression(): BlockNode {
        this.consume(TokenType.PARENTHESIS_OPEN, "Expected '('");

        const args: (string | number | BlockNode)[] = [];

        // Parse the expression until we hit the closing parenthesis
        while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
            if (this.match(TokenType.STRING)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.OPERATOR)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                args.push(this.parseExpression());
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.PARENTHESIS_CLOSE, "Expected ')'");

        // Create an operator block for the expression
        return {
            type: "operators",
            name: "expression",
            args,
        };
    }

    // parseListLiteral: Parse a list literal [value1, value2, ...]
    private parseListLiteral(): (string | number)[] {
        this.consume(TokenType.BRACKET_OPEN, "Expected '['");

        const values: (string | number)[] = [];

        // Parse list values until we hit the closing bracket
        while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
            // Skip commas between values
            if (this.match(TokenType.COMMA)) {
                this.advance();
                continue;
            }

            if (this.match(TokenType.STRING)) {
                values.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                values.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                values.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.BRACKET_CLOSE, "Expected ']'");

        return values;
    }

    // parseVariableDeclaration: Parses a variable declaration.
    private parseVariableDeclaration(program: Program): void {
        // Skip 'var' or 'variable' keyword
        this.advance();

        // Expect a variable name (identifier)
        const variableName = this.consume(TokenType.IDENTIFIER, "Expected variable name").value;

        // Check for initial value assignment
        let initialValue: string | number | object | undefined | null = 0; // Default value

        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse the initial value
            if (this.match(TokenType.NUMBER)) {
                initialValue = parseFloat(this.advance().value);
            } else if (this.match(TokenType.STRING)) {
                initialValue = this.advance().value;
            } else if (this.match(TokenType.IDENTIFIER)) {
                initialValue = this.advance().value;
            } else {
                // Skip invalid tokens
                this.advance();
            }
        }

        // Add the variable to the program
        program.variables.set(variableName, initialValue);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseListDeclaration: Parses a list declaration.
    private parseListDeclaration(program: Program): void {
        // Skip 'list' keyword
        this.advance();

        // Expect a list name (identifier)
        const listName = this.consume(TokenType.IDENTIFIER, "Expected list name").value;

        // Initialize with an empty list
        let listValues: (string | number | object | undefined | null)[] = [];

        // Check for initial values
        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse list initialization
            if (this.match(TokenType.BRACKET_OPEN)) {
                listValues = this.parseListLiteral() as (string | number | object | undefined | null)[];
            }
        }

        // Add the list to the program
        program.lists.set(listName, listValues);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseCustomBlockDefinition: Parse a custom block definition (procedure).
    private parseCustomBlockDefinition(program: Program): void {
        // Skip 'define' keyword
        this.advance();

        // Expect the block name (identifier)
        const blockName = this.consume(TokenType.IDENTIFIER, "Expected custom block name").value;

        // Parse parameter list if available
        const parameters: string[] = [];

        if (!this.isAtEnd() && this.match(TokenType.PARENTHESIS_OPEN)) {
            this.advance(); // Skip '('

            // Parse parameters until closing parenthesis
            while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
                if (this.match(TokenType.IDENTIFIER)) {
                    parameters.push(this.advance().value);
                } else if (this.match(TokenType.COMMA)) {
                    this.advance(); // Skip commas between parameters
                } else {
                    this.advance(); // Skip other tokens
                }
            }

            if (!this.isAtEnd()) {
                this.advance(); // Skip ')'
            }
        }

        // Create a custom block script
        const customScript: Script = {
            blocks: [],
        };

        // Parse the custom block body
        this.skipIrrelevant();

        if (!this.isAtEnd() && this.match(TokenType.INDENT)) {
            this.advance(); // Skip indent

            // Reset indentation for parsing this block
            const oldIndentLevel = this.indentLevel;
            this.indentLevel = 1;

            // Parse the body of the custom block
            this.parseScriptBlocks(customScript);

            // Restore indentation level
            this.indentLevel = oldIndentLevel;
        }

        // Add this custom block to the program
        // For now, we'll add it as a special script with metadata
        customScript.blocks.unshift({
            type: "custom",
            name: "define",
            args: [blockName, ...parameters],
        });

        program.scripts.push(customScript);
    }
}
