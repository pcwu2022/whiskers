// Parser: Convert tokens to an AST (Abstract Syntax Tree)
// This class, Parser, takes an array of tokens generated by the Lexer and constructs
// an Abstract Syntax Tree (AST). The AST represents the structure of the program,
// making it easier to analyze and execute.

import { Program, BlockNode, Script, BlockType, Token, TokenType, blockTypeMap, CompilerError, ErrorCodes } from "@/types/compilerTypes";
import { Lexer } from "./lexer";
// import { SimpleDebugger } from "./debugger";

// const d: SimpleDebugger = new SimpleDebugger();

// Built-in reporter names that cannot be used as user-defined variables
// These are reserved because they are Scratch's built-in reporter blocks
export const BUILTIN_REPORTERS = new Set([
    // Motion reporters
    "x", "y", "x position", "y position", "direction",
    // Looks reporters
    "size", "costume number", "costume name", "backdrop number", "backdrop name",
    // Sound reporters
    "volume",
    // Sensing reporters
    "timer", "answer", "mouse x", "mouse y", "loudness", "username",
    "current year", "current month", "current date", "current day of week",
    "current hour", "current minute", "current second", "days since 2000"
]);

export class Parser {
    // Array of tokens to be parsed.
    private tokens: Token[];
    // Current position in the token array.
    private position: number = 0;
    // Stack to track block nesting for indentation-based blocks
    // Each entry stores the block and the indentation level at which it lives
    private blockStack: { block: BlockNode; indent: number }[] = [];
    // Track the last block seen at each indentation level to connect `.next` chains correctly
    private lastAtIndent: (BlockNode | null)[] = [];
    // Current indentation level
    private indentLevel: number = 0;
    // Collection of errors found during parsing
    private errors: CompilerError[] = [];
    // Declared variables (for undeclared variable checking)
    private declaredVariables: Set<string> = new Set();
    // Declared lists
    private declaredLists: Set<string> = new Set();

    // Constructor: Initializes the Parser with the token array.
    constructor(tokens: Token[]) {
        this.tokens = tokens;
    }

    // Get collected errors
    getErrors(): CompilerError[] {
        return this.errors;
    }

    // Add an error
    private addError(code: string, message: string, token?: Token, suggestion?: string, endColumn?: number): void {
        const line = token?.line || this.current?.line || 1;
        const column = token?.column || this.current?.column || 1;
        this.errors.push({
            code,
            message,
            line,
            column,
            endColumn: endColumn,
            severity: "error",
            suggestion,
        });
    }

    // Check if a C-block has an empty body (no INDENT follows it)
    // If so, emit an error pointing to the 'end' or next token
    private checkCBlockHasBody(block: BlockNode): void {
        if (!this.isCBlock(block.name)) return;
        
        // Save position to look ahead
        const savedPosition = this.position;
        this.skipIrrelevant();
        
        // If next token is not INDENT, the C-block has an empty body
        if (!this.isAtEnd() && !this.match(TokenType.INDENT)) {
            // Find the token to point the error at (usually 'end' keyword)
            let errorToken = this.current;
            
            // Skip any DEDENT tokens to find the actual 'end' or next meaningful token
            const scanPosition = this.position;
            while (!this.isAtEnd() && this.match(TokenType.DEDENT)) {
                this.advance();
            }
            if (!this.isAtEnd() && this.current.type === TokenType.KEYWORD) {
                errorToken = this.current;
            }
            // Restore scan position
            this.position = scanPosition;
            
            // Special message for empty body (usually followed by 'end')
            const isEndKeyword = errorToken.type === TokenType.KEYWORD && errorToken.value === "end";
            const message = isEndKeyword
                ? `Oops! '${block.name}' has nothing inside it. Every block like 'repeat', 'forever', and 'if' needs some code inside to tell the computer what to do.`
                : "This block needs to be one step to the right! Click the start of the line and press 'Tab' to move it. This is called an <i>indent</i>, and it tells the computer that this code belongs inside the block above it.";
            
            const suggestion = isEndKeyword
                ? `Add some code between '${block.name}' and 'end'. For example:\n   ${block.name}${block.args.length ? ' ' + block.args[0] : ''}\n       say "Hello!"\n   end`
                : `The code after '${block.name}' should be indented (moved to the right) so the computer knows it belongs inside this block.`;
            
            this.addError(
                ErrorCodes.MISSING_INDENT,
                message,
                errorToken,
                suggestion,
                (errorToken.column || 1) + 1  // Underline just the first character
            );
        }
        
        // Restore position
        this.position = savedPosition;
    }

    /**
     * Parse the body of an else block
     * Handles nested if-else structures by recursively parsing blocks
     * Returns an array of parsed blocks
     */
    private parseElseBody(): BlockNode[] {
        const blocks: BlockNode[] = [];
        const startIndent = this.indentLevel;
        let currentBlock: BlockNode | null = null;
        
        // Track blocks at this indent level for nested if-else handling
        const localBlockStack: { block: BlockNode; indent: number }[] = [];
        
        while (!this.isAtEnd()) {
            this.skipIrrelevant();
            if (this.isAtEnd()) break;
            
            // Check if we've dedented out of the else body
            if (this.match(TokenType.DEDENT)) {
                this.advance();
                this.indentLevel = Math.max(0, this.indentLevel - 1);
                
                // Pop blocks from local stack that were deeper
                while (localBlockStack.length && localBlockStack[localBlockStack.length - 1].indent > this.indentLevel) {
                    localBlockStack.pop();
                }
                
                // Check for nested 'else' keyword after DEDENT
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.matchKeyword("else")) {
                    // Find the parent 'if' block in our local stack
                    const parentEntry = localBlockStack.length > 0 ? localBlockStack[localBlockStack.length - 1] : null;
                    if (parentEntry && parentEntry.block.name === "if") {
                        this.advance(); // Consume 'else'
                        parentEntry.block.name = "ifElse";
                        parentEntry.block.elseBody = [];
                        
                        // Check for INDENT (nested else body)
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.INDENT)) {
                            this.indentLevel++;
                            this.advance();
                            // Recursively parse nested else body
                            parentEntry.block.elseBody = this.parseElseBody();
                        }
                        continue;
                    }
                }
                
                // If we've dedented below the starting indent, we're done
                if (this.indentLevel < startIndent) {
                    break;
                }
                continue;
            }
            
            // Handle INDENT - parse nested blocks
            if (this.match(TokenType.INDENT)) {
                this.indentLevel++;
                this.advance();
                
                // Attach nested blocks to the current block
                if (localBlockStack.length > 0) {
                    const parent = localBlockStack[localBlockStack.length - 1].block;
                    const nestedBlock = this.parseBlock();
                    if (nestedBlock) {
                        // Check for nested C-block empty body
                        this.checkCBlockHasBody(nestedBlock);
                        
                        // Attach as body (in args for C-blocks)
                        parent.args.push(nestedBlock);
                        
                        // Track this nested block for potential if-else
                        localBlockStack.push({ block: nestedBlock, indent: this.indentLevel });
                        
                        // Parse sibling blocks at this level
                        let siblingBlock = nestedBlock;
                        while (!this.isAtEnd() && !this.match(TokenType.DEDENT) && !this.match(TokenType.INDENT)) {
                            this.skipIrrelevant();
                            if (this.isAtEnd() || this.match(TokenType.DEDENT) || this.match(TokenType.INDENT)) break;
                            
                            if (this.isBlockStart()) {
                                const nextSibling = this.parseBlock();
                                if (nextSibling) {
                                    this.checkCBlockHasBody(nextSibling);
                                    siblingBlock.next = nextSibling;
                                    siblingBlock = nextSibling;
                                    localBlockStack.push({ block: nextSibling, indent: this.indentLevel });
                                }
                            } else {
                                this.advance();
                            }
                        }
                    }
                }
                continue;
            }
            
            // Parse a block at the current level
            if (this.isBlockStart()) {
                const block = this.parseBlock();
                if (block) {
                    this.checkCBlockHasBody(block);
                    
                    if (currentBlock) {
                        currentBlock.next = block;
                    } else {
                        blocks.push(block);
                    }
                    currentBlock = block;
                    
                    // Track for potential if-else handling
                    localBlockStack.push({ block, indent: this.indentLevel });
                }
            } else if (this.matchKeyword("end")) {
                // 'end' keyword - just skip it
                this.advance();
            } else {
                // Skip unknown tokens
                this.advance();
            }
        }
        
        return blocks;
    }

    // Get the current token
    private get current(): Token {
        return this.tokens[this.position];
    }

    // Check if we've reached the end of the tokens
    private isAtEnd(): boolean {
        return this.position >= this.tokens.length || this.current.type === TokenType.EOF;
    }

    // Advance to the next token and return the previous one
    private advance(): Token {
        const token = this.current;
        if (!this.isAtEnd()) {
            this.position++;
        }
        return token;
    }

    // Look ahead at the next token without advancing
    private peek(offset: number = 1): Token | null {
        if (this.position + offset >= this.tokens.length) {
            return null;
        }
        return this.tokens[this.position + offset];
    }

    // Check if the current token's type matches the expected type
    private match(type: TokenType): boolean {
        if (this.isAtEnd()) return false;
        return this.current.type === type;
    }

    // Check if the current token matches the type and value
    // This helper avoids TypeScript type narrowing issues
    private matchKeyword(value: string): boolean {
        if (this.isAtEnd()) return false;
        return this.current.type === TokenType.KEYWORD && this.current.value === value;
    }

    // Consume a token if it matches the expected type, otherwise throw an error
    private consume(type: TokenType, errorMessage: string): Token {
        if (this.match(type)) {
            return this.advance();
        }
        throw new Error(`${errorMessage} at line ${this.current.line}, column ${this.current.column}`);
    }

    // Skip newlines and comments
    private skipIrrelevant(): void {
        while (!this.isAtEnd() && (this.match(TokenType.NEWLINE) || this.match(TokenType.COMMENT))) {
            this.advance();
        }
    }

    // parse: Main method to generate the AST (Program).
    parse(): Program {
        // Initialize the program structure with empty scripts, variables, and lists.
        const program: Program = {
            scripts: [],
            variables: new Map(),
            lists: new Map(),
        };

        // Reset declared variables and lists
        this.declaredVariables.clear();
        this.declaredLists.clear();
        
        // Add built-in variables (sensing reporters, etc.)
        // These are reserved and cannot be used as user-defined variable names
        BUILTIN_REPORTERS.forEach(v => this.declaredVariables.add(v));

        // Skip any initial newlines or comments
        this.skipIrrelevant();

        // First pass: collect all variable and list declarations
        const savedPosition = this.position;
        while (!this.isAtEnd()) {
            this.skipIrrelevant();
            if (this.isAtEnd()) break;

            if (this.match(TokenType.KEYWORD)) {
                const keyword = this.current.value;
                if (keyword === "var" || keyword === "variable") {
                    this.advance(); // Skip 'var'
                    // Check for identifier OR keyword (for cases like "var timer")
                    if (this.match(TokenType.IDENTIFIER)) {
                        this.declaredVariables.add(this.current.value);
                    } else if (this.match(TokenType.KEYWORD)) {
                        // If it's a keyword that's a built-in reporter, we'll error later
                        // Otherwise it could be a user variable with a keyword name
                        this.declaredVariables.add(this.current.value);
                    }
                } else if (keyword === "list") {
                    this.advance(); // Skip 'list'
                    if (this.match(TokenType.IDENTIFIER)) {
                        this.declaredLists.add(this.current.value);
                    }
                }
            }
            this.advance();
        }
        
        // Reset position for actual parsing
        this.position = savedPosition;

        // Skip any initial newlines or comments
        this.skipIrrelevant();

        // Loop through the tokens until we reach the end.
        while (!this.isAtEnd()) {
            try {
                // Skip any additional newlines or comments
                this.skipIrrelevant();

                if (this.isAtEnd()) break;

                // Check for declarations and scripts
                if (this.match(TokenType.KEYWORD)) {
                    const keyword = this.current.value;

                    if (keyword === "when") {
                        // Parse a script starting with 'when'
                        const script = this.parseScript();
                        program.scripts.push(script);
                    } else if (keyword === "var" || keyword === "variable") {
                        // Parse variable declaration
                        this.parseVariableDeclaration(program);
                    } else if (keyword === "list") {
                        // Parse list declaration
                        this.parseListDeclaration(program);
                    } else if (keyword === "define") {
                        // Parse custom block definition
                        this.parseCustomBlockDefinition(program);
                    } else {
                        // Unknown keyword or statement at top level
                        this.advance();
                    }
                } else {
                    // Skip unknown tokens at top level
                    this.advance();
                }
            } catch (error) {
                // Log the error and try to recover
                console.error(error);
                this.synchronize();
            }
        }

        // Return the constructed program (AST).
        return program;
    }

    // synchronize: Skip tokens until a safe point to continue parsing
    private synchronize(): void {
        this.advance();

        while (!this.isAtEnd()) {
            // Skip until we find a keyword that could start a new statement
            if (
                this.current.type === TokenType.KEYWORD &&
                ["when", "var", "variable", "list", "define"].includes(this.current.value)
            ) {
                return;
            }

            // Skip until we find a newline, which might indicate a new statement
            if (this.current.type === TokenType.NEWLINE) {
                this.advance();
                return;
            }

            this.advance();
        }
    }

    // parseScript: Parses a script (sequence of blocks).
    private parseScript(): Script {
        // Create a new script with an empty array of blocks
        const script: Script = {
            blocks: [],
        };

        // Reset the block stack for this script
        this.blockStack = [];
        this.lastAtIndent = [];
        this.indentLevel = 0;

        // Parse the first block (usually an event block)
        const firstBlock = this.parseBlock();
        if (firstBlock) {
            script.blocks.push(firstBlock);
            // track the top-level block with indent 0
            this.blockStack.push({ block: firstBlock, indent: 0 });
            this.lastAtIndent[0] = firstBlock;

            // Parse subsequent blocks
            this.parseScriptBlocks(script);
        }

        // Return the script with its blocks.
        return script;
    }

    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    // parseScriptBlocks: Parse all blocks in a script after the first block
    private parseScriptBlocks(script: Script): void {
        // Continue parsing blocks until we reach the end of the script
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Check for indentation changes
            if (this.match(TokenType.INDENT)) {
                // Increase indentation level and consume the INDENT token
                this.indentLevel++;
                this.advance();

                // If there is no parent block on the stack, nothing to attach to
                if (!this.blockStack.length) {
                    break;
                }

                const parentEntry = this.blockStack[this.blockStack.length - 1];
                const parentBlock = parentEntry.block;

                // Parse the first nested block in this indented region
                const firstNestedBlock = this.parseBlock();
                if (!firstNestedBlock) {
                    continue;
                }

                // Check if this is a C-block with an empty body
                this.checkCBlockHasBody(firstNestedBlock);

                // Attach the nested sequence to the parent block
                // For event blocks (e.g., 'when') attach as `next` so handlers execute sequentially
                if (parentBlock.type === "event" || parentBlock.name === "when") {
                    parentBlock.next = firstNestedBlock;
                } else {
                    // Common convention: args[0] is condition/count, body goes at next index
                    parentBlock.args.push(firstNestedBlock);
                }

                // Track the first block at this indent level and push onto the stack
                this.lastAtIndent[this.indentLevel] = firstNestedBlock;
                this.blockStack.push({ block: firstNestedBlock, indent: this.indentLevel });

                // Parse additional sibling blocks at the same indentation level
                let currentBlock = firstNestedBlock;
                while (!this.isAtEnd() && !this.match(TokenType.DEDENT) && !this.match(TokenType.INDENT)) {
                    this.skipIrrelevant();
                    if (this.isAtEnd() || this.match(TokenType.DEDENT) || this.match(TokenType.INDENT)) break;

                    if (this.isBlockStart()) {
                        const nextBlock = this.parseBlock();
                        if (nextBlock) {
                            // Check if this is a C-block with an empty body
                            this.checkCBlockHasBody(nextBlock);
                            
                            currentBlock.next = nextBlock;
                            currentBlock = nextBlock;
                            // update the last block at this indent and push onto stack
                            this.lastAtIndent[this.indentLevel] = nextBlock;
                            this.blockStack.push({ block: nextBlock, indent: this.indentLevel });
                        }
                    } else {
                        this.advance();
                    }
                }
            } else if (this.match(TokenType.DEDENT)) {
                // Consume DEDENT and reduce indent level
                this.advance();
                this.indentLevel = Math.max(0, this.indentLevel - 1);

                // Pop any blocks that belonged to deeper indentation levels
                while (this.blockStack.length && this.blockStack[this.blockStack.length - 1].indent > this.indentLevel) {
                    this.blockStack.pop();
                }
                // Clear lastAtIndent entries deeper than current indent
                for (let i = this.lastAtIndent.length - 1; i > this.indentLevel; i--) {
                    this.lastAtIndent[i] = null;
                }
                
                // Check for 'else' keyword after DEDENT - this handles if-else blocks
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.matchKeyword("else")) {
                    // Find the parent 'if' block on the stack
                    const parentEntry = this.blockStack.length > 0 ? this.blockStack[this.blockStack.length - 1] : null;
                    if (parentEntry && parentEntry.block.name === "if") {
                        this.advance(); // Consume 'else'
                        
                        // Change the block type to ifElse
                        parentEntry.block.name = "ifElse";
                        
                        // Initialize else body
                        parentEntry.block.elseBody = [];
                        
                        // Check for INDENT (else body)
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.match(TokenType.INDENT)) {
                            this.indentLevel++;
                            this.advance();
                            
                            // Parse else body blocks using recursive approach
                            const elseBodyBlocks = this.parseElseBody();
                            parentEntry.block.elseBody = elseBodyBlocks;
                        }
                        continue; // Continue the main loop
                    }
                }

                // If we've reduced indentation below our starting level, we're done with this script
                if (this.indentLevel <= 0) {
                    this.indentLevel = 0;
                    // keep the top-level block on the stack but exit if at base
                    if (this.blockStack.length <= 1) break;
                }
            } else if (this.isBlockStart()) {
                // Parse a new block at the current indentation level
                const block = this.parseBlock();
                if (block) {
                    // Check if this is a C-block with an empty body
                    this.checkCBlockHasBody(block);
                    
                    // If there is an existing block at this indent, connect as `.next`
                    const last = this.lastAtIndent[this.indentLevel];
                    if (last) {
                        last.next = block;
                    } else {
                        // This is a top-level block in the script for this indent
                        script.blocks.push(block);
                    }

                    // Track this block as the last at this indent and push onto the stack
                    this.lastAtIndent[this.indentLevel] = block;
                    this.blockStack.push({ block, indent: this.indentLevel });
                }
            } else {
                // Skip tokens that don't start a block
                this.advance();
            }
        }
    }

    // isBlockStart: Checks if the current token can start a block
    private isBlockStart(): boolean {
        if (!this.match(TokenType.KEYWORD)) return false;

        const blockStartKeywords = [
            // Events
            "when",
            "broadcast",
            "receive",
            
            // Motion
            "move",
            "turn",
            "go",
            "goto",
            "glide",
            "point",
            
            // Looks
            "say",
            "think",
            "show",
            "hide",
            "switch",
            "change",
            "set",
            "clear",
            "next",
            
            // Sound
            "play",
            "start",
            "stop",
            
            // Control
            "wait",
            "repeat",
            "forever",
            "if",
            "else",
            "until",
            "create",
            "delete",
            
            // Sensing
            "ask",
            "touching",
            "reset",
            
            // Variables
            "var",
            "variable",
            "add",
            "insert",
            "replace",
            
            // Operators (rarely start blocks)
            "join",
            "pick",
            
            // Pen
            "pen",
            "stamp",
            "erase",
            
            // Custom
            "define",
        ];

        return blockStartKeywords.includes(this.current.value);
    }

    // parseBlock: Parses a single block.
    private parseBlock(): BlockNode | null {
        // Check if the current token can start a block
        if (!this.isBlockStart()) {
            return null;
        }

        // Get the block name (keyword)
        let blockKeyword = this.consume(TokenType.KEYWORD, "Expected block keyword").value;

        // Normalize multi-word block keywords (e.g., 'turn right' -> 'turnRight', 'repeat until' -> 'repeatUntil')
        if (blockKeyword === "turn") {
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "right" || this.current.value === "left")) {
                const dir = this.advance().value;
                blockKeyword = dir === "right" ? "turnRight" : "turnLeft";
            }
        } else if (blockKeyword === "go") {
            // Handle "go to x: y:", "go to random position", "go to mouse-pointer", "go to front/back layer"
            // Also handle "go back N layers" and "go forward N layers"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const firstWord = this.current.value as string;
                
                if (firstWord === "to") {
                    this.advance(); // Consume 'to'
                    this.skipIrrelevant();
                    
                    // Check what follows "go to"
                    if (!this.isAtEnd()) {
                        if (this.match(TokenType.KEYWORD)) {
                            const nextWord = this.current.value as string;
                            if (nextWord === "x" || nextWord === "x:") {
                                blockKeyword = "goToXY";
                            } else if (nextWord === "random") {
                                this.advance(); // Consume 'random'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.matchKeyword("position")) {
                                    this.advance(); // Consume 'position'
                                }
                                blockKeyword = "goToRandom";
                            } else if (nextWord === "mouse-pointer") {
                                this.advance(); // Consume 'mouse-pointer'
                                blockKeyword = "goToMouse";
                            } else if (nextWord === "front") {
                                this.advance(); // Consume 'front'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.matchKeyword("layer")) {
                                    this.advance(); // Consume 'layer'
                                }
                                blockKeyword = "goToFront";
                            } else if (nextWord === "back") {
                                this.advance(); // Consume 'back'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.matchKeyword("layer")) {
                                    this.advance(); // Consume 'layer'
                                }
                                blockKeyword = "goToBack";
                            } else {
                                // go to "SpriteName"
                                blockKeyword = "goToSprite";
                            }
                        } else if (this.match(TokenType.STRING)) {
                            // go to "SpriteName"
                            blockKeyword = "goToSprite";
                        } else {
                            blockKeyword = "goToXY";
                        }
                    }
                } else if (firstWord === "back") {
                    // "go back N layers" - looks block
                    this.advance(); // Consume 'back'
                    blockKeyword = "goBackLayers";
                    // The number will be parsed as an argument
                } else if (firstWord === "forward") {
                    // "go forward N layers" - looks block
                    this.advance(); // Consume 'forward'
                    blockKeyword = "goForwardLayers";
                    // The number will be parsed as an argument
                }
            }
        } else if (blockKeyword === "glide") {
            // Handle "glide N secs to x: y:" or "glide N secs to random position" etc
            blockKeyword = "glide";
        } else if (blockKeyword === "point") {
            // Handle "point in direction N" or "point towards X"
            this.skipIrrelevant();;
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "in") {
                    this.advance(); // Consume 'in'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("direction")) {
                        this.advance(); // Consume 'direction'
                    }
                    blockKeyword = "pointInDirection";
                } else if (nextWord === "towards") {
                    this.advance(); // Consume 'towards'
                    blockKeyword = "pointTowards";
                }
            }
        } else if (blockKeyword === "set") {
            // Handle "set x to", "set y to", "set size to", "set rotation style", "set pen color/size"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "x") {
                    this.advance(); // Consume 'x'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setX";
                } else if (nextWord === "y") {
                    this.advance(); // Consume 'y'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setY";
                } else if (nextWord === "size") {
                    this.advance(); // Consume 'size'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setSize";
                } else if (nextWord === "rotation") {
                    this.advance(); // Consume 'rotation'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("style")) {
                        this.advance(); // Consume 'style'
                    }
                    blockKeyword = "setRotationStyle";
                } else if (nextWord === "pen") {
                    this.advance(); // Consume 'pen'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const penProp = this.current.value as string;
                        if (penProp === "color") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.matchKeyword("to")) {
                                this.advance();
                            }
                            blockKeyword = "setPenColor";
                        } else if (penProp === "size") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.matchKeyword("to")) {
                                this.advance();
                            }
                            blockKeyword = "setPenSize";
                        }
                    }
                } else if (nextWord === "volume") {
                    this.advance(); // Consume 'volume'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // Consume 'to'
                    }
                    blockKeyword = "setVolume";
                } else {
                    // set variable to value - check for effect names
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    if (effectNames.includes(nextWord)) {
                        this.advance(); // Consume effect name
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("effect")) {
                            this.advance(); // Consume 'effect'
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.matchKeyword("to")) {
                                this.advance(); // Consume 'to'
                            }
                        }
                        blockKeyword = "setEffect";
                    } else {
                        // set variable to value
                        blockKeyword = "setVariable";
                    }
                }
            } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
                // set <variableName> to <value> - the variable name is an IDENTIFIER
                blockKeyword = "setVariable";
            }
        } else if (blockKeyword === "change") {
            // Handle "change x by", "change y by", "change size by", "change effect by", "change pen size by", "change volume by"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "x") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("by")) {
                        this.advance();
                    }
                    blockKeyword = "changeX";
                } else if (nextWord === "y") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("by")) {
                        this.advance();
                    }
                    blockKeyword = "changeY";
                } else if (nextWord === "size") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("by")) {
                        this.advance();
                    }
                    blockKeyword = "changeSize";
                } else if (nextWord === "pen") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const penProp = this.current.value as string;
                        if (penProp === "size") {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.matchKeyword("by")) {
                                this.advance();
                            }
                            blockKeyword = "changePenSize";
                        }
                    }
                } else if (nextWord === "volume") {
                    this.advance();
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("by")) {
                        this.advance();
                    }
                    blockKeyword = "changeVolume";
                } else {
                    // Check for effects
                    const effectNames = ["color", "fisheye", "whirl", "pixelate", "mosaic", "brightness", "ghost"];
                    if (effectNames.includes(nextWord)) {
                        this.advance();
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("effect")) {
                            this.advance();
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.matchKeyword("by")) {
                                this.advance();
                            }
                        }
                        blockKeyword = "changeEffect";
                    } else {
                        // change variable by
                        blockKeyword = "changeVariable";
                    }
                }
            } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
                // change <variableName> by <value> - the variable name is an IDENTIFIER
                blockKeyword = "changeVariable";
            }
        } else if (blockKeyword === "repeat") {
            // support 'repeat until' as a combined keyword
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("until")) {
                this.advance();
                blockKeyword = "repeatUntil";
            }
        } else if (blockKeyword === "wait") {
            // support 'wait until' as a combined keyword
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("until")) {
                this.advance();
                blockKeyword = "waitUntil";
            }
        } else if (blockKeyword === "switch") {
            // Handle "switch costume to <name>" or "switch backdrop to <name>"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "costume") {
                    this.advance(); // consume "costume"
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // consume "to"
                    }
                    blockKeyword = "switchCostume";
                } else if (nextWord === "backdrop") {
                    this.advance(); // consume "backdrop"
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("to")) {
                        this.advance(); // consume "to"
                    }
                    blockKeyword = "switchBackdrop";
                }
            }
        } else if (blockKeyword === "next") {
            // Handle "next costume" or "next backdrop"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                if (nextWord === "costume") {
                    this.advance(); // consume "costume"
                    blockKeyword = "nextCostume";
                } else if (nextWord === "backdrop") {
                    this.advance(); // consume "backdrop"
                    blockKeyword = "nextBackdrop";
                }
            }
        } else if (blockKeyword === "create") {
            // Handle "create clone of myself" or "create clone of <sprite>"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("clone")) {
                this.advance(); // consume "clone"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "of") {
                    this.advance(); // consume "of"
                }
                blockKeyword = "createClone";
            }
        } else if (blockKeyword === "delete") {
            // Handle "delete this clone"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("this")) {
                this.advance(); // consume "this"
                this.skipIrrelevant();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as any) === "clone") {
                    this.advance(); // consume "clone"
                    blockKeyword = "deleteThisClone";
                }
            }
        } else if (blockKeyword === "stop") {
            // Handle "stop all", "stop all sounds", "stop this script", "stop other scripts in sprite"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("all")) {
                this.advance(); // consume "all"
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.matchKeyword("sounds")) {
                    this.advance(); // consume "sounds"
                    blockKeyword = "stopAllSounds";
                } else {
                    blockKeyword = "stopAll";
                }
            } else if (!this.isAtEnd() && this.matchKeyword("this")) {
                this.advance(); // consume "this"
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.matchKeyword("script")) {
                    this.advance(); // consume "script"
                }
                blockKeyword = "stopThisScript";
            } else if (!this.isAtEnd() && this.matchKeyword("other")) {
                this.advance(); // consume "other"
                this.skipIrrelevant();
                if (!this.isAtEnd() && this.matchKeyword("scripts")) {
                    this.advance(); // consume "scripts"
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("in")) {
                        this.advance(); // consume "in"
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("sprite")) {
                            this.advance(); // consume "sprite"
                        }
                    }
                }
                blockKeyword = "stopOtherScripts";
            }
        } else if (blockKeyword === "start") {
            // Handle "start sound <name>"
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.matchKeyword("sound")) {
                this.advance(); // consume "sound"
                blockKeyword = "playSound";
            }
        } else if (blockKeyword === "when") {
            // Handle multi-word "when" keywords
            this.skipIrrelevant();
            if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                const nextWord = this.current.value as string;
                
                if (nextWord === "green") {
                    // "when green flag clicked"
                    this.advance(); // Consume 'green'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("flag")) {
                        this.advance(); // Consume 'flag'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("clicked")) {
                            this.advance(); // Consume 'clicked'
                        }
                    }
                    blockKeyword = "whenFlagClicked";
                } else if (nextWord === "this") {
                    // "when this sprite clicked"
                    this.advance(); // Consume 'this'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("sprite")) {
                        this.advance(); // Consume 'sprite'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("clicked")) {
                            this.advance(); // Consume 'clicked'
                        }
                    }
                    blockKeyword = "whenSpriteClicked";
                } else if (nextWord === "I") {
                    this.advance(); // Consume 'I'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD)) {
                        const word = this.current.value as string;
                        if (word === "receive") {
                            this.advance(); // Consume 'receive'
                            blockKeyword = "whenIReceive";
                        } else if (word === "start") {
                            this.advance(); // Consume 'start'
                            // Optionally consume "as a clone"
                            this.skipIrrelevant();
                            if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "as") {
                                this.advance(); // Consume 'as'
                                this.skipIrrelevant();
                                if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "a") {
                                    this.advance(); // Consume 'a'
                                    this.skipIrrelevant();
                                    if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value as string) === "clone") {
                                        this.advance(); // Consume 'clone'
                                    }
                                }
                            }
                            blockKeyword = "whenIStartAsClone";
                        }
                    }
                } else if (nextWord === "flagClicked") {
                    // Support old syntax "when flagClicked" 
                    this.advance();
                    blockKeyword = "whenFlagClicked";
                } else if (nextWord === "flag") {
                    // Support shorthand "when flag clicked" (without "green")
                    this.advance(); // Consume 'flag'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("clicked")) {
                        this.advance(); // Consume 'clicked'
                    }
                    blockKeyword = "whenFlagClicked";
                } else if (nextWord === "spriteClicked") {
                    // Support old syntax "when spriteClicked"
                    this.advance();
                    blockKeyword = "whenSpriteClicked";
                } else if (nextWord === "cloneStarted") {
                    // Support old syntax "when cloneStarted"
                    this.advance();
                    blockKeyword = "whenIStartAsClone";
                } else if (nextWord === "receive") {
                    // Support old syntax "when receive"
                    this.advance();
                    blockKeyword = "whenIReceive";
                } else {
                    // Check for "when X key pressed" pattern
                    // nextWord could be the key name (space, up, left, etc.)
                    // Also handle "up arrow", "down arrow", "left arrow", "right arrow"
                    let keyName = nextWord;
                    this.advance(); // Consume the first key name word
                    this.skipIrrelevant();
                    
                    // Check for "arrow" suffix (e.g., "up arrow key pressed")
                    if (!this.isAtEnd() && this.matchKeyword("arrow")) {
                        this.advance(); // Consume 'arrow'
                        keyName = keyName + " arrow"; // e.g., "up arrow"
                        this.skipIrrelevant();
                    }
                    
                    if (!this.isAtEnd() && this.matchKeyword("key")) {
                        this.advance(); // Consume 'key'
                        this.skipIrrelevant();
                        if (!this.isAtEnd() && this.matchKeyword("pressed")) {
                            this.advance(); // Consume 'pressed'
                            blockKeyword = "whenKeyPressed";
                            // Store the key name by encoding it temporarily
                            blockKeyword = `whenKeyPressed:${keyName}`;
                        }
                    }
                }
            } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
                // Handle "when <identifier> key pressed" (e.g., "when a key pressed")
                const keyName = this.current.value as string;
                this.advance(); // Consume the key name
                this.skipIrrelevant();
                
                if (!this.isAtEnd() && this.matchKeyword("key")) {
                    this.advance(); // Consume 'key'
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("pressed")) {
                        this.advance(); // Consume 'pressed'
                        blockKeyword = `whenKeyPressed:${keyName}`;
                    }
                }
            }
        }

        // Determine the block type based on the keyword
        // Handle special encoded block keywords like "whenKeyPressed:space"
        let keyPressedKey: string | null = null;
        if (blockKeyword.startsWith("whenKeyPressed:")) {
            keyPressedKey = blockKeyword.split(":")[1];
            blockKeyword = "whenKeyPressed";
        }
        
        const blockType: BlockType = this.determineBlockType(blockKeyword);

        // Parse block arguments (with special handling for certain blocks)
        let args: (string | number | BlockNode)[];
        
        if (keyPressedKey !== null) {
            // Key was already captured during "when X key pressed" parsing
            args = [keyPressedKey];
        } else if (blockKeyword === "var" || blockKeyword === "variable") {
            // Check for built-in reporter names and raise error
            args = this.parseVarBlockArguments();
        } else if (blockKeyword === "goToXY") {
            // Parse "x: N y: N" format
            args = this.parseGoToXYArguments();
        } else if (blockKeyword === "glide") {
            // Parse "N secs to x: N y: N" format
            args = this.parseGlideArguments();
        } else if (blockKeyword === "goBackLayers" || blockKeyword === "goForwardLayers") {
            // Parse "N layers" - just get the number, skip "layers"
            args = this.parseLayersArguments();
        } else {
            args = this.parseBlockArguments();
        }

        // Create the block node
        const block: BlockNode = {
            type: blockType,
            name: blockKeyword,
            args,
        };

        // Note: if-else is handled in parseScript when DEDENT is followed by 'else'
        // The else body gets attached when we encounter the 'else' keyword after the if body

        return block;
    }

    // Parse "x: N y: N" arguments for goToXY block
    private parseGoToXYArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Expect "x:" or "x" followed by number, then "y:" or "y" followed by number
        // Pattern: x: 100 y: 50  OR  x 100 y 50
        
        // Skip 'x' or 'x:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "x" || this.current.value === "x:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get x value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0); // default
        }
        
        this.skipIrrelevant();
        
        // Skip 'y' or 'y:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "y" || this.current.value === "y:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get y value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0); // default
        }
        
        return args;
    }
    
    // Parse "N secs to x: N y: N" arguments for glide block
    private parseGlideArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Get duration (number of seconds)
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else {
            args.push(1); // default 1 second
        }
        
        this.skipIrrelevant();
        
        // Skip 'secs' or 'seconds' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && 
            (this.current.value === "secs" || this.current.value === "seconds" || this.current.value === "sec")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip 'to' if present
        if (!this.isAtEnd() && this.matchKeyword("to")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip 'x' or 'x:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "x" || this.current.value === "x:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get x value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0);
        }
        
        this.skipIrrelevant();
        
        // Skip 'y' or 'y:' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && (this.current.value === "y" || this.current.value === "y:")) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Skip ':' if present
        if (!this.isAtEnd() && this.match(TokenType.COLON)) {
            this.advance();
            this.skipIrrelevant();
        }
        
        // Get y value
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else if (!this.isAtEnd() && this.match(TokenType.IDENTIFIER)) {
            args.push(this.advance().value);
        } else {
            args.push(0);
        }
        
        return args;
    }
    
    // Parse "N layers" arguments for go back/forward layers blocks
    private parseLayersArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Get number of layers
        if (!this.isAtEnd() && this.match(TokenType.NUMBER)) {
            args.push(parseFloat(this.advance().value));
        } else {
            args.push(1); // default 1 layer
        }
        
        this.skipIrrelevant();
        
        // Skip 'layers' or 'layer' if present
        if (!this.isAtEnd() && this.match(TokenType.KEYWORD) && 
            (this.current.value === "layers" || this.current.value === "layer")) {
            this.advance();
        }
        
        return args;
    }

    // Parse arguments for var/variable block and check for built-in reporter conflicts
    private parseVarBlockArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        this.skipIrrelevant();
        
        // Get the variable name
        let varName: string | null = null;
        if (this.match(TokenType.IDENTIFIER) || this.match(TokenType.KEYWORD)) {
            const nameToken = this.advance();
            varName = nameToken.value;
            args.push(varName);
            
            // Check if the variable name is a built-in reporter
            if (BUILTIN_REPORTERS.has(varName)) {
                this.addError(
                    ErrorCodes.RESERVED_KEYWORD,
                    `'${varName}' is already a special Whiskers value! You can't use it as a variable name.`,
                    nameToken,
                    ` Names like 'x position', 'timer', and 'answer' are already used by Whiskers. Pick a different name for your variable, like 'myScore' or 'playerName'.`
                );
            }
        }
        
        this.skipIrrelevant();
        
        // Parse initial value if present (var name = value)
        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='
            this.skipIrrelevant();
            
            // Get the value
            if (this.match(TokenType.NUMBER)) {
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.STRING)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.IDENTIFIER)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                args.push(this.parseExpression());
            }
        }
        
        return args;
    }

    // determineBlockType: Determine the type of block based on its keyword
    private determineBlockType(keyword: string): BlockType {
        // Maps common Scratch block keywords to their respective types
        return blockTypeMap[keyword] || "custom";
    }

    // isCBlock: Check if a block keyword represents a C-block (needs indented body)
    private isCBlock(keyword: string): boolean {
        // C-blocks are control structures that wrap other blocks
        const cBlockKeywords = [
            "repeat",
            "repeatUntil",
            "forever",
            "if",
            "ifElse",
            // Hat blocks (events) also need indentation but are handled differently
            "whenFlagClicked",
            "whenKeyPressed",
            "whenSpriteClicked",
            "whenIReceive",
            "whenIStartAsClone",
            // Custom block definitions
            "define",
        ];
        return cBlockKeywords.includes(keyword);
    }

    /**
     * Try to parse an inline operator expression starting with the current keyword.
     * Returns a BlockNode if an operator is recognized, null otherwise.
     * Handles: join, pick random, length of, letter X of, distance to, contains, abs of, sqrt of, etc.
     */
    private tryParseInlineOperator(): BlockNode | null {
        if (!this.match(TokenType.KEYWORD)) return null;
        
        const keyword = this.current.value;
        
        // join ARG1 ARG2 (or join ARG1 join ARG2 join ARG3 ...)
        if (keyword === "join") {
            this.advance(); // consume 'join'
            const arg1 = this.parseOperatorArg();
            const arg2 = this.parseOperatorArg();
            return { type: "operators", name: "join", args: [arg1, arg2] };
        }
        
        // pick random ARG1 to ARG2
        if (keyword === "pick") {
            this.advance(); // consume 'pick'
            this.skipIrrelevant();
            if (this.matchKeyword("random")) {
                this.advance(); // consume 'random'
                const arg1 = this.parseOperatorArg();
                // Skip 'to' keyword if present
                this.skipIrrelevant();
                if (this.matchKeyword("to")) {
                    this.advance();
                }
                const arg2 = this.parseOperatorArg();
                return { type: "operators", name: "random", args: [arg1, arg2] };
            }
            // Just 'pick' without 'random' - unexpected, backtrack would be needed
            // For now, return null and let the caller handle it
            return null;
        }
        
        // length of ARG
        if (keyword === "length") {
            this.advance(); // consume 'length'
            this.skipIrrelevant();
            if (this.matchKeyword("of")) {
                this.advance(); // consume 'of'
            }
            const arg = this.parseOperatorArg();
            return { type: "operators", name: "length", args: [arg] };
        }
        
        // letter ARG1 of ARG2
        if (keyword === "letter") {
            this.advance(); // consume 'letter'
            const indexArg = this.parseOperatorArg();
            this.skipIrrelevant();
            if (this.matchKeyword("of")) {
                this.advance(); // consume 'of'
            }
            const stringArg = this.parseOperatorArg();
            return { type: "operators", name: "letter", args: [indexArg, stringArg] };
        }
        
        // distance to ARG
        if (keyword === "distance") {
            this.advance(); // consume 'distance'
            this.skipIrrelevant();
            if (this.matchKeyword("to")) {
                this.advance(); // consume 'to'
            }
            const arg = this.parseOperatorArg();
            return { type: "sensing", name: "distanceTo", args: [arg] };
        }
        
        // round ARG
        if (keyword === "round") {
            this.advance(); // consume 'round'
            const arg = this.parseOperatorArg();
            return { type: "operators", name: "round", args: [arg] };
        }
        
        // abs of ARG, sqrt of ARG, floor of ARG, ceiling of ARG, sin of ARG, cos of ARG, etc.
        const mathFunctions = ["abs", "floor", "ceiling", "sqrt", "sin", "cos", "tan", "asin", "acos", "atan", "ln", "log"];
        if (mathFunctions.includes(keyword)) {
            this.advance(); // consume the function name
            this.skipIrrelevant();
            if (this.matchKeyword("of")) {
                this.advance(); // consume 'of'
            }
            const arg = this.parseOperatorArg();
            return { type: "operators", name: keyword, args: [arg] };
        }
        
        // item ARG1 of ARG2 (list access)
        if (keyword === "item") {
            this.advance(); // consume 'item'
            const indexArg = this.parseOperatorArg();
            this.skipIrrelevant();
            if (this.matchKeyword("of")) {
                this.advance(); // consume 'of'
            }
            const listArg = this.parseOperatorArg();
            return { type: "list", name: "itemOf", args: [indexArg, listArg] };
        }
        
        return null;
    }
    
    /**
     * Parse a single argument for an inline operator.
     * Can be: number, string, variable reference, parenthesized expression, or another inline operator.
     */
    private parseOperatorArg(): string | number | BlockNode {
        this.skipIrrelevant();
        
        if (this.isAtEnd()) return "";
        
        // Number
        if (this.match(TokenType.NUMBER)) {
            return parseFloat(this.advance().value);
        }
        
        // String
        if (this.match(TokenType.STRING)) {
            return this.advance().value;
        }
        
        // Parenthesized expression
        if (this.match(TokenType.PARENTHESIS_OPEN)) {
            return this.parseExpression();
        }
        
        // Identifier (variable reference)
        if (this.match(TokenType.IDENTIFIER)) {
            const identifierName = this.advance().value;
            if (this.declaredVariables.has(identifierName)) {
                return `$${identifierName}`;
            } else if (this.declaredLists.has(identifierName)) {
                return `#${identifierName}`;
            }
            return `$${identifierName}`;
        }
        
        // Keyword - could be a variable, built-in reporter, or another inline operator
        if (this.match(TokenType.KEYWORD)) {
            // Check for special targets first (these are literal string values, not variable references)
            const specialTargets = ["mouse-pointer", "random", "edge", "_edge_", "_myself_"];
            if (specialTargets.includes(this.current.value)) {
                return this.advance().value;  // Return as literal string, not variable reference
            }
            
            // Check for multi-word built-in reporters first
            const multiWordReporter = this.tryMatchMultiWordReporter();
            if (multiWordReporter) {
                return `$${multiWordReporter}`;
            }
            
            // Check for single-word built-in reporters
            if (Parser.SINGLE_WORD_REPORTERS.includes(this.current.value)) {
                return `$${this.advance().value}`;
            }
            
            // Check if this is another inline operator (nested)
            const nestedOperator = this.tryParseInlineOperator();
            if (nestedOperator) {
                return nestedOperator;
            }
            
            // Check if it's a declared variable/list
            const keyword = this.current.value;
            if (this.declaredVariables.has(keyword)) {
                this.advance();
                return `$${keyword}`;
            }
            if (this.declaredLists.has(keyword)) {
                this.advance();
                return `#${keyword}`;
            }
            
            // Otherwise just return the keyword value (could be 'to', 'of', etc. - the caller will handle)
            // Don't consume it - let the caller decide
            return "";
        }
        
        return "";
    }

    // parseBlockArguments: Parse arguments for a block based on its type
    private parseBlockArguments(): (string | number | BlockNode)[] {
        const args: (string | number | BlockNode)[] = [];
        
        // Keywords that can be inline operators (should be parsed as args, not block starts)
        const inlineOperatorKeywords = ["join", "pick", "length", "letter", "distance", "round", 
            "abs", "floor", "ceiling", "sqrt", "sin", "cos", "tan", "asin", "acos", "atan", "ln", "log",
            "item", "contains"];

        // Continue parsing arguments until we hit a new block, indentation change, or end of line
        while (!this.isAtEnd()) {
            this.skipIrrelevant();

            if (this.isAtEnd()) break;

            // Stop if we encounter indent/dedent
            if (this.match(TokenType.INDENT) || this.match(TokenType.DEDENT)) {
                break;
            }
            
            // Stop if we encounter the 'end' keyword - it terminates blocks, not an argument
            if (this.matchKeyword("end")) {
                break;
            }
            
            // Check for keywords that could be block starts OR inline operators
            if (this.match(TokenType.KEYWORD)) {
                const keyword = this.current.value;
                
                // If it's an inline operator keyword, try to parse it as such
                if (inlineOperatorKeywords.includes(keyword)) {
                    const inlineOp = this.tryParseInlineOperator();
                    if (inlineOp) {
                        args.push(inlineOp);
                        continue;
                    }
                }
                
                // If it's a block start keyword (and NOT an inline operator), stop parsing args
                if (this.isBlockStart()) {
                    break;
                }
            }

            // Parse different types of arguments
            if (this.match(TokenType.STRING)) {
                // String argument
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                // Number argument
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                // First check if this starts a multi-word built-in reporter
                const multiWordReporter = this.tryMatchMultiWordReporter();
                if (multiWordReporter) {
                    // It's a built-in reporter like "current date" or "mouse x"
                    args.push(`$${multiWordReporter}`);
                    continue;
                }
                
                // Check if this identifier is a declared variable or list
                const token = this.current;
                const identifierName = this.advance().value;
                
                // Check if it's a known variable or list
                if (this.declaredVariables.has(identifierName)) {
                    // It's a declared variable - prefix with $ for code generator
                    args.push(`$${identifierName}`);
                } else if (this.declaredLists.has(identifierName)) {
                    // Check if this is "listName contains item" pattern
                    this.skipIrrelevant();
                    if (!this.isAtEnd() && this.matchKeyword("contains")) {
                        this.advance(); // consume 'contains'
                        const itemArg = this.parseOperatorArg();
                        args.push({ type: "list", name: "contains", args: [`#${identifierName}`, itemArg] } as BlockNode);
                    } else {
                        // It's a declared list - prefix with # for code generator
                        args.push(`#${identifierName}`);
                    }
                } else if (!Lexer.RESERVED_KEYWORDS.has(identifierName)) {
                    // Unknown identifier - could be undeclared variable
                    this.addError(
                        ErrorCodes.UNDECLARED_VARIABLE,
                        `I don't know what '${identifierName}' is. Did you forget to create it first?`,
                        token,
                        ` Before you can use a variable, you need to create it! Add this line at the top of your code:\n   var ${identifierName} = 0\nor for a list:\n   list ${identifierName} = []`
                    );
                    // Still push it as a variable reference (with $) in case they want to run anyway
                    args.push(`$${identifierName}`);
                } else {
                    // It's a reserved keyword used as identifier, just push as-is
                    args.push(identifierName);
                }
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                // Nested expression in parentheses
                args.push(this.parseExpression());
            } else if (this.match(TokenType.BRACKET_OPEN)) {
                // Brackets are not allowed in block arguments (only for list init)
                const bracketToken = this.current;
                this.addError(
                    ErrorCodes.INVALID_BRACKET,
                    "Square brackets [...] don't work here!",
                    bracketToken,
                    " Just use the variable name directly without brackets. For example, write 'score' instead of '[score]'."
                );
                // Skip the bracketed content
                this.advance(); // Skip '['
                while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance();
                }
                if (this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance(); // Skip ']'
                }
            } else if (this.match(TokenType.KEYWORD)) {
                // Check if this starts a multi-word built-in reporter
                const multiWordReporter = this.tryMatchMultiWordReporter();
                if (multiWordReporter) {
                    // It's a built-in reporter like "current date" or "mouse x"
                    args.push(`$${multiWordReporter}`);
                } else if (Parser.SINGLE_WORD_REPORTERS.includes(this.current.value)) {
                    // It's a single-word built-in reporter like "answer" or "timer"
                    args.push(`$${this.advance().value}`);
                } else {
                    // Try to parse as an inline operator (join, pick random, length of, etc.)
                    const inlineOp = this.tryParseInlineOperator();
                    if (inlineOp) {
                        args.push(inlineOp);
                    } else {
                        // Single keyword argument
                        args.push(this.advance().value);
                    }
                }
            } else if (this.match(TokenType.OPERATOR)) {
                // Operator
                args.push(this.advance().value);
            } else if (this.match(TokenType.COLON)) {
                // Colon (for x: y: syntax)
                args.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        return args;
    }

    // parseExpression: Parse a parenthesized expression
    private parseExpression(): BlockNode {
        this.consume(TokenType.PARENTHESIS_OPEN, "Expected '('");

        const args: (string | number | BlockNode)[] = [];

        // Keywords that act as operators inside expressions
        const operatorKeywords = ["mod", "and", "or", "not"];
        
        // Keywords that can be inline operators (should be parsed as nested blocks, not variable refs)
        const inlineOperatorKeywords = ["join", "pick", "length", "letter", "distance", "round", 
            "abs", "floor", "ceiling", "sqrt", "sin", "cos", "tan", "asin", "acos", "atan", "ln", "log",
            "item", "contains"];

        // Parse the expression until we hit the closing parenthesis
        while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
            if (this.match(TokenType.STRING)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                args.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                const identifierName = this.advance().value;
                // Check if it's a variable or list and prefix accordingly
                if (this.declaredVariables.has(identifierName)) {
                    args.push(`$${identifierName}`);
                } else if (this.declaredLists.has(identifierName)) {
                    args.push(`#${identifierName}`);
                } else {
                    // Unknown identifier - treat as variable reference anyway
                    args.push(`$${identifierName}`);
                }
            } else if (this.match(TokenType.OPERATOR)) {
                args.push(this.advance().value);
            } else if (this.match(TokenType.KEYWORD)) {
                // Handle keywords inside expressions
                const keyword = this.current.value;
                
                // First, try to parse as an inline operator (join, length of, pick random, etc.)
                if (inlineOperatorKeywords.includes(keyword)) {
                    const inlineOp = this.tryParseInlineOperator();
                    if (inlineOp) {
                        args.push(inlineOp);
                        continue;
                    }
                }
                
                // Try to match multi-word built-in reporters
                const multiWordReporter = this.tryMatchMultiWordReporter();
                if (multiWordReporter) {
                    args.push(`$${multiWordReporter}`);
                } else if (Parser.SINGLE_WORD_REPORTERS.includes(keyword)) {
                    // It's a single-word built-in reporter like "answer" or "timer"
                    args.push(`$${this.advance().value}`);
                } else if (operatorKeywords.includes(keyword)) {
                    // Keywords that act as operators (mod, and, or, not)
                    args.push(this.advance().value);
                } else if (this.declaredVariables.has(keyword)) {
                    // Keywords that match declared variable names - treat as variable
                    this.advance();
                    args.push(`$${keyword}`);
                } else if (this.declaredLists.has(keyword)) {
                    // Keywords that match declared list names - treat as list
                    this.advance();
                    args.push(`#${keyword}`);
                } else {
                    // Other keywords in expressions - might be a variable reference
                    // (user might use keywords as variable names before declaration check)
                    this.advance();
                    args.push(`$${keyword}`);
                }
            } else if (this.match(TokenType.PARENTHESIS_OPEN)) {
                args.push(this.parseExpression());
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.PARENTHESIS_CLOSE, "Expected ')'");

        // Create an operator block for the expression
        return {
            type: "operators",
            name: "expression",
            args,
        };
    }

    // Single-word built-in reporters that should be recognized as variable references
    private static SINGLE_WORD_REPORTERS = [
        "direction",  // Motion
        "size",       // Looks
        "volume",     // Sound
        "answer",     // Sensing
        "loudness",   // Sensing
        "timer",      // Sensing
        "username",   // Sensing
    ];

    // Multi-word built-in reporter patterns
    // Order matters - longer patterns should be first to match greedily
    private static MULTI_WORD_REPORTERS = [
        // 4-word patterns
        ["current", "day", "of", "week"],
        ["days", "since", "2000"],
        // 2-word patterns
        ["x", "position"],
        ["y", "position"],
        ["costume", "number"],
        ["costume", "name"],
        ["backdrop", "number"],
        ["backdrop", "name"],
        ["mouse", "x"],
        ["mouse", "y"],
        ["current", "year"],
        ["current", "month"],
        ["current", "date"],
        ["current", "hour"],
        ["current", "minute"],
        ["current", "second"],
    ];

    // Try to match a multi-word built-in reporter starting at current position
    // Returns the full reporter name if matched, null otherwise
    private tryMatchMultiWordReporter(): string | null {
        for (const pattern of Parser.MULTI_WORD_REPORTERS) {
            if (this.matchesMultiWordPattern(pattern)) {
                // Consume all tokens in the pattern
                const words: string[] = [];
                for (let i = 0; i < pattern.length; i++) {
                    words.push(this.advance().value);
                }
                return words.join(" ");
            }
        }
        return null;
    }

    // Check if the tokens at current position match a multi-word pattern
    private matchesMultiWordPattern(pattern: string[]): boolean {
        for (let i = 0; i < pattern.length; i++) {
            const lookAhead = i === 0 ? this.current : this.peek(i);
            if (!lookAhead || lookAhead.value !== pattern[i]) {
                return false;
            }
        }
        return true;
    }

    // parseListLiteral: Parse a list literal [value1, value2, ...]
    // Also handles [varName] and [effectName] in Scratch syntax
    private parseListLiteral(): (string | number)[] {
        this.consume(TokenType.BRACKET_OPEN, "Expected '['");

        const values: (string | number)[] = [];

        // Parse list values until we hit the closing bracket
        while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
            // Skip commas between values
            if (this.match(TokenType.COMMA)) {
                this.advance();
                continue;
            }

            if (this.match(TokenType.STRING)) {
                values.push(this.advance().value);
            } else if (this.match(TokenType.NUMBER)) {
                values.push(parseFloat(this.advance().value));
            } else if (this.match(TokenType.IDENTIFIER)) {
                values.push(this.advance().value);
            } else if (this.match(TokenType.KEYWORD)) {
                // Keywords inside brackets should be treated as values (e.g., [color], [ghost])
                values.push(this.advance().value);
            } else {
                // Skip other tokens
                this.advance();
            }
        }

        this.consume(TokenType.BRACKET_CLOSE, "Expected ']'");

        return values;
    }

    // parseVariableDeclaration: Parses a variable declaration.
    private parseVariableDeclaration(program: Program): void {
        // Skip 'var' or 'variable' keyword
        const varKeywordToken = this.advance();

        // Expect a variable name (identifier or keyword that could be used as a name)
        if (!this.match(TokenType.IDENTIFIER) && !this.match(TokenType.KEYWORD)) {
            this.addError(
                ErrorCodes.INVALID_SYNTAX,
                "Hmm, I need a name for this variable!",
                varKeywordToken,
                " After 'var', write a name for your variable. Names should start with a letter and can include letters, numbers, and underscores. Example: var myScore = 0"
            );
            this.synchronize();
            return;
        }
        
        const nameToken = this.advance();
        const variableName = nameToken.value;

        // Check if the variable name is a built-in reporter (check this FIRST)
        if (BUILTIN_REPORTERS.has(variableName)) {
            this.addError(
                ErrorCodes.RESERVED_KEYWORD,
                `'${variableName}' is already a special Whiskers value! You can't use it as a variable name.`,
                nameToken,
                ` Names like 'x position', 'timer', and 'answer' are already used by Whiskers. Pick a different name, like 'myScore' or 'playerName'.`
            );
            this.synchronize();
            return;
        }

        // Check if the variable name is a reserved keyword
        if (Lexer.RESERVED_KEYWORDS.has(variableName)) {
            this.addError(
                ErrorCodes.RESERVED_KEYWORD,
                `'${variableName}' is a special word in Whiskers! You can't use it as a variable name.`,
                nameToken,
                ` Some words like 'color', 'ghost', and 'repeat' have special meanings. Pick a different name for your variable, like 'myColor' or 'count'.`
            );
            this.synchronize();
            return;
        }

        // Add to declared variables
        this.declaredVariables.add(variableName);

        // Check for initial value assignment
        let initialValue: string | number | object | undefined | null = 0; // Default value

        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse the initial value
            if (this.match(TokenType.NUMBER)) {
                initialValue = parseFloat(this.advance().value);
            } else if (this.match(TokenType.STRING)) {
                initialValue = this.advance().value;
            } else if (this.match(TokenType.IDENTIFIER)) {
                initialValue = this.advance().value;
            } else {
                this.addError(
                    ErrorCodes.MISSING_VALUE,
                    "Expected a value after '=' in variable declaration.",
                    this.current,
                    "Provide an initial value like: var score = 0 or var name = \"Player\""
                );
            }
        }

        // Add the variable to the program
        program.variables.set(variableName, initialValue);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseListDeclaration: Parses a list declaration.
    private parseListDeclaration(program: Program): void {
        // Skip 'list' keyword
        const listKeywordToken = this.advance();

        // Expect a list name (identifier)
        if (!this.match(TokenType.IDENTIFIER)) {
            this.addError(
                ErrorCodes.INVALID_SYNTAX,
                "Hmm, I need a name for this list!",
                listKeywordToken,
                " After 'list', write a name for your list. Names should start with a letter and can include letters, numbers, and underscores. Example: list myItems = []"
            );
            this.synchronize();
            return;
        }
        
        const nameToken = this.advance();
        const listName = nameToken.value;

        // Check if the list name is a reserved keyword
        if (Lexer.RESERVED_KEYWORDS.has(listName)) {
            this.addError(
                ErrorCodes.RESERVED_KEYWORD,
                `'${listName}' is a special word in Whiskers! You can't use it as a list name.`,
                nameToken,
                ` Some words like 'color', 'ghost', and 'repeat' have special meanings. Pick a different name for your list, like 'myList' or 'items'.`
            );
            this.synchronize();
            return;
        }

        // Add to declared lists
        this.declaredLists.add(listName);

        // Initialize with an empty list
        let listValues: (string | number | object | undefined | null)[] = [];

        // Check for initial values - ONLY [] is allowed
        if (!this.isAtEnd() && this.match(TokenType.OPERATOR) && this.current.value === "=") {
            this.advance(); // Skip '='

            // Parse list initialization - must be []
            if (this.match(TokenType.BRACKET_OPEN)) {
                const openBracket = this.advance();
                
                // Check if it's empty []
                if (this.match(TokenType.BRACKET_CLOSE)) {
                    this.advance(); // Skip ']'
                    // Empty list - this is valid
                } else {
                    // Non-empty brackets - not allowed
                    this.addError(
                        ErrorCodes.INVALID_BRACKET,
                        "Lists need to start empty! You can add items later.",
                        openBracket,
                        " Create an empty list first with: list myList = []\nThen add items using: add \"apple\" to myList"
                    );
                    // Skip to closing bracket
                    while (!this.isAtEnd() && !this.match(TokenType.BRACKET_CLOSE)) {
                        this.advance();
                    }
                    if (this.match(TokenType.BRACKET_CLOSE)) {
                        this.advance();
                    }
                }
            } else {
                this.addError(
                    ErrorCodes.INVALID_SYNTAX,
                    "Lists need to be created with empty brackets [].",
                    this.current,
                    " Write it like this: list myList = []"
                );
            }
        }

        // Add the list to the program
        program.lists.set(listName, listValues);

        // Skip to the end of the declaration (usually a newline)
        while (!this.isAtEnd() && !this.match(TokenType.NEWLINE)) {
            this.advance();
        }
    }

    // parseCustomBlockDefinition: Parse a custom block definition (procedure).
    private parseCustomBlockDefinition(program: Program): void {
        // Skip 'define' keyword
        this.advance();

        // Expect the block name (identifier)
        const blockName = this.consume(TokenType.IDENTIFIER, "Expected custom block name").value;

        // Parse parameter list if available
        const parameters: string[] = [];

        if (!this.isAtEnd() && this.match(TokenType.PARENTHESIS_OPEN)) {
            this.advance(); // Skip '('

            // Parse parameters until closing parenthesis
            while (!this.isAtEnd() && !this.match(TokenType.PARENTHESIS_CLOSE)) {
                if (this.match(TokenType.IDENTIFIER)) {
                    parameters.push(this.advance().value);
                } else if (this.match(TokenType.COMMA)) {
                    this.advance(); // Skip commas between parameters
                } else {
                    this.advance(); // Skip other tokens
                }
            }

            if (!this.isAtEnd()) {
                this.advance(); // Skip ')'
            }
        }

        // Create a custom block script
        const customScript: Script = {
            blocks: [],
        };

        // Parse the custom block body
        this.skipIrrelevant();

        if (!this.isAtEnd() && this.match(TokenType.INDENT)) {
            this.advance(); // Skip indent

            // Reset indentation for parsing this block
            const oldIndentLevel = this.indentLevel;
            this.indentLevel = 1;

            // Parse the body of the custom block
            this.parseScriptBlocks(customScript);

            // Restore indentation level
            this.indentLevel = oldIndentLevel;
        }

        // Add this custom block to the program
        // For now, we'll add it as a special script with metadata
        customScript.blocks.unshift({
            type: "custom",
            name: "define",
            args: [blockName, ...parameters],
        });

        program.scripts.push(customScript);
    }
}
